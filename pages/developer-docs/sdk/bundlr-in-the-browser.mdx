---
description: Using the WebBundlr class to interact with Bundlr from the browser
---

import { Callout } from "nextra-theme-docs";

# Bundlr In The Browser (WebBundlr)

<Callout emoji="ðŸš€">
	If you're using Bundlr with React and `npx create-react-app`, you will need to follow [some extra setup
	steps](/developer-docs/recipes/react).
</Callout>

To use Bundlr with browser wallets like MetaMask and Phantom, use the `WebBundlr` class. Usage is similar to the Bundlr class used with server-side development, however you donâ€™t need to provide a private key as that will be linked via the userâ€™s wallet. When functions that require signing are called (upload, fund, withdraw etc.) the linked wallet will prompt the user to confirm the required actions.

If youâ€™d prefer to learn using a long-form tutorial, [we have this one on creating a web-based uploader with progress bars](/tutorials/file-uploader).

Provider setup varies based on wallet type / version:

[Ethers 5](/developer-docs/sdk/bundlr-in-the-browser#ethers-5) | [Ethers 6](/developer-docs/sdk/bundlr-in-the-browser#ethers-6) | [RainbowKit / WAGMI](/developer-docs/sdk/bundlr-in-the-browser#rainbowkit-v1) | [viem](/developer-docs/sdk/bundlr-in-the-browser#viem) | [WalletConnect](/developer-docs/sdk/bundlr-in-the-browser#walletconnect) | [Phantom](/developer-docs/sdk/bundlr-in-the-browser#phantom) | [Near](/developer-docs/sdk/bundlr-in-the-browser#near)

## Ethers 5

```js
import { WebBundlr } from "@bundlr-network/client";
import { providers } from "ethers";

await window.ethereum.enable();
const provider = new providers.Web3Provider(window.ethereum);
const bundlr = new WebBundlr("https://node2.bundlr.network", "matic", provider);
await bundlr.ready();
```

## Ethers 6

Import our SDK and connect to a Bundlr node using injected providers and ethers version 6.

```js
import { WebBundlr } from "@bundlr-network/client";
import { ethers } from "ethers";
import BigNumber from "bignumber.js";

const provider = new ethers.BrowserProvider(window.ethereum);

provider.getGasPrice = async () => {
	const gp = +((await provider.getFeeData()).gasPrice?.toString() ?? 0);
	console.log("getGasPrice", gp, typeof gp);
	return gp;
};

const e = provider.estimateGas.bind(provider);
provider.estimateGas = async (tx) => {
	const est = +((await e(tx))?.toString() ?? 0);
	return { mul: (n) => +est * +n };
};

const signer = await provider.getSigner();

signer.estimateGas = e;
signer.getGasPrice = provider.getGasPrice;
provider.getSigner = () => signer;

signer._signTypedData = (domain, types, value) => signer.signTypedData(domain, types, value);

const bundlr = new WebBundlr("https://devnet.bundlr.network/", "matic", provider, {
	providerUrl: "https://rpc-mumbai.maticvigil.com/",
});

bundlr.currencyConfig.createTx = async (amount, to) => {
	const estimatedGas = await signer.estimateGas({ to, from: bundlr.address, amount });
	const gasPrice = await signer.getGasPrice();
	const txr = await signer.populateTransaction({
		// eslint-disable-next-line no-undef
		to,
		from: bundlr.address,
		value: BigInt(amount),
		gasPrice,
		gasLimit: estimatedGas,
	});
	return { txId: undefined, tx: txr };
};

bundlr.currencyConfig.getTx = async function (txId: string): Promise<Tx> {
	const provider = this.providerInstance;
	const response = await provider.getTransaction(txId);

	if (!response) throw new Error("Tx doesn't exist");
	if (!response.to) throw new Error(`Unable to resolve transactions ${txId} receiver`);

	return {
		from: response.from,
		to: response.to,
		blockHeight: response.blockNumber ? new BigNumber(response.blockNumber) : undefined,
		amount: new BigNumber(response.value),
		pending: response.blockNumber ? false : true,
		confirmed: response.confirmations >= this.minConfirm,
	};
};
await bundlr.ready();
```

## RainbowKit v1

```js
import { WebBundlr } from "@bundlr-network/client";
import { ethers } from "ethers";
import { mainnet, polygonMumbai } from "viem/chains";
import { createWalletClient, custom, parseEther } from "viem";
import { usePrepareSendTransaction, useSendTransaction } from "wagmi";

const url = "https://devnet.bundlr.network";
const currency = "matic";
const providerUrl = "https://rpc-mumbai.maticvigil.com";

const client = createWalletClient({
	chain: mainnet,
	transport: custom(window.ethereum),
});
//@ts-expect-error injected
client.getSigner = () => client;
//@ts-expect-error injected
client.getAddress = async () => client.getAddresses().then((a) => a[0]);

const bundlr = new WebBundlr(url, currency, client, { providerUrl });

// @ts-expect-error
bundlr.currencyConfig.getFee = async (_amount, _to): Promise<number> => {
	return 0;
};

// if you're using react hooks:
bundlr.currencyConfig.sendTx = async (data): Promise<string> => {
	const { sendTransaction } = useSendTransaction(data);
	await sendTransaction?.();
	// make this function return the transaction id
	// think it's
	return data.hash;
};

bundlr.currencyConfig.createTx = async (
	amount: string | number,
	to: string,
	_fee?: string,
): Promise<{ txId: string | undefined; tx: any }> => {
	const { config } = usePrepareSendTransaction({
		to, //@ts-expect-error weird type
		value: parseEther(+amount),
	});
	return { txId: undefined, tx: config };
};

// Otherwise
bundlr.currencyConfig.sendTx = async (data): Promise<string> => {
	const hash = await client.sendTransaction({
		to: data.to,
		value: parseEther(data.amount.toString()),
		account: bundlr.address as `0x${string}`,
	});
	return hash;
};

bundlr.currencyConfig.createTx = async (amount, to, fee): Promise<{ txId: string | undefined; tx: any }> => {
	// dummy value/method
	return { txId: undefined, tx: { amount, to, fee } };
};

await bundlr.ready();
//@ts-expect-error injected
client._signTypedData = async (domain, types, message) => {
	message["Transaction hash"] = "0x" + Buffer.from(message["Transaction hash"]).toString("hex");
	//@ts-ignore
	return await client.signTypedData({
		domain,
		message,
		types,
		account: bundlr.address!,
		primaryType: "Bundlr",
	});
};
```

## viem

```js
import { WebBundlr } from "@bundlr-network/client";
import { createWalletClient, custom } from "viem";
import { mainnet } from "viem/chains";

const client = createWalletClient({
	chain: mainnet,
	transport: custom(window.ethereum),
});
client.getSigner = () => client;
client.getAddress = async () => client.getAddresses().then((a) => a[0]);

const bundlr = new WebBundlr("https://node1.bundlr.network", "matic", client);
await bundlr.ready();
```

## WalletConnect

```js
import { WebBundlr } from "@bundlr-network/client";

import { ethers } from "ethers";
import WalletConnectProvider from "@walletconnect/web3-provider";

const connector = await new WalletConnectProvider({
	rpc: "https://cloudflare-eth.com/",
}).enable();
const provider = new ethers.BrowserProvider(connector);

const bundlr = new WebBundlr("https://node1.bundlr.network", "matic", provider);
await bundlr.ready();
```

## Phantom

```js
import { WebBundlr } from "@bundlr-network/client";
import { PhantomWalletAdapter } from "@solana/wallet-adapter-phantom";
await window.solana.connect();
const provider = new PhantomWalletAdapter();
await provider.connect();

const bundlr = new WebBundlr("https://node1.bundlr.network", "solana", provider);
await bundlr.ready();
```

## Near

```js
import { WebBundlr } from "@bundlr-network/client";
import { connect, keyStores, WalletConnection } from "near-api-js";

const config = {
	networkId: "mainnet",
	keyStore: new keyStores.BrowserLocalStorageKeyStore(),
	nodeUrl: "https://rpc.mainnet.near.org",
	walletUrl: "https://wallet.mainnet.near.org",
	helperUrl: "https://helper.mainnet.near.org",
	explorerUrl: "https://explorer.mainnet.near.org",
	headers: {},
};
const near = await connect(config);
const wallet = new WalletConnection(near, "bundlr");
wallet.requestSignIn({
	contractId: "",
});

const bundlr = new WebBundlr("https://node1.bundlr.network", "near", wallet);
await bundlr.ready();
```
