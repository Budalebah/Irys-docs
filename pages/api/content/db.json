[{
  "url": "/developer-docs/cli/commands/balance",
  "title": "balance",
  "description": "Funds the node with the specified amount of tokens.",
  "text": "balance Returns the amount of funds available on the specified node. Provide your public wallet address as an argument, along with: Parameters-n: The network to check. Values are mainnet or devnet (if you omit, the default is mainnet). -t: The token to use when funding. --provider-url: RPC URL to use. This is only required when using Devnet.ExamplesMainnet irys balance 0xac568a981b1370b2e1baa8ce30bd5ac9e28c572d \\-t matic \\Devnet irys balance 0x591B5Ce7cA10a55A9B5d1516eF89693D5b3586b8 \\-t matic \\-n devnet \\--provider-url https://rpc-mumbai.maticvigil.comDevnet RPC URLs change often, use a recent one from https://chainlist.org/ ",
  "origin": "docs"
},{
  "url": "/developer-docs/cli/commands/fund",
  "title": "fund",
  "description": "Funds the node with the specified amount of tokens.",
  "text": "fund Fund Irys' mainnet or devnet with the specified amount of tokens.Not all calls to fund will post immediately to your account, some blockchains are faster than others. When funding with AR, it can take upwards of 40 minutes before the balance post. For MATIC, ETH and SOL, balances will usually post inParameters-n: The network to check. Values are mainnet or devnet (if you omit, the default is mainnet). -t: The token to use when funding. -w: Your private key. --provider-url: RPC URL to use. This is only required when using Devnet.ExamplesMainnet irys fund 1000000000000000 \\-t matic \\-w bf20......c9885307Devnet irys fund 1000000000000000 \\-n devnet \\-t matic \\-w bf20......c9885307 \\--provider-url https://rpc-mumbai.maticvigil.comDevnet RPC URLs change often, use a recent one from https://chainlist.org/ ",
  "origin": "docs"
},{
  "url": "/developer-docs/cli/commands/price",
  "title": "price",
  "description": "Funds the node with the specified amount of tokens.",
  "text": "price Checks the price to upload the specified number of bytes. Parameters-t: The token used for payment. -n: The network to check. Values are mainnet or devnet (if you omit, the default is mainnet). --provider-url: RPC URL to use. This is only required when using Devnet.ExamplesMainnet irys price 1000000 \\-t maticDevnet irys price 1000000 \\-t matic \\-n devnet \\--provider-url https://rpc-mumbai.maticvigil.comDevnet RPC URLs change often, use a recent one from https://chainlist.org/ ",
  "origin": "docs"
},{
  "url": "/developer-docs/cli/commands/upload-dir",
  "title": "upload-dir",
  "description": "Funds the node with the specified amount of tokens.",
  "text": "upload-dir Uploads an entire directory of files. Parameters-n: The network to check. Values are mainnet or devnet (if you omit, the default is mainnet). -t: The token to use when uploading. -w: Your private key. --index-file: Name of the file to use as an index for manifests. --provider-url: RPC URL to use. This is only required when using Devnet.ExamplesMainnet irys upload-dir ./myImages \\-t matic \\-w bf20......c9885307Devnet irys upload-dir ./myImages \\-n devnet \\-t matic \\-w bf20......c9885307 \\--provider-url https://rpc-mumbai.maticvigil.comDevnet RPC URLs change often, use a recent one from https://chainlist.org/ Downloading Files uploaded via irys upload-dir can be retrieved in one of two ways. Creating a URL with the format https://gateway.irys.xyz/[manifest-id]/[original-file-name]. Creating a URL using the transaction ID of each individual file uploaded with the format https://gateway.irys.xyz/[transacton-id] After a successful folder upload, two files are written to your local project directory: [folder_name].csv [folder_name].json The example below highlights a folder called “llama_folder” with a total of 5 files in it. The transaction id for each file can be used to retrieve the uploaded data by forming a URL with the format https://gateway.irys.xyz]/[transaction-id] ",
  "origin": "docs"
},{
  "url": "/developer-docs/cli/commands/upload",
  "title": "upload",
  "description": "Funds the node with the specified amount of tokens.",
  "text": "upload Uploads a single file. Parameters-n: The network to check. Values are mainnet or devnet (if you omit, the default is mainnet). -t: The token to use when uploading. -w: Your private key. --tags: Tags to include, format ` ` --provider-url: RPC URL to use. This is only required when using Devnet.ExamplesMainnet irys upload myImage.png \\-t matic \\-w bf20......c9885307 \\--tags tagName1 tagValue1 tagName2 tagValue2Devnet irys upload myImage.png \\-n devnet \\-t matic \\-w bf20......c9885307 \\--tags tagName1 tagValue1 tagName2 tagValue2 \\--provider-url https://rpc-mumbai.maticvigil.comDevnet RPC URLs change often, use a recent one from https://chainlist.org/ Downloading Files uploaded via irys upload can be downloaded using the transaction ID provided after a successful upload. irys upload myImage.png \\-n mainnet \\-t matic \\-w bf20......c9885307 \\--tags tagName1 tagValue1 tagName2 tagValue2 Loaded address: 0xac568a981b1370b2e1baa8ce30bd5ac9e28c572d Uploaded to https://gateway.irys.xyz/yPX6rwxfJ2gTvXSHGoumIvlFR-EwuRlUMmHpeLHUM `",
  "origin": "docs"
},{
  "url": "/developer-docs/cli/commands/withdraw",
  "title": "withdraw",
  "description": "Funds the node with the specified amount of tokens.",
  "text": "withdraw Withdraws funds from either Irys' mainnet or devnet.Not all calls to withdraw will post immediately to your account, some blockchains are faster than others. When funding with AR, it can take upwards of 40 minutes before the balance post. For MATIC, ETH and SOL, balances will usually post inParameters-n: The network to check. Values are mainnet or devnet (if you omit, the default is mainnet). -t: The token to withdraw. -w: Your private key. --provider-url: RPC URL to use. This is only required when using Devnet.ExamplesMainnet irys withdraw 1000000000000000 \\-t matic \\-w bf20......c9885307Devnet irys withdraw 1000000000000000 \\-n devnet \\-t matic \\-w bf20......c9885307 \\--provider-url https://rpc-mumbai.maticvigil.comDevnet RPC URLs change often, use a recent one from https://chainlist.org/ ",
  "origin": "docs"
},{
  "url": "/developer-docs/cli",
  "title": "CLI",
  "description": "Use Irys from your CLI",
  "text": "CLIPermanently store files on Arweave using Irys' Command Line Interface (CLI). Prerequisites To install our CLI, you will need to install a current version of node first.Installing the CLI Install our CLI globally using the -g flag. Depending on your setup, you may or may not need to use sudo. npm i -g @irys/sdk sudo npm i -g @irys/sdkUsing private keys When executing CLI commands involving funding nodes or signing transactions, you must provide a private key. Use the -w flag to specify a private key along with the -c flag to indicate the token you'll use. irys -w-tThe methods for supplying private keys differ for Ethereum and Solana compared to Arweave.Ethereum / Solana For Ethereum and Solana, specify the private key directly in the command line every time you execute a CLI command. Note that the CLI does not store the private key, it needs to be included with each command. irys fund 1000000000000000 -t matic -w bf20......c9885307 -n mainnetArweave When using Arweave, the private key is typically stored in a file (commonly named wallet.json). This file is then referenced in the CLI command, instead of specifying the private key directly. irys fund 1000000000000000 -t arweave -w wallet.json -n mainnetNetworks Fund the network you plan to upload to.Mainnet irys -n mainnetDevnet irys -n devnet When connecting to Devnet, you must supply the additional --provider-url parameter. irys -n devnet --provider-url https://rpc-mumbai.maticvigil.comDevnet RPC URLs change often, use a recent one from https://chainlist.org/ Funding Use the fund command to fund a node. irys fund 1000000000000000 -n mainnet -t matic -w bf20......c9885307Withdrawing funds Use the withdraw command to withdraw funds from a node. irys withdraw 1000000000000000 -n mainnet -t matic -w bf20......c9885307Uploading a file Use the upload command to upload a file. irys upload myImage.png -n mainnet -t matic -w bf20......c9885307Uploading a folder Use the upload-dir command to upload a folder. irys upload-dir ./myImages -n mainnet -t matic -w bf20......c9885307Using tags Use the -t option, followed by a series of name / value pairs to append metadata tags to your upload. Irys supports adding any optional metadata tags to each upload. When uploading files with a filename extension, the related Content-Type (MIME type) tag is automatically added. irys upload myImage.png -t tagName1 tagValue1 tagName2 tagValue2 -n mainnet -t matic -w bf20......c9885307Pricing Use the price command, followed by a number of bytes to get the cost to upload that number of bytes. You must also provide a token (-t) and a node URL (-h) irys price 1000000 -t matic -n mainnet `",
  "origin": "docs"
},{
  "url": "/developer-docs/downloading",
  "title": "Downloading data",
  "description": "Instantly downloading data from a network of gateways",
  "text": "Downloading data Once data is uploaded to Irys, it becomes instantly accessible through gateways, which work hand in hand with our optimistic cache. To download data, use the transaction id to query the relevant gateway. There are multiple gateways, including those running open source software that can be spun up by anyone. Here are examples of how to use the two most common ones.Irys gatewayURL format https://gateway.irys.xyz/[transaction-id]Example https://gateway.irys.xyz/CO9EpX0lekJEfXUOeXncUmMuG8eEp5WJHXl9U9yZUYAArweave gatewayURL format https://arweave.net/[transaction-id]Example https://arweave.net/CO9EpX0lekJEfXUOeXncUmMuG8eEp5WJHXl9U9yZUYA",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/api/fund",
  "title": "irys.fund(amount)",
  "description": "Funds the node with the specified amount of tokens",
  "text": "irys.fund(amount) Funds the Irys network you connected to with the specified number of tokens. For more information on how funding and withdrawing are handled, see our docs. Parametersamount: The amount to fund ([in atomic units](/developer-docs/irys-sdk/api/utils-toAtomic)) multiplier: Fee multiplier (optional) Returnsresponse: A JSON object with the following values response = {id, // The transaction id of the fund transferquantity, // How much is being transferredreward, // The amount taken by the network as a feetarget, // The address the funds were sent to };Upfront funding You can up-front fund a node, where you send over enough funds to cover all of a project’s uploads. When upfront funding, you may want to write a script to monitor your stored balance, topping up when needed. try {const irys = await getIrys();const fundTx = await irys.fund(irys.utils.toAtomic(0.05));console.log(Successfully funded ${irys.utils.fromAtomic(fundTx.quantity)} ${irys.token}); } catch (e) {console.log(\"\"Error funding node \"\", e); }Lazy-funding You can also lazy-fund a node where you check the cost to upload each file first and then transfer exact funds. This works best with currencies like MATIC, ETH and SOL whose balances post (almost) instantly. try {const irys = await getIrys();const pathToFile = \"\"./myNFT.png\"\";const { size } = await fs.promises.stat(pathToFile);const price = await irys.getPrice(size);await irys.fund(price);const { id } = await irys.uploadFile(pathToFile);console.log(${pathToFile} --> Uploaded to https://gateway.irys.xyz/${id}); } catch (e) {console.log(\"\"Error funding node \"\", e); }Not all calls to irys.fund() will post immediately to your account, some blockchains are faster than others. When funding with AR, it can take upwards of 40 minutes before the balance post. For MATIC, ETH and SOL, balances will usually post in Fee multiplier The multiplier parameter multiplies the fees we allow the network to take, in effect prioritizing the transaction. Normally you can safely ignore this parameter, however, if you're experiencing errors when funding, you can try passing a value of 1.2 or more. try {const irys = await getIrys();const fundTx = await irys.fund(irys.utils.toAtomic(0.05), 1.2);console.log(Successfully funded ${irys.utils.fromAtomic(fundTx.quantity)} ${irys.token}); } catch (e) {console.log(\"\"Error funding node \"\", e); }Paid RPCs When transferring tokens we use public RPCs. Sometimes these can be slow to confirm transactions. If you're experiencing an error when funding, consider using a paid RPC. const network = \"\"devnet; const providerUrl = \"\"\"\"; // Paid RPC URL const token = \"\"matic\"\"; const privateKey = process.env.PRIVATE_KEY; const irys = new Irys({network, // URL of the node you want to connect totoken, // Currency used for paymentkey: privateKey, // ETH or SOL private keyconfig: { providerUrl }, }); `",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/api/funder-submitFundTransaction",
  "title": "irys.funder.submitFundTransaction(txID)",
  "description": "Returns the receipt associated with the supplied transaction id",
  "text": "irys.funder.submitFundTransaction(txID) Tells a node to re-evaluate a funding transaction. Parameters txID: The ID of the funding transaction to re-evaluate. Returnsresponse: A JSON object with the following values response = {id, // The transaction id of the fund transferquantity, // How much is being transferredreward, // The amount taken by the network as a feetarget, // The address the funds were sent to }; Example const irys = await getIrys(); try {// First get a receiptconst fundTx = await irys.fund(irys.utils.toAtomic(0.05));const response = await irys.funder.submitFundTransaction(fundTx.id); } catch (e) {console.log(\"\"Error funding \"\", e); } `",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/api/getLoadedBalance",
  "title": "irys.getLoadedBalance()",
  "description": "Returns the connected wallet's balance on the connected node",
  "text": "irys.getLoadedBalance() Returns the connected wallet's balance on the connected node. Returns loadedBalance: Wallet balance on the connected node in atomic units. You can convert it into standard units using irys.utils.fromAtomic(atomicUnits). Example const irys = await getIrys(); // Get loaded balance in atomic units const atomicBalance = await irys.getLoadedBalance(); console.log(Node balance (atomic units) = ${atomicBalance}); // Convert balance to standard const convertedBalance = irys.utils.fromAtomic(atomicBalance); console.log(Node balance (converted) = ${convertedBalance}); `",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/api/getPrice",
  "title": "irys.getPrice(numBytes)",
  "description": "Returns the cost to upload the specified number of bytes",
  "text": "irys.getPrice(numBytes) Returns the cost to upload the specified number of bytes. Parameters numBytes: The number of bytes to check the price for Returnsprice: Cost to upload numBytes, unit is the token specified when instantiating the Irys objectReturn value is in atomic units, to convert to standard units use irys.utils.fromAtomic() Example const irys = await getIrys(); const numBytes = 1048576; // Number of bytes to check const priceAtomic = await irys.getPrice(numBytes); // Convert from atomic units to standard units const priceConverted = irys.utils.fromAtomic(numBytes); console.log(Uploading ${numBytes} bytes costs ${priceConverted}); `",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/api/upload",
  "title": "irys.upload(data, tags)",
  "description": "Uploads data",
  "text": "irys.upload(data, tags) Permanently uploads data. Parametersdata: The data to upload tags: Optional metatags Returns receipt: A receipt in the form of a JSON object with the following values: response = {id, // Transaction id (used to download the data)timestamp, // Timestamp (UNIX milliseconds) of when the transaction was created and verifiedversion, // The version of this JSON file, currently 1.0.0public, // Public key of the bundler node usedsignature, // A signed deep hash of the JSON receiptdeadlineHeight, // The block number by which the transaction must be finalized on Arweaveblock, // DeprecatedvalidatorSignatures, // Deprecatedverify, // An async function used to verify the receipt at any time } Example const irys = await getIrys(); const dataToUpload = \"\"GM world.\"\"; try {const receipt = await irys.upload(dataToUpload);console.log(Data uploaded ==> https://gateway.irys.xyz/${receipt.id}); } catch (e) {console.log(\"\"Error uploading data \"\", e); }The transaction id returned as part of the response is used to download the data, simply create a URL with theformat https://gateway.irys.xyz/[transaction-id]. ",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/api/uploadFile",
  "title": "irys.uploadFile(fileName, tags)",
  "description": "Uploads a file",
  "text": "irys.uploadFile(fileName, tags) Permanently uploads a file. ParametersfileName: Name of the file to upload tags: Optional metatags Returnsreceipt: A receipt in the form of a JSON object with the following values: response = {id, // Transaction id (used to download the data)timestamp, // Timestamp (UNIX milliseconds) of when the transaction was created and verifiedversion, // The version of this JSON file, currently 1.0.0public, // Public key of the bundler node usedsignature, // A signed deep hash of the JSON receiptdeadlineHeight, // The block number by which the transaction must be finalized on Arweaveblock, // DeprecatedvalidatorSignatures, // Deprecatedverify, // An async function used to verify the receipt at any time } Example const irys = await getIrys(); // Your file const fileToUpload = \"\"./myImage.png\"\"; // Add a custom tag that tells the gateway how to serve this file to a browser const tags = [{ name: \"\"Content-Type\"\", value: \"\"image/png\"\" }]; try {const response = await irys.uploadFile(fileToUpload, tags);console.log(File uploaded ==> https://gateway.irys.xyz/${response.id}); } catch (e) {console.log(\"\"Error uploading file \"\", e); }The transaction id returned as part of the response is used to download the data, simply create a URL with theformat https://gateway.irys.xyz/[transaction-id]. ",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/api/uploadFolder",
  "title": "uploadFolder()",
  "description": "Uploads a folder of files to Irys",
  "text": "uploadFolder() Permanently uploads a group of files in a single transaction. When using the method on the server (Irys), you provide the path to a folder which is then uploaded. When using the method in the browser (WebIrys), you pass an array of File objects that are then uploaded. Irys WebIrysirys.uploadFolder() ParametersfolderToUpload: Path to the folder being uploaded indexFile: (optional) The name of anindex file also included in the folder you upload. If provided, this index file will load when a user requestshttps://gateway.irys.xyz/[manifest_id] batchSize: (optional) The number of files to upload at once. keepDeleted: (optional) Whether to keep now deleted items from previous uploads. When you upload a folder, the file names are indexed and saved. If you then re-upload that same folder, Irys will only upload new files added since the previous upload. In the case where you delete files from your source directory, this flag tells Irys whether to keep those deleted files in the index or remove them. Returnsresponse: A JSON object with the following values {id, // Transaction id (used to download the data)timestamp, // Timestamp (UNIX milliseconds) of when the transaction was created and verifiedversion, // The version of this JSON file, currently 1.0.0public, // Public key of the bundler node usedsignature, // A signed deep hash of the JSON receiptdeadlineHeight, // The block number by which the transaction must be finalized on Arweaveblock, // DeprecatedvalidatorSignatures, // Deprecatedverify, // An async function used to verify the receipt at any time } Example const irys = await getIrys(); // Upload an entire folder const folderToUpload = \"\"./my-images/\"\"; // Path to folder try {const response = await irys.uploadFolder(\"\"./\"\" + folderToUpload, {indexFile: \"\"\"\", // Optional index file (file the user will load when accessing the manifest)batchSize: 50, // Number of items to upload at oncekeepDeleted: false, // Whether to keep now deleted items from previous uploads});console.log(Files uploaded. Manifest ID ${response.id}); } catch (e) {console.log(\"\"Error uploading file \"\", e); }webIrys.uploadFolder() Parametersfiles: An array of TaggedFile objects, each containing a File and an array of tags to be added to that file indexFileRelPath: (optional) The name of anindex file also included in the folder you upload. If provided, this index file will load when a user requestshttps://gateway.irys.xyz/[manifest_id] throwawayKey: (optional) Your own throwaway JWK to use for signing (i.e if you want to use the same one for more than one set of uploads). seperateManifestTx: (optional) If true, the manifest transaction will be excluded from the bundle making its tags indexable and queryable. Returnsmanifest: A JSON object with the following values {id, // Manifest IDtimestamp, // Timestamp (UNIX milliseconds) of when the transaction was created and verifiedversion, // The version of this JSON file, currently 1.0.0public, // Public key of the bundler node usedsignature, // A signed deep hash of the JSON receiptdeadlineHeight, // The block number by which the transaction must be finalized on Arweaveblock, // DeprecatedvalidatorSignatures, // Deprecatedverify, // An async function used to verify the receipt at any time } Example const webIrys = await getWebIrys(); const files: File[] = []; const tags: { name: string; value: string } = []; // Set files and tags in your UI // Convert to TaggedFile objects const taggedFiles = files.map((f: TaggedFile, i: number) => {f.tags = tags[i];return f; }); // Optional parameters const uploadOptions = {indexFileRelPath: \"\"./index.html\"\",manifestTags: myTags,throwawayKey: myKey,seperateManifestTx: true, }; const response = await webIrys.uploadFolder(taggedFiles, uploadOptions); Returns A JSON object containing the following values. A receipt is also generated which can be retrieved using irys.utils.getReceipt(response.id) {id, // Transaction IDmanifestId, // Manifest IDmanifest, // The manifesttxs, // An array of DataItems, one for each entry in the bundletimestamp, // Timestamp (UNIX milliseconds) of when the transaction was created and verifiedversion, // The version of this JSON file, currently 1.0.0public, // Public key of the bundler node usedsignature, // A signed deep hash of the JSON receiptdeadlineHeight, // The block number by which the transaction must be finalized on Arweaveblock, // DeprecatedvalidatorSignatures, // Deprecatedverify, // An async function used to verify the receipt at any time }Downloading Files uploaded via uploadFolder() can be retrieved in one of two ways. Creating a URL with the format https://gateway.irys.xyz/[manifest-id]/[original-file-name]. Creating a URL using the transaction ID of each individual file uploaded with the format https://gateway.irys.xyz/[transacton-id] After a successful folder upload, two files are written to your local project directory [foldername].csv and [foldername].json. The example below highlights a folder called “llama_folder” with a total of 5 files in it. The transaction id for each file can be used to retrieve the uploaded data by forming a URL with the format https://gateway.irys.xyz]/[transaction-id] ",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/api/uploader-uploadBundle",
  "title": "upload.uploadBundle(tx)",
  "description": "Uploads an array of transactions as a bundle",
  "text": "upload.uploadBundle(tx) Permanently uploads an array of transactions as a bundle in a single transaction. This function is provided for users who need to obtain each transaction's ID before uploading. Most users will opt to use irys.uploadFolder(), an abstraction that handles the uploading, signing and bundling in a single function call. Parametersdata: The data to upload tags: Optional metatags Returns receipt: A receipt in the form of a JSON object with the following values: response = {id, // Transaction id (used to download the data)timestamp, // Timestamp (UNIX milliseconds) of when the transaction was created and verifiedversion, // The version of this JSON file, currently 1.0.0public, // Public key of the bundler node usedsignature, // A signed deep hash of the JSON receiptdeadlineHeight, // The block number by which the transaction must be finalized on Arweaveblock, // DeprecatedvalidatorSignatures, // Deprecatedverify, // An async function used to verify the receipt at any time } Example const irys = await getIrys(); const maxTxs = 5; const txs = []; for (let i = 0; iThe transaction id returned as part of the response is used to download the data, simply create a URL with theformat https://gateway.irys.xyz/[transaction-id]. ",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/api/utils-fromAtomic",
  "title": "irys.utils.fromAtomic(value)",
  "description": "Converts from atomic to standard units",
  "text": "irys.utils.fromAtomic(value) Converts from atomic to standard units. Parametersvalue: The value to be converted ReturnsstandardValue: The value in standard units Example const irys = await getIrys(); const atomicBalance = await irys.getLoadedBalance(); const convertedBalance = irys.utils.fromAtomic(atomicBalance).toString();Atomic units refer to the smallest possible unit of a given cryptocurrency. In Ethereum, atomic units are calledWei, and they represent the smallest unit of Ether. Similar to how 1 dollar can be broken down into 100 cents, 1Ether can be broken down into 10^18 Wei. In Solana, atomic units are called Lamports, 1 SOL can be broken down into10^9 Lamports. ",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/api/utils-getReceipt",
  "title": "irys.utils.getReceipt(trasnactionId)",
  "description": "Returns the receipt associated with the supplied transaction id",
  "text": "irys.utils.getReceipt(trasnactionId) Returns the receipt associated with the supplied transaction id, or an error if no receipt is found. ParameterstransactionId: The transaction ID associated with the receipt Returnsresponse: A JSON object with the following values response = {id, // Transaction id (used to download the data)timestamp, // Timestamp (UNIX milliseconds) of when the transaction was created and verifiedversion, // The version of this JSON file, currently 1.0.0public, // Public key of the bundler node usedsignature, // A signed deep hash of the JSON receiptdeadlineHeight, // The block number by which the transaction must be finalized on Arweaveblock, // DeprecatedvalidatorSignatures, // Deprecatedverify, // An async function used to verify the receipt at any time } Example const irys = await getIrys(); try {const transactionID = \"\"i9tgbHsr6c1sxryAQ-SLM2rfQAYRuyap7RmGgH28mI4\"\"; // Your transaction Idconst receipt = await irys.utils.getReceipt(transactionID);console.log(receipt); } catch (e) {console.log(\"\"Error getting receipt \"\", e); } `",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/api/utils-toAtomic",
  "title": "irys.utils.toAtomic(value)",
  "description": "Converts from standard to atomic units",
  "text": "irys.utils.toAtomic(value) Converts from standard to atomic units. Parameters value: The value to be converted ReturnsatomicValue: The value in atomic units Example const irys = await getIrys(); const amountAtomic = irys.utils.toAtomic(amountStandard);Atomic units refer to the smallest possible unit of a given cryptocurrency. In Ethereum, atomic units are calledWei, and they represent the smallest unit of Ether. Similar to how 1 dollar can be broken down into 100 cents, 1Ether can be broken down into 10^18 Wei. In Solana, atomic units are called Lamports, 1 SOL can be broken down into10^9 Lamports. ",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/api/utils-verifyReceipt",
  "title": "irys.utils.verifyReceipt(receipt)",
  "description": "Returns the receipt associated with the supplied transaction id",
  "text": "irys.utils.verifyReceipt(receipt) Returns true or false, indicating if a receipt is valid or not. Parameters receipt: The receipt as a JSON object in the following format {id, // Transaction idpublic, // Public key of the bundler node usedsignature, // A signed deep hash of the JSON receiptdeadlineHeight, // The block number by which the transaction must be finalized on Arweavetimestamp, // Timestamp (UNIX milliseconds) of when the transaction was created and verifiedversion, // The version of this JSON file, currently 1.0.0 } ReturnsisValid: A true or false value indicating if the receipt is valid Example const irys = await getIrys(); try {// First get a receiptconst transactionID = \"\"i9tgbHsr6c1sxryAQ-SLM2rfQAYRuyap7RmGgH28mI4\"\"; // Your transaction Idconst receipt = await irys.utils.getReceipt(transactionID);// Then verify itconst isReceiptValid = await irys.utils.verifyReceipt(receipt);console.log(isReceiptValid); } catch (e) {console.log(\"\"Error getting receipt \"\", e); } `",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/api/withdrawBalance",
  "title": "irys.withdrawBalance(amount)",
  "description": "Withdraws the supplied amount",
  "text": "irys.withdrawBalance(amount) Withdraws the supplied amount. The parameter value must in atomic units. Parameters amount: The amount to withdraw. Value must be in atomic units. Returnsresponse: Either a 400 or 200 code, combined with the following values: 400 - something went wrong response.data = \"\"Not enough balance for requested withdrawal\"\" 200 - Ok response.data = {requested, // the requested amount,fee, // the reward required by the network (network fee)final, // total cost to your account (requested + fee)tx-id, // the ID of the withdrawal transaction } Example const irys = await getIrys(); try {// 1. Get current balanceconst curBalance = await irys.getLoadedBalance();// 2. Withdraw allconst response = await irys.withdrawBalance(curBalance);console.log(Successfully withdrew ${irys.utils.fromAtomic(curBalance)} ${irys.token}); } catch (e) {console.log(\"\"Error uploading data \"\", e); } `",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/balance-approvals",
  "title": "Balance approvals",
  "description": "Create an app",
  "text": "Balance approvals Balance approvals allow for the sharing of balances between multiple addresses. Use balance approvals to pay for your users' uploads while still allowing those users to sign the transactions themselves. Balance approvals: Are non-transferable. Can be configured to expire automatically. Are based on the token set when connecting to an Irys node. Both approver and approvee must use the sametoken. Are registered instantly upon upload completion.Create an approval const approvalReceipt = await irys.approval.createApproval({amount: irys.utils.toAtomic(1), // Amount in atomic unitsapprovedAddress: \"\"address\"\",expiresInSeconds: 100, // Expires in 100 seconds. Delete to remove expiration. });Upload using an approval const approvedReceipt = await irys.upload(\"\"GM World\"\", { upload: { paidBy: \"\"payerAddress\"\" } });Revoke an approval const revocationReceipt = await irys.approval.revokeApproval({ approvedAddress: \"\"address\"\" });Get remaining approval balance & and expiration date const approval = await irys.approval.getApprovedBalance({ approvedAddress: \"\"address\"\" }); `",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/chunked-uploader/connecting-node",
  "title": "Connecting to a node",
  "description": "Sample code for connecting to a node",
  "text": "Connecting to a node When using the chunking uploader, first connect to a node using the same flow as with our default uploader and then follow that by requesting the chunked uploader using irys.uploader.chunkedUploader. You can use any of our public and Devnet node addresses.The chunkedUploader object reference must be updated before each subsequent upload, it can not be reused.let irys = await getIrys(); let uploader = irys.uploader.chunkedUploader; `",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/chunked-uploader/controlling-the-upload",
  "title": "Controlling the upload",
  "description": "Pausing and resuming uploads",
  "text": "Controlling the upload Uploads created with the chunked uploader can be paused and resumed at any time using the functions uploader.pause() and uploader.resume(). For these functions to work, the initial call to uploader.uploadData() or uploader.uploadTransaction() must not be preceded with the await keyword. To resume an upload from a new uploader instance, you must use the same: Token Network (mainnet or devnet) Input data Configured chunk sizeuploader.pause() and uploader.resume() const irys = await getIrys(); // When uploading smaller files, it's common to use the await keyword before // uploadData() or uploadTransaction(). This causes execution to pause until the file // is fully uploaded. If you omit await, the upload happens in the background // and you can use pause and resume as needed. transaction = irys.createTransaction(\"\"Hello, world!\"\"); uploader = irys.uploader.chunkedUploader; // Recreate for each transaction const upload = uploader.uploadTransaction(transaction); uploader.pause(); // Pauses the upload console.log(\"\"Upload paused\"\"); uploader.resume(); // Resumes the upload console.log(\"\"Upload resumed\"\"); While the initial call to uploader.uploadData() or uploader.uploadTransaction() should not use the await keyword, you can use it down the line to ensure the upload is complete. You can call await at ANY TIME to ensure the upload has is complete. response = await upload; `",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/chunked-uploader/data-mode",
  "title": "Data mode",
  "description": "Automate transaction creation in data mode",
  "text": "Data mode The chunked uploader has two modes of operation, data mode and transaction mode. When using data mode do not create a transaction, this will be done automatically for you. Within data mode, you can either upload using: A buffer containing the data you want to upload. A readable stream pointing to the data you want to upload.uploader.uploadData() // The uploader has two modes of operation, data mode and transaction mode. // When using data mode, do not create a transaction, this will be done // automatically for you. const transactionOptions = { tags: [{ name: \"\"Content-Type\"\", value: \"\"text/plain\"\" }] }; // Within data mode you have two options: // 1. Using a Buffer containing just the data you want to upload. const dataBuffer = Buffer.from(\"\"Hello, world!\"\"); const response = await uploader.uploadData(dataBuffer, transactionOptions); // The transaction id (used to query the network) is found in response.data.id console.log(Data buffer uploaded ==> https://gateway.irys.xyz/${response.data.id}); // 2. Using a Readable (stream) pointing to the data uploader = irys.uploader.chunkedUploader; // Recreate for each transaction const dataStream = fs.createReadStream(\"\"./data.txt\"\"); response = await uploader.uploadData(dataStream, transactionOptions); console.log(Read Stream uploaded ==> https://gateway.irys.xyz/${response.data.id}); `",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/chunked-uploader/expired-uploads",
  "title": "Expired uploads",
  "description": "Recovering expired uploads",
  "text": "Expired uploads Paused uploads will expire after a period of inactivity. If you do need to recover an expired upload, use the following: const resumeData = uploader.getResumeData(); // Get the data required to resume the upload with a new instance uploader.setResumeData(resumeData); // Set resume data await uploader.uploadTransaction(dataItem); // Upload as normal `",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/chunked-uploader/setting-upload-parameters",
  "title": "Setting upload parameters",
  "description": "Changing batch and chunk size",
  "text": "Setting upload parameterssetBatchSize() and uploader.setUploadSize() The default batch size (number of chunks to upload at once) is 5, the default chunk size (maximum chunk size) is 25MB. These values can be changed using the functions uploader.setBatchSize(size) and uploader.setUploadSize(size). // Optionally change the batch size (default is 5) uploader.setBatchSize(10); // Optionally change the chunk size (default is 25MB) // Value is in bytes uploader.setChunkSize(500000); `",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/chunked-uploader/transaction-mode",
  "title": "Transaction mode",
  "description": "Access fine-grained control over transactions",
  "text": "Transaction mode Transaction mode gives you more fine-grained control over the upload workflow. You can create and sign your transaction first, store it, and then upload when it makes the most sense for your application.uploadTransaction() uploader = irys.uploader.chunkedUploader; // Recreate for each transaction const transaction = irys.createTransaction(\"\"Hello, world!\"\"); await transaction.sign(); response = await uploader.uploadTransaction(transaction); console.log(Transaction mode uploaded ==> https://gateway.irys.xyz/${response.data.id}); `",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/chunked-uploader/upload-events",
  "title": "Upload events",
  "description": "Track upload progress with event callbacks",
  "text": "Upload events The uploader emits three events during each upload. These can be subscribed to for any use case when tracking upload progress is needed. chunkUpload`: Emitted whenever a chunk is uploaded. chunkError`: Emitted whenever a chunk upload fails. Due to internal retry logic, these errors can most likely be ignored as long as the upload doesn't error overall. done`: Emitted when the upload completes. uploader.on(\"\"chunkUpload\"\", (chunkInfo) => {console.log(Uploaded Chunk number ${chunkInfo.id}, offset of ${chunkInfo.offset}, size ${chunkInfo.size} Bytes, with a total of ${chunkInfo.totalUploaded} bytes uploaded.,); }); uploader.on(\"\"chunkError\"\", (e) => {console.error(Error uploading chunk number ${e.id} - ${e.res.statusText}); }); uploader.on(\"\"done\"\", (finishRes) => {console.log(Upload completed with ID ${finishRes.id}); }); `",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/chunked-uploader",
  "title": "Chunked uploader",
  "description": "A fault-tolerant, resumable, signer & uploader",
  "text": "Chunked uploader The chunked uploader is a fault-tolerant, resumable, stream-based signer and uploader. It allows you to pause and resume uploads, and to do things like create progress bars that show upload progress. The chunked uploader is supported both with Irys / NodeJS on the server and with WebIrys in the browser. Key Terminology: Batch size - the maximum number of chunks to upload at once. Defaults to 5. Chunk size - the maximum size of a single chunk. Defaults to 25MB. For those with slower/unstable connections, reducing both should lead to improved reliability. For those with faster connections, increasing both will lead to higher throughput, at the cost of more memory (and CPU).The default uploder (accessed via irys.upload()) does chunking automatically. You only need to use the ChunkedUploader to access advanced features like pausing and resuming uploads, changing batch size, and changing chunksize. ",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/community-sdk",
  "title": "Community SDKs (unofficial)",
  "description": "Use Golang, and other languages, with Irys",
  "text": "Community SDKs (unofficial) In addition to the official Irys JavaScript / TypeScript SDK, there are also SDKs in other languages built by our community. Looking to implement our SDK in a new language? Reach out to us on Discord for help.Go Irys Go SDK Maintained by Javad Rajabzadeh",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/installing-the-sdk",
  "title": "Installing The SDK",
  "description": "Installing the SDK with Npm and Yarn",
  "text": "Installing The SDK The Irys SDK can be installed using npm: npm install @irys/sdk or yarn: yarn add @irys/sdkIf you get a warning saying bigint: Failed to load bindings, pure JS will be used (try npm run rebuild?) duringinstall, it can be safely ignored. For details on how make it go away, see our [troubleshootingguide](/developer-docs/irys-sdk/troubleshooting#bigint). ",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/ipfs-cid",
  "title": "IPFS Content IDs",
  "description": "Use IPFS CIDs when addressing data on Irys.",
  "text": "IPFS Content IDs In addition to using Irys transaction IDs, you can also use IPFS Content IDs (CIDs) when addressing data on Irys.Irys does not currently verify that CIDs match their uploaded data. This will be added in a future release. Content IDs vs transaction IDs IPFS and Irys take a different approach to identifying data, IPFS uses Content Identifiers (CIDs) and Irys uses transaction IDs. IPFS Content Identifiers (CIDs) are generated by hashing the content being uploaded. The same data uploaded twice will generate the same CID. Irys transaction IDs are generated by hashing the content + metadata being uploaded. All uploads have a unique transaction ID.Uploading with a CID To upload data to Irys using a CID, embed it as the value of the IPFS-CID tag when uploading data.This code example generates a CID using the ipfs-only-hash package which uses the SHA-256 algorithm by default. IPFSalso allows CIDs to be generated using SHA3 and Blake2, all of which are supported when uploading to Irys.const generateCID = async (content) => {return await IPFS.of(content); }; const uploadToIrysWithCID = async () => {// See: https://docs.irys.xyz/developer-docs/irys-sdk#connecting-to-irysconst irys = await getIrys();const dataToUpload = \"\"Irys + IPFS Content ID\"\";const contentID = await generateCID(dataToUpload);console.log(ContentID=${contentID});const tags = [{ name: \"\"Content-Type\"\", value: \"\"text/html\"\" },{ name: \"\"IPFS-CID\"\", value: contentID },];const receipt = await irys.upload(dataToUpload, { tags: tags });// You can download using either the Irys transaction ID or IPFS Content IDconsole.log(Transaction ID URL https://gateway.irys.xyz/${receipt.id});console.log(Content ID URL https://gateway.irys.xyz/ipfs/${contentID}); };Downloading with a CID To download data tagged with a CID, request it from the Irys gateway using a URL in the format https://gateway.irys.xyz/ipfs/:contentID.If the same CID is assigned to more than one transaction, the Irys gateway will always return the one with theearliest timestamp.const fetchData = async (ipfsCID) => {const url = https://gateway.irys.xyz/ipfs/${ipfsCID};console.log(URL: ${url});const response = await fetch(url);const data = await response.text();console.log(DATA: ${data}); };Migrating data from IPFS to Irys You can migrate data from IPFS to Irys by first downloading the data from an IPFS gateway and then uploading it to Irys. Users can choose to tag the uploads with the original IPFS CID and continue to retrieve data using the CID, or switch to using Irys transaction IDs. This code example shows how to: Download data from an IPFS gateway Determine the data's content type (for example: image/png) Re-upload the data to Irys while tagging it with the existing content typePrior to uploading, users must fund an Irys node. Most users will choose to [up-frontfund](/developer-docs/irys-sdk/api/fund#upfront-funding) where they pre-fund an Irys node with sufficient tokens tocover all data being migrated. Users can also choose to lazy-fundthe uploads where you fund each separate upload.const uploadToIrysWithCID = async (dataToUpload, contentType, contentID) => {// See: https://docs.irys.xyz/developer-docs/irys-sdk#connecting-to-irysconst irys = await getIrys();const tags = [{ name: \"\"Content-Type\"\", value: contentType },{ name: \"\"IPFS-CID\"\", value: contentID },];const receipt = await irys.upload(dataToUpload, { tags: tags });console.log(Direct URL: https://gateway.irys.xyz/${receipt.id});console.log(Content ID URL: https://gateway.irys.xyz/ipfs/${contentID}); }; const downloadAndDetermineContentType = async (ipfsCID) => {try {const ipfsURL = https://ipfs.io/ipfs/${ipfsCID};const response = await fetch(ipfsURL);const arrayBuffer = await response.arrayBuffer();const buffer = Buffer.from(arrayBuffer);const contentType = await fileTypeFromBuffer(buffer);if (contentType) {console.log(Content Type: ${contentType.mime});await uploadToIrysWithCID(buffer, contentType.mime, ipfsCID);} else {console.error(\"\"Unable to determine content type\"\");}} catch (error) {console.error(\"\"Error:\"\", error);} }; const ipfsCID = \"\"QmUgL4YbnW9vMWZXLdAFzgxJwxpxJapZRLpjoT2ubU5WmF\"\"; downloadAndDetermineContentType(ipfsCID); `",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/irys-in-the-browser",
  "title": "Irys in the browser",
  "description": "Using the WebIrys class to interact with Irys from the browser",
  "text": "Irys in the browserWorking with Irys in the browser is similar to working with our server-side SDK, however there are a few differences which are demonstrated below. In addition to creating your own components using the code below, you can also fork the [Irys provenance toolkit](/developer-docs/provenance-toolkit) and quickly build your project using its rich UI component library and helper functions.If you're using Irys with React and npx create-react-app, you will need to [follow some extra setupsteps](/hands-on/tutorials/react). Installing Install using npm: npm install @irys/sdk or yarn: yarn add @irys/sdkImportingConnecting to a node When instantiating a WebIrys object pass: network: Either \"\"mainnet\"\" or \"\"devnet\"\" token: Payment token wallet: A wallet object containing the end-user's injected provider and the name of the provider package your project uses const getWebIrys = async () => {// Ethers5 providerawait window.ethereum.enable();const provider = new providers.Web3Provider(window.ethereum);const network = \"\"mainnet\"\";const token = \"\"matic\"\";// Devnet RPC URLs change often, use a recent one from https://chainlist.orgconst rpcUrl = \"\"\"\";// Create a wallet objectconst wallet = { rpcUrl: rpcUrl, name: \"\"ethersv5\"\", provider: provider };// Use the wallet objectconst webIrys = new WebIrys({ network, token, wallet });await webIrys.ready();return webIrys; }; After instantiating the object, call webIrys.ready().Supported providers WebIrys supports the following providers. When instantiating a new WebIrys object, you must pass in the name of the provider you will be using. | Package| Parameter value | | --------------------------------------- | --------------- | | Ethers 5 | ethersv5| | Ethers 6 | ethersv6| | Solana| solana| | Viem v2| viemv2|Solana React Hooks When working with the Solana React hooks, start by wrapping your components in the Solana ConnectionProvider WalletProvider and WalletModalProvider providers. // Devnet or Mainnet const network = WalletAdapterNetwork.Devnet; const endpoint = useMemo(() => clusterApiUrl(network), [network]); const wallets = useMemo(() => [new PhantomWalletAdapter()], [network]);; Then, in components where you need to access a WebIrys object use the useWallet() hook to get a reference to the user's injected provider, and pass that into WebIrys when instantiating a new object. const wallet = useWallet(); const getIrys = async (): Promise => {// Devnet RPC URLs change often, use a recent one from https://chainlist.orgconst rpcUrl = \"\"\"\";const wallet = { rpcUrl: rpcUrl, name: \"\"solana\"\", provider: wallet };const webIrys = new WebIrys({ network: \"\"mainnet\"\", token: \"\"solana\"\", wallet });await webIrys.ready();return webIrys; };Additional providers Additionally, the following providers will work with extra setup code. | Package| Parameter value | | ------------------------------------------------------------------- | --------------- | | Arconnect | arconnect| | Othent| othent| | Privy| privy|Arconnect const getWebIrys = async () => {const arconnect = window.arweaveWallet;await arconnect.connect([\"\"ACCESSADDRESS\"\", \"\"ACCESSPUBLICKEY\"\", \"\"SIGNTRANSACTION\"\", \"\"SIGNATURE\"\"]);const webIrys = new WebIrys({ network: \"\"mainnet\"\", token: \"\"arweave\"\", wallet: { provider: arconnect } });await webIrys.ready();return webIrys; };Othent export const getWebIrys = async () => {const wallet = { name: \"\"Othent KMS\"\", provider: othentKMS };const network = \"\"mainnet\"\";const token = \"\"arweave\"\";const webIrys = new WebIrys({ network, token, wallet });await webIrys.ready();return webIrys; };Privy Initialize the Privy provider with your app ID and wrap it around your components. In most NextJS projects, you will place this code in your app.tsx file. In our example, we use the `` component as a placeholder for your app's top-level component structure.We also have a demo repository teaching how to build a PWA photo-sharing appusing Privy and Irys.; Then, write code to login with Privy and create a new WebIrys object. The code to create a WebIrys object differs depending on if you're using an external wallet vs an embedded one. When using external wallets, pass the Ethers provider returned from the Wallet object, when using embedded wallets pass the sendTransaction Privy React hook. The following code uses conditional logic to create the correct WebIrys object based on the wallet type. If your application only supports a single wallet type, feel free to simplify the code. const { wallets } = useWallets(); const { login } = usePrivy(); const { sendTransaction } = usePrivy(); // First login login(); // The 0th position wallet is the most recently used one const w = wallets.at(0); // Or find the embedded wallet // const w = wallets.find((wallet) => wallet.walletClientType === 'privy'); // Then create a WebIrys object const getWebIrys = async () => {const network = \"\"devnet\"\";const token = \"\"matic\"\";const provider = await w?.getEthersProvider();if (!provider) throw new Error(Cannot find privy wallet);const irysWallet =w?.walletClientType === \"\"privy\"\"? { name: \"\"privy-embedded\"\", provider, sendTransaction }: { name: \"\"privy\"\", provider };const webIrys = new WebIrys({network,token,wallet: irysWallet,});await webIrys.ready(); };Funding a node Fund a node using any of our supported tokens: const fundNode = async () => {const webIrys = await getWebIrys();try {const fundTx = await webIrys.fund(webIrys.utils.toAtomic(0.05));console.log(Successfully funded ${webIrys.utils.fromAtomic(fundTx.quantity)} ${webIrys.token});} catch (e) {console.log(\"\"Error uploading data \"\", e);} };Uploading The provenance toolkit contains an uploader component that can be dropped into any project to instantly enable file uploading. Data uploaded to Irys is given a millisecond-accurate timestamp, attributes and authorship details before being passed to Arweave for permanent storage. This information is used to create a signed receipt that can be used to verify the data's provenance at any time.Uploading data const uploadData = async () => {const webIrys = await getWebIrys();const dataToUpload = \"\"GM world.\"\";try {const receipt = await webIrys.upload(dataToUpload);console.log(Data uploaded ==> https://gateway.irys.xyz/${receipt.id});} catch (e) {console.log(\"\"Error uploading data \"\", e);} };Uploading a file Upload a File object. const uploadFile = async (fileToUpload: File) => {const webIrys = await getWebIrys();// Your fileconst tags = [{ name: \"\"application-id\"\", value: \"\"MyNFTDrop\"\" }];try {const receipt = await webIrys.uploadFile(fileToUpload, { tags: tags });console.log(File uploaded ==> https://gateway.irys.xyz/${receipt.id});} catch (e) {console.log(\"\"Error uploading file \"\", e);} };Uploading a folder Upload an array of File objects. Upon upload, a manifest is automatically created. Your files can be accessed https://gateway.irys.xyz/[manifestId]/[file-name]. const uploadFolder = async (files: File[], tags: Tag[]) => {const webIrys = await getIrys();try {const receipt = await webIrys.uploadFolder(files, {tags,}); //returns the manifest IDconsole.log(Files uploaded. Manifest Id=${receipt.manifestId} Receipt Id=${receipt.id});} catch (e) {console.log(\"\"Error uploading file \"\", e);} }; `",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/manual-transaction",
  "title": "Manually creating a transaction",
  "description": "Manually creating, signing and uploading a transaction.",
  "text": "Manually creating a transaction In addition to uploading using the SDK functions irys.upload(),irys.uploadFile(), and irys.uploadFolder(), you can also manually create, sign, and upload a transaction in separate steps.Workflow const tx = irys.createTransaction() await tx.sign() await tx.upload() After calling tx.sign(), you can access the transaction ID via tx.id, this facilitates use cases where you need access to the ID before uploading the full transaction.You must call tx.sign() before using the value of tx.id. Creating, signing, uploading Basic workflow. const createSignUpload = async () => {// Get a reference to a pre-configured Irys object// See: https://docs.irys.xyz/developer-docs/irys-sdk#connecting-to-irysconst irys = await getIrys();// Create the transactionconst tx = irys.createTransaction(\"\"GM World!\"\", { tags: [{ name: \"\"Content-Type\"\", value: \"\"text/plain\"\" }] });// Sign the transactionawait tx.sign(); // ID is now setconsole.log(Tx created and signed, ID=${tx.id});// Upload the transactionconst receipt = await tx.upload();console.log(Tx uploaded. https://gateway.irys.xyz/${receipt.id}); };Serializing a transaction Serialize a transaction and recreate it later. const serializationUpload = async () => {// Get a reference to a pre-configured Irys object// See: https://docs.irys.xyz/developer-docs/irys-sdk#connecting-to-irysconst irys = await getIrys();// Create the transactionconst tx1 = irys.createTransaction(\"\"GM World!\"\", { tags: [{ name: \"\"Content-Type\"\", value: \"\"text/plain\"\" }] });// Note: You can sign before or after serializingawait tx1.sign(); // ID is now setconsole.log(Tx created and signed, ID=${tx1.id});// Serialize the transactionconst txSerialized = tx1.getRaw();// Recreate the transaction from the serialized versionconst tx2 = irys.transaction.fromRaw(txSerialized);// ID is the same as beforeconsole.log(Tx re-created from serialized, ID=${tx2.id});// Upload the txconst receipt = await tx2.upload();console.log(Tx uploaded. https://gateway.irys.xyz/${receipt.id}); };Deterministic ID Use a deterministic ID in cases where you need access to a transaction ID before uploading, but can't or don't want to store a reference to the transaction object. First, generate an anchor and use that to create a transaction with your data. Then, sign the transaction and you can access the ID. Finally, you can recreate the transaction using the same anchor and data and your ID will be the same. const deterministicIDUpload = async () => {// Get a reference to a pre-configured Irys object// See: https://docs.irys.xyz/developer-docs/irys-sdk#connecting-to-irysconst irys = await getIrys();// Generate 32 bytes through Buffer.from(anchor)const anchor = randomBytes(16).toString(\"\"hex\"\");const tx1 = irys.createTransaction(\"\"GM Irys!\"\", {tags: [{ name: \"\"content-type\"\", value: \"\"text/plain\"\" }],anchor,});await tx1.sign();console.log(Tx1 ID ${tx1.id}); // ID is now setconst tx2 = irys.createTransaction(\"\"GM Irys!\"\", {tags: [{ name: \"\"content-type\"\", value: \"\"text/plain\"\" }],anchor,});await tx2.sign();console.log(Tx2 ID ${tx2.id}); // ID is the sameconst receipt = await tx2.upload();console.log(Tx uploaded. https://gateway.irys.xyz/${receipt.id}); }; `",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/migration-guide",
  "title": "Migration guide",
  "description": "Migrating from Bundlr SDK to Irys SDK",
  "text": "Migration guide Migrating your application from the Bundlr SDK to the Irys SDK is a simple process.All existing legacy packages will be maintained until October 2024 and will continue to work until at least OctoberAll domains will be supported in perpetuity (e.g., https://node1.bundlr.network) Installation Install the Irys SDK using npm: npm install @irys/sdk or yarn: yarn add @irys/sdkImports Change your import statements from: to:Name Changes Apart from rebrand to Irys, certain elements within the SDK have undergone a name change. WebBundlr and (Node)Bundlr have been changed to WebIrys and (Node)Irys respectively. \\ All usage of currency in the SDK has been replaced with token, notably the argument as part of client instantiation (see Constructor) as well as internal APIs (such as currencyConfig -> tokenConfig)Constructor In the Bundlr SDK, parameters are passed directly. In the Irys SDK, parameters are passed inside an options object. Update new Bundlr to new Irys and then wrap your constructor arguments in {}. const url = \"\"https://devnet.irys.xyz\"\"; // Devnet RPC URLs change often, use a recent one from https://chainlist.org/ const providerUrl = \"\"\"\"; const token = \"\"matic\"\"; const bundlr = new Bundlr(url, token, process.env.PRIVATE_KEY); const irys = new Irys({url, // URL of the node you want to connect totoken, // Token used to pay for uploadskey: process.env.PRIVATE_KEY, // ETH or SOL private keyconfig: { providerUrl }, // Optional provider URL, only required when using Devnet });Domain Changes With the release of the Irys SDK our domain has changed from https://bundlr.network to https://irys.xyz. When upgrading your code, you shouldsla change your Node URLs: | Bundlr Node Address| Irys Node Address| | ------------------------------- | ------------------------- | | https://node1.bundlr.network| https://node1.irys.xyz| | https://node2.bundlr.network| https://node2.irys.xyz| | https://devnet.bundlr.network | https://devnet.irys.xyz | And your GraphQL endpoints | Bundlr GraphQL Endpoint| Irys GraphQL Endpoint| | --------------------------------------- | --------------------------------- | | https://node1.bundlr.network/graphql| https://node1.irys.xyz/graphql| | https://node2.bundlr.network/graphql| https://node2.irys.xyz/graphql| | https://devnet.bundlr.network/graphql | https://devnet.irys.xyz/graphql |Changes to upload functions In the Bundlr SDK there were separate upload functions depending on whether you wanted a receipt or not. With the Irys SDK, all upload functions return a receipt. The following function is deprecated: bundlr.uploadWithReceipt() The following functions upload data as before however, the return type has changed to be a receipt. irys.upload() To upload any data irys.uploadFile() To upload a file irys.uploadFolder() To upload a folderChange to WebBundlr / WebIrys With the Bundlr SDK, using providers other than Ethers 5 required extra setup code unique to each provider. Now, we natively support multiple different provider types. When connecting to a WebIrys class, you pass both a reference to a provider and the provider type. The following example is for Ethers 5, we also have a full list of supported provider types see Irys in the browser. const getWebIrys = async () => {// Ethers5 providerawait window.ethereum.enable();const provider = new providers.Web3Provider(window.ethereum);const url = \"\"https://node1.irys.xyz\"\";const token = \"\"matic\"\";// Devnet RPC URLs change often, use a recent one from https://chainlist.org/const rpcUrl = \"\"\"\";// Create a wallet objectconst wallet = { rpcUrl: rpcUrl, name: \"\"ethersv5\"\", provider: provider };// Use the wallet objectconst webIrys = new WebIrys({ url, token, wallet });await webIrys.ready();return webIrys; }; `",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk/troubleshooting",
  "title": "Troubleshooting",
  "description": "Troubleshooting common problems",
  "text": "Troubleshooting Troubleshooting common errors during installation and use. Errors: bigint: Failed to load bindings, pure JS will be used (try npm run rebuild?) Error: Using Irys devnet requires a dev/testnet RPC to be configured Error: Not enough balance for transaction Error: Transaction simulation failed: Blockhash not foundbigint Error message: bigint: Failed to load bindings, pure JS will be used (try npm run rebuild?) This error can be safely ignored, it will not cause any issues. To make the error go away, you'll need to install updated Python and C++ build tools. MacOS Current versions of MacOS come pre-built with Python. To install the C++ build tools: First install XCode Once XCode is installed, go to Preferences, Downloads, and install the Command Line Tools Windows Windows users need to install both Python and C++ build tools. These commands must be run with administrator permissions. // First run: npm i -g --add-python-to-path --vs2015 --production windows-build-tools // Then run: npm i -g node-gyp@latest UNIX Most UNIX distributions come with Python installed. To install C++ build tools, the following works for most debian-based systems. For others, use your package manager to install \"\"GCC build tools\"\". sudo apt-get install build-essentialDevnet RPC Error message: Error: Using Irys devnet requires a dev/testnet RPC to be configured When using our devnet, you must provide the URL to a Denvet RPC for the chain you're using. As this parameter is not required when using Node 1 and 2, users will sometimes get an error if they forget to add in the RPC URL. For example, this will throw an error: const getIrys = async () => {const token = \"\"matic\"\";const irys = new Irys({network: \"\"devnet\"\",token, // Token used for paymentkey: process.env.PRIVATE_KEY, // EVM private key});return irys; }; But this will not: const getIrys = async () => {const token = \"\"matic\"\";const providerUrl = \"\"https://rpc-mumbai.maticvigil.com\"\";const irys = new Irys({network: \"\"devnet\"\",token, // Token used for paymentkey: process.env.EVMPRIVATEKEY, // EVM private keyconfig: { providerUrl }, // Optional provider URL, only required when using Devnet});return irys; }; As RPC URLs change frequently, users should always choose an up-to-date one from https://chainlist.org/Insufficient balance Error message: Error: Not enough balance for transaction This error occurs when you try to upload to a node without first funding it. This applies to both Nodes 1 and 2 where you can pay using any our supported mainnet tokens and our devnet node where you can pay using any of our supported devnet tokens. Devnet tokens can be obtained for free from common faucets like the ones for Solana, Sepolia and Mumbai.Blockhash not found Error message: Error: Transaction simulation failed: Blockhash not found Irys depends on transactions being confirmed, however, in some situations, it may be necessary to wait for the transaction to be finalized. This can be fixed by configuring Irys as follows: const irys = new Irys({url: nodeUrl,token,provider,config: { tokenOpts: { commitment: \"\"finalized\"\" } }, }); `",
  "origin": "docs"
},{
  "url": "/developer-docs/irys-sdk",
  "title": "Irys SDK",
  "description": "Quickstart with the Irys SDK",
  "text": "Irys SDKInstalling Install using npm: npm install @irys/sdk or yarn: yarn add @irys/sdkIf you get a warning saying bigint: Failed to load bindings, pure JS will be used (try npm run rebuild?) duringinstall, it can be safely ignored. For details on how make it go away, see our [troubleshootingguide](/developer-docs/irys-sdk/troubleshooting#bigint). ImportingConnecting to Irys Connect to any our mainnet or devnet, using a serialized JWK file when using an Arweave wallet: const getIrysArweave = async () => {const network = \"\"mainnet\"\";const token = \"\"arweave\"\";const key = JSON.parse(fs.readFileSync(\"\"arweaveWallet.json\"\").toString());const irys = new Irys({network, // \"\"mainnet\"\" or \"\"devnet\"\"token, // Token used for payment and signingkey, // Arweave wallet});return irys; }; Or a private key when using an EVM or Solana wallet: const getIrys = async () => {const network = \"\"mainnet\"\";// Devnet RPC URLs change often, use a recent one from https://chainlist.org/const providerUrl = \"\"\"\";const token = \"\"matic\"\";const irys = new Irys({network, // \"\"mainnet\"\" or \"\"devnet\"\"token, // Token used for paymentkey: process.env.PRIVATE_KEY, // ETH or SOL private keyconfig: { providerUrl }, // Optional provider URL, only required when using Devnet});return irys; };Provider URLs Use the providerUrl parameter to specify an RPC provider. When working with Nodes 1 and 2, this value is optional and will default to the main public RPC provider for the chosen chain. When working with Devnet, this parameter is required. When working with Aptos, use one of \"\"mainnet\"\" | \"\"testnet\"\" | \"\"devnet\"\" instead of a URL.Funding a node Fund a node using any of our supported tokens: const fundNode = async () => {const irys = await getIrys();try {const fundTx = await irys.fund(irys.utils.toAtomic(0.05));console.log(Successfully funded ${irys.utils.fromAtomic(fundTx.quantity)} ${irys.token});} catch (e) {console.log(\"\"Error uploading data \"\", e);} };Uploading Data uploaded to Irys is given a millisecond-accurate timestamp, attributes and authorship details before being passed to Arweave for permanent storage. This information is used to create a signed receipt that can be used to verify the data's provenance at any time.Uploading data const uploadData = async () => {const irys = await getIrys();const dataToUpload = \"\"GM world.\"\";try {const receipt = await irys.upload(dataToUpload);console.log(Data uploaded ==> https://gateway.irys.xyz/${receipt.id});} catch (e) {console.log(\"\"Error uploading data \"\", e);} };Uploading a file const uploadFile = async () => {const irys = await getIrys();// Your fileconst fileToUpload = \"\"./myImage.png\"\";const tags = [{ name: \"\"application-id\"\", value: \"\"MyNFTDrop\"\" }];try {const receipt = await irys.uploadFile(fileToUpload, { tags: tags });console.log(File uploaded ==> https://gateway.irys.xyz/${receipt.id});} catch (e) {console.log(\"\"Error uploading file \"\", e);} };Uploading a folder You can upload a group of files as a single transaction from both the server and the browser.When uploading a folder, files can be accessed either directly athttps://gateway.irys.xyz/[transaction-id] or https://gateway.irys.xyz/[manifest-id]/[file-name] Server const uploadFolder = async () => {const irys = await getIrys();// Upload an entire folderconst folderToUpload = \"\"./my-images/\"\"; // Path to foldertry {const receipt = await irys.uploadFolder(\"\"./\"\" + folderToUpload, {indexFile: \"\"\"\", // optional index file (file the user will load when accessing the manifest)batchSize: 50, //number of items to upload at oncekeepDeleted: false, // whether to keep now deleted items from previous uploads}); //returns the manifest IDconsole.log(Files uploaded. Manifest ID ${receipt.id});} catch (e) {console.log(\"\"Error uploading file \"\", e);} };Browser const webIrys = await getWebIrys(); const files: File[] = []; const tags: { name: string; value: string } = []; // Convert Files to TaggedFiles const taggedFiles = files.map((f: TaggedFile, i: number) => {f.tags = tags[i];return f; }); const response = await webIrys.uploadFolder(taggedFiles);Querying In addition to using the query package to search Irys and Arweave, you can also search directly from the Irys SDK. The following shows how to search for all transactions posted to Irys mainnet, paid for with Matic, and uploaded during a three day period. For more details on all search functions, see query package documentation. const result = await irys.search(\"\"irys:transactions\"\").network(\"\"mainnet\"\").token(\"\"matic\"\").fromTimestamp(new Date(\"\"2023-07-01\"\")).toTimestamp(new Date(\"\"2023-07-03\"\"));3rd party build toolsParcel If using Parcel, you will need to manually enable package exports by adding the following to the package.json file in your project root directory. {\"\"@parcel/resolver-default\"\": {\"\"packageExports\"\": true} } `",
  "origin": "docs"
},{
  "url": "/developer-docs/mutable-references",
  "title": "Mutable references",
  "description": "Mutable references enable the creation of a single, static URL that is linked to a sequential series of transactions.",
  "text": "Mutable references Mutable references enable the creation of a single, static URL that is linked to a sequential series of transactions. You can add a new transaction to the series at any time, and the URL will always resolve to the most recent transaction.To create a mutable reference: Upload a base transaction to Irys and reference it using a URL in the following format https://gateway.irys.xyz/mutable/:id const irys = await getIrys(); const receiptOne = await irys.upload(\"\"First TX\"\"); console.log(TX 1 uploaded https://gateway.irys.xyz/mutable/${receiptOne.id}); Upload an addition to the series as a new transaction, and add a tag named Root-TX with the value of the original transaction ID. const tags = [{ name: \"\"Root-TX\"\", value: receiptOne.id }]; const receiptTwo = await irys.upload(\"\"Second TX\"\", { tags: tags }); console.log(TX 2 uploaded https://gateway.irys.xyz/mutable/${receiptOne.id}); The original URL (https://gateway.irys.xyz/mutable/:id) now resolves to the second transaction in the chain.When building a transaction chain, additions must be made using the same wallet that created the original transaction.This prevents unauthorized actors from maliciously modifying someone else’s transaction chain. Granularity Mutable references are based on Irys’ millisecond-accurate timestamps. You can publish multiple sequential updates to a given transaction and be confident the transaction served by the /mutable/ endpoint will always be the most recent chronological one.Versions While the https://gateway.irys.xyz/mutable/:id endpoint will always resolve to the most recent transaction in a chain, it is possible to directly access any transaction in a chain using the transaction’s ID and a URL in the format https://gateway.irys.xyz/:id You can query a version chain using the Irys query package: const txID = \"\"WF--VR1ZERvABYy1aNYD3QJ0OAVDSUF8dTlg6zFKveQ\"\"; const fromAddress = \"\"0x591b5ce7ca10a55a9b5d1516ef89693d5b3586b8\"\"; const myQuery = new Query({ network: \"\"mainnet\"\" }); const results = await myQuery.search(\"\"irys:transactions\"\").tags([{ name: \"\"Root-TX\"\", values: [txID] }]).from([fromAddress]).sort(\"\"ASC\"\"); results.forEach((result, i) => {const formattedTimestamp = new Date(result.timestamp).toLocaleString();console.log(Update ${i + 1}: ID: ${result.id}, Timestamp: ${formattedTimestamp}); }); Or GraphQL: query getChain {transactions(tags: [{name: \"\"Root-TX\"\"values: [\"\"WF--VR1ZERvABYy1aNYD3QJ0OAVDSUF8dTlg6zFKveQ\"\"]}]owners: [\"\"0x591b5ce7ca10a55a9b5d1516ef89693d5b3586b8\"\"]order: ASC) {edges {node {idtimestamp}}} }Use-cases Irys’ mutable references open up new opportunities for builders, including: Gaming NFTs: Metadata changes based on in-game actions Dynamic NFTs: Images change based on onchain activity Software distribution: The latest version is always available via the same link Content publishing / social media: Content can be updated at any time and users will always have the most recent version Website hosting / dApp front-ends: Websites can be updated at any time without changing the main URL",
  "origin": "docs"
},{
  "url": "/developer-docs/network-merge-guide",
  "title": "Node merge",
  "description": "Build and prototype your application on Irys' Devnet",
  "text": "Node merge On March 28th, 2024 Irys merged our mainnet nodes. This simplifies our developer experience and means you no longer need to: Choose a node when uploading to our mainnet Manage balances on separate mainnet nodesThis change is fully backward compatible.You can continue using the existing URLs and SDKs with no code changes.Balances on nodes 1 & 2 will merge into a single mainnet balance. Your funds are safu.For more information, see below.Free uploads Uploads of less than 100 KiB remain free on Irys' mainnet and devnet.Balances User balances on nodes 1 and 2 have been merged into a single mainnet balance.Node URLs Most users will not need the direct node URLs as the SDK abstracts this away. However, if needed, you can use the following: https://arweave.mainnet.irys.xyz https://arweave.devnet.irys.xyzUpgrading To upgrade your code, see below: SDK CLI Query package GraphQL Provenance Toolkit WhistleblowerSDK Previously, you specified a node URL when connecting to our SDK. const irys = new Irys({url: \"\"https://node2.irys.xyz\"\", // URL of the node you want to connect totoken, // Token used for paymentkey: process.env.PRIVATE_KEY, // Private key }); Now, you pass either \"\"mainnet\"\" or \"\"devnet\"\" as the value of the network parameter. const irys = new Irys({network: \"\"mainnet\"\", // \"\"mainnet\"\" or \"\"devnet\"\"token, // Token used for paymentkey: process.env.PRIVATE_KEY, // Private key });CLI Previously, you specified a node URL using the -h flag. irys fund 1000000000000000 \\-h https://node1.irys.xyz \\-t matic \\-w bf20......c9885307 Now, you specify either mainnet or devnet using the -n flag. irys fund 1000000000000000 \\-n mainnet \\-t matic \\-w bf20......c9885307 If you omit the -n flag, the CLI will default to mainnet. irys fund 1000000000000000 \\-t matic \\-w bf20......c9885307Query package Previously, you set the query location using the url parameter. const myQuery = new Query({ url: \"\"https://devnet.irys.xyz/graphql\"\" }); Now, you set the query location using the network parameter. const myQuery = new Query({ network: \"\"mainnet\"\" }); // \"\"mainnet\"\" || \"\"devnet\"\" || \"\"arweave\"\" If needed, you can continue using the url parameter to override the default GraphQL endpoint. const myQuery = new Query({ url: \"\"https://arweave-search.goldsky.com/graphql\"\" }); Previously, when querying directly from the SDK, you used the url() method to specify a search location. This method has been deprecated. const result = await irys.search(\"\"irys:transactions\"\").url(\"\"https://node1.irys.xyz/graphql\"\").token(\"\"matic\"\").fromTimestamp(new Date(\"\"2023-07-01\"\")).toTimestamp(new Date(\"\"2023-07-03\"\")); And the network() method has been added. const result = await irys.search(\"\"irys:transactions\"\").network(\"\"mainnet\"\") // \"\"mainnet\"\" || \"\"devnet\"\".token(\"\"matic\"\").fromTimestamp(new Date(\"\"2023-07-01\"\")).toTimestamp(new Date(\"\"2023-07-03\"\"));GraphQL Previously, we had separate URLs for our two mainnet nodes. | Node| Endpoint| | ------ | ------------------------------- | | Node 1 | https://node1.irys.xyz/graphql| | Node 2 | https://node2.irys.xyz/graphql| | Devnet | https://devnet.irys.xyz/graphql | Now, we use a unified URL. | Node| Endpoint| | ------- | ---------------------------------------- | | Mainnet | https://arweave.mainnet.irys.xyz/graphql | | Devnet| https://arweave.devnet.irys.xyz/graphql|Provenance Toolkit The Provenance Toolkit has been updated to use our unified nodes.Whistleblower Previously, you used a flag to tell Whistleblower which mainnet nodes to monitor. yarn whistleblower init --nodes https://node1.irys.xyz https://node2.irys.xyz yarn start npm run whistleblower init-- --nodes https://node1.irys.xyz https://node2.irys.xyz npm run start Now, you no longer need to. yarn whistleblower init yarn start npm run whistleblower init npm run start `",
  "origin": "docs"
},{
  "url": "/developer-docs/path-manifests",
  "title": "Path manifests",
  "description": "Path manifests map paths to transaction IDs.",
  "text": "Path manifests Path manifests map paths to transaction IDs. Use them to create logical groupings of transactions, even transactions you didn’t create yourself. Creating To create a path manifest: Create a JavaScript Map object where each entry maps a unique transaction ID to a unique path. Paths are arbitrary; you can use anything that conforms to valid URL syntax. Create a Manifest object by passing the Map object to irys.uploader.generateManifest(). Upload the Manifest object to Irys. const map = new Map(); map.set(\"\"foo.png\"\", \"\"DSfHGmnhb7AN3xY3VUCykl-2xKiQcqXrsSP9zpzQQmY\"\"); const manifest = await irys.uploader.generateManifest({ items: map }); const tags = [{ name: \"\"Type\"\", value: \"\"manifest\"\" },{ name: \"\"Content-Type\"\", value: \"\"application/x.arweave-manifest+json\"\" }, ]; const receipt = await irys.upload(JSON.stringify(manifest), { tags }); const manifestId = receipt.id;Resolving Upon uploading a manifest, you get a receipt containing a transaction ID. To download transactions in a path manifest, request them from the Irys gateway using a URL formatted as: https://gateway.irys.xyz/:manifestId/:pathName The gateway then: Looks up the manifest by ID. Looks in the manifest to see if the path exists. Returns the transaction associated with the path if found. Returns 404 if not found. For example, if you have a manifest with ID W1UbYAZ08egXgm9kCw24ZZPAfdu8LQB7jcVx8fwv4 containing the following: | Tx ID| Path Name| | --------------------------------------------- | ---------- | | DSfHGmnhb7AN3xY3VUCykl-2xKiQcqXrsSP9zpzQQmY | foo1.png | | JDCzc3RE5b6RBXt3foKOR_nTt76dIxoW3Jjjezkk6VA | foo2.png | | 7BaKT3Wm04NPEAL3A0jcRc4cwQ6KHV8krv-DkbneFBw | foo3.png | You can download the first entry using: https://gateway.irys.xyz/W1UbYAZ08egXgm9kCw24ZZPAfdu8LQB7jcVx8fwv4/foo1.pngStatic websites When uploading a static website using irys.uploadFolder(), you can automatically create a path manifest by passing it as a parameter. For more information, see our guide on uploading static websites.Manually creating a path manifest Use path manifests to create a logical grouping of transactions, even transactions you didn’t create yourself. This example: Uses the Irys query package to search for the 10 most recent transactions tagged image/png. Groups the transations using a Map object. Creates a manifest mapping the transations to paths. Permanently uploads the manifest using Irys. // Get the most recent 'totalIds' number TXs tagged 'image/gif' const getTxIds = async (totalIds: number): Promise => {const myQuery = new Query({ network: \"\"devnet\"\" });const results = await myQuery.search(\"\"irys:transactions\"\").tags([{ name: \"\"Content-Type\"\", values: [\"\"image/gif\"\"] }]).sort(\"\"ASC\"\").limit(totalIds);const txIds: string[] = results.map((result) => result.id); // Adjust based on actual structurereturn txIds; }; // Generate a manifest containing the 10 most recent TX IDs tagged 'image/gif' const generateManifest = async () => {const txIds: string[] = await getTxIds(10);const map = new Map();for (let i = 0; i{console.log(https://gateway.irys.xyz/${manifestId}/${key});}); }; async function main(): Promise {await generateManifest(); } main().catch(console.error); `",
  "origin": "docs"
},{
  "url": "/developer-docs/provenance-toolkit/encrypted-uploader",
  "title": "Encrypted Uploader",
  "description": "UI component to encrypt files before uploading to Irys",
  "text": "Encrypted Uploader The Uploader component can optionally be put in encrypt mode where: A user selects a single file The file is encrypted using Lit Protocol The file is uploaded to Irys The user can choose to decrypt the file The file is then downloaded and decrypted using Lit Protocol Detailed reading For more information on how Irys works with Lit Protocol, see: Encrypting onchain data Encrypting data server-side Encrypting data in the browserUploading The component uses lazy funding, only funding when the currently funded balance is not sufficient to cover the cost of this upload. Once uploaded, file URLs are stored in the fileUrls state variable. When uploading a single file, the URL generated is in the form https://gateway.irys.xyz/[transaction-id]. When uploading multiple files, they are grouped together and uploaded as a group along with a manifest. The URL generated is in the form https://gateway.irys.xyz/[manifest-id]/[file-name].Access control rules In its default configuration, the Encrypted Uploader component is configured to allow anyone to decrypt the data. This is done by defining an access control condition that says any wallet with an ETH balance >= 0 can decrypt the data. For more information on access control conditions, see our docs and Lit's.",
  "origin": "docs"
},{
  "url": "/developer-docs/provenance-toolkit/fund-withdraw",
  "title": "Fund / withdraw",
  "description": "UI component to manage funding and withdrawing node balances",
  "text": "Fund / withdraw The Fund Withdraw component is used to manage node balances. Funding and withdrawing When uploading data to Irys, first fund a balance on our mainnet or devnet.Customizing the UI The FundWithdraw component provides a default UI that includes options for the end user to select a node, choose a token, and decide between funding or withdrawing. You can also modify the UI to hardwire the node address, token, or fix the mode (either to \"\"fund-only\"\" or \"\"withdraw-only\"\") using configuration parameters. | Description| Code| | ------------------------- | --------------------------------------- | | Default Behavior| ``| | Fix the network| ``| | Fix the token| ``| | Set to fund-only mode| ``| | Set to withdraw-only mode | `` | If both fundOnly and withdrawOnly are set to false, the component defaults to fund-only mode.Code The component is designed to be used as-is. Users making significant changes to the UI will need to understand the following.Getting funded balance When the component is set to \"\"withdraw\"\" mode, the UI will automatically check and display the user's currently funded balance. As balances are both node and token-specific, this balance check is encapsulated within a useEffect() hook that gets triggered when the component mounts and also whenever the user changes either the selected node or token. To get the currently funded balance, first connect to a Irys node using the node and token selected by the user: const irys = await getIrys(selectedNode?.value, selectedToken?.value); Then retrieve the loaded balance in atomic units: await irys.getLoadedBalance(); And convert to standard units before setting to a React state variable: setAmount(irys.utils.fromAtomic(loadedBalance)); Here’s the full code: useEffect(() => {setAmount(0);const getCurBalance = async () => {try {const irys = await getIrys(selectedNode?.value, selectedToken?.value);const loadedBalance = await irys.getLoadedBalance();// Show currently funded balance iff we're in withdraw modeif (!isFunding) setAmount(irys.utils.fromAtomic(loadedBalance));} catch (error) {console.log(\"\"Error connecting to Irys:\"\", error);}};if (selectedNode && selectedToken) getCurBalance(); }, [selectedNode, selectedToken, isFunding]);Funding & withdrawing Funding and withdrawing happen in the function handleFundWithdraw(). This function first validates input, then connects to a Irys node: const irys = await getIrys(selectedNode?.value, selectedToken?.value); When funding, it converts the value entered by the user to atomic units and then uses that value to fund: const fundTx = await irys.fund(irys.utils.toAtomic(amount)); When withdrawing, it converts the value entered by the user to atomic units and then uses that value to withdraw: const fundTx = await irys.withdrawBalance(irys.utils.toAtomic(amount));Atomic units When funding and withdrawing using the functions irys.fund() or irys.withdrawBalance(), pass a value in atomic units.Atomic units refer to the smallest possible unit of a given cryptocurrency. In Ethereum, atomic units are called Wei,and they represent the smallest unit of Ether. Similar to how 1 dollar can be broken down into 100 cents, 1 Ether canbe broken down into 10^18 Wei. In Solana, atomic units are called Lamports, 1 SOL can be broken down into 10^9Lamports. ",
  "origin": "docs"
},{
  "url": "/developer-docs/provenance-toolkit/gasless-uploader",
  "title": "Gasless uploader",
  "description": "UI component to upload single files or groups of files",
  "text": "Gasless uploader The Gasless Uploader component is used to upload either single files or groups of files. Uploads are signed and paid for using a wallet linked to the server. Uploading When uploading a single file, the URL generated is in the form https://gateway.irys.xyz/[transaction-id]. When uploading multiple files, they are grouped together and uploaded as a folder with a manifest. The URL generated is in the form https://gateway.irys.xyz/[manifest-id]/[file-name].Image & receipt previewOnce uploaded, the UI updates to include buttons that can be clicked to view the upload and the upload receipt. When previewing uploads, all image types are supported. If your application is working with files other than images, you can remove the upload preview or modify the code to include support for previewing your file type.Customizing the UI In default mode, the GaslessUploader component shows both the image preview and receipt preview buttons, which can be optionally hidden by passing config parameters to the component. | Description| Code| | ------------------------ | --------------------------------------------- | | Default Behavior| ``| | Hide the image preview| ``| | Hide the receipt preview | `` | If either parameter is left blank, it defaults to true.Code The component is designed to be used as-is. Users making significant changes to the UI can familiarize themselves with the code using this tutorial.",
  "origin": "docs"
},{
  "url": "/developer-docs/provenance-toolkit/progress-bar-uploader",
  "title": "Progress-bar uploader",
  "description": "UI component to manage funding and withdrawing node balances",
  "text": "Progress-bar uploader The Progress Bar Uploader is designed for larger files whose upload will take more than a few seconds. It provides visual feedback of upload progress in the form of a progress bar. Uploading The component uses a lazy funding approach, it first determines the cost to upload the chosen file, then checks the user's loaded balance, only funding more if needed. Once uploaded, a link to the file is shown in the UI and stored in the fileUrl state variable.Customizing the UI In default mode, the ProgressBarUploader component shows both the image preview and receipt preview buttons. They can be hidden by passing config parameters. | Description| Code| | ------------------------ | --------------------------------------------------- | | Default Behavior| ``| | Hide the image preview| ``| | Hide the receipt preview | `` |Code The component is designed to be used as-is. Users making significant changes to the UI will need to understand the following. The progress bar uploader uses our chunked uploader, which gives users fine-grained control over how files are uploaded. You can specify how to break a large file into smaller \"\"chunks\"\", how big each should be and how many should be uploaded at once. The uploader also supports event callbacks which update you on the upload's progress. The progress bar is controlled using the progress state variable, as its value is incrementally updated from 0 to 100, the visual representation automatically updates. const [progress, setProgress] = useState(0);Using the chunked uploader When setting up the chunked uploader, configure it by setting the batch size and chunk size. You may need to experiment with these values as you build your application, the ideal configuration will depend on factors including average file size and the quality of your end-user's internet connection. const irys = await getIrys(); const uploader = irys.uploader.chunkedUploader; uploader.setBatchSize(1); uploader.setChunkSize(2000000);Event callbacks Three different event callbacks are supported, use them to have code run during and after your upload. Currently they are used to update the progress bar. chunkUpload: Called after each chunk is uploaded, updates the progress bar. uploader.on(\"\"chunkUpload\"\", (chunkInfo) => {const chunkNumber = chunkInfo.id + 1;// update the progress bar based on how much has been uploadedif (chunkNumber >= totalChunks) setProgress(100);else setProgress((chunkNumber / totalChunks.current) * 100); }); error: Called if an error happens. In most cases, these can be ignored as the uploader automatically retries the upload whenever an error happens. uploader.on(\"\"chunkError\"\", (e) => {console.error(Error uploading chunk number ${e.id} - ${e.res.statusText}); }); done: Called when the upload is complete, sets the progress bar to 100%. uploader.on(\"\"done\"\", (finishRes) => {console.log(Upload completed with ID ${finishRes.id});// Set the progress bar to 100setProgress(100); });Uploading the file Once the event callbacks are setup, the file is passed to the uploader and the URL to the file is shown in the UI and stored in a state variable. await uploader.uploadData(dataStream, {tags: [{ name: \"\"Content-Type\"\", value: fileType }],upload: { getReceiptSignature: true },}).then((res) => {setFileUrl(https://gateway.irys.xyz/${res.data.id});setMessage(File uploaded,);}).catch((e) => {setMessage(\"\"Upload error \"\" + e.message);}); `",
  "origin": "docs"
},{
  "url": "/developer-docs/provenance-toolkit/solana-nft-minter",
  "title": "Solana NFT minter",
  "description": "UI component to upload single files or groups of files",
  "text": "Solana NFT minter The Solana NFT Minter component: Uploads an image to Irys Mints the image as a Solana NFT using the Helius SDK Minting This component uses the Helius SDK to mint the uploaded image as a compressed NFT on Solana. To use this component, you must create a Helius developer account first.Then, add your Helius API key as the value for the NEXTPUBLICHELIUS_API field in the Provenance Toolkit's .env.local file.",
  "origin": "docs"
},{
  "url": "/developer-docs/provenance-toolkit/transaction-feed",
  "title": "Transaction feed",
  "description": "UI component to query transaction metadata",
  "text": "Transaction feed The Transaction Feed component uses the query package to search transactions based on node, token, content type and timestamp and renders the results in an easy-to-view format.The component could be easily forked and used as part of applications like: A feed of images for a decentralized image-sharing platform A music discovery tool highlighting songs uploaded to Arweave A browsing tool as part of a platform for academic research and papersQuery function The actual querying takes place in the function handleQuery() where parameters entered in the UI are used to create a new Query object. When forking this component, you could modify the query construction to do things like limit query results to transactions with your application-id or transactions of a single Content-Type. const handleQuery = async () => {setTxProcessing(true);setQueryResults([]);setError(\"\"\"\");if (selectedNode === null) {// Should never happen, but better to checksetError(\"\"Please select a node\"\");return;}// Convert the timestamp strings to Date objectsconst fromDate = fromTimestamp ? new Date(fromTimestamp) : null;const toDate = toTimestamp ? new Date(toTimestamp) : null;try {const query = new Query({ url: selectedNode.value });const myQuery = query.search(\"\"irys:transactions\"\").limit(42);// Set query params based on input in NavBarif (selectedContentType?.value) {console.log(\"\"Adding content type=\"\", selectedContentType?.value);myQuery.tags([{ name: \"\"Content-Type\"\", values: [selectedContentType?.value] }]);}if (selectedToken?.value) {console.log(\"\"Adding token=\"\", selectedToken?.value);myQuery.token(selectedToken?.value);}if (fromDate) {console.log(\"\"Adding fromDate=\"\", fromDate);myQuery.fromTimestamp(fromDate);}if (toDate) {console.log(\"\"Adding fromDate=\"\", toDate);myQuery.toTimestamp(toDate);}// Having configured the query, call await on it to executeconst results = await myQuery;console.log(\"\"Query results \"\", results);let convertedResults: QueryResult[] = [];for (const result of results) {const transformedResult: QueryResult = {txID: result.id, // adjust as necessary based on the structure of resultscreationDate: result.timestamp.toString(),token: result.token,tags: result.tags,};convertedResults.push(transformedResult);}setQueryResults(convertedResults);} catch (error) {setError(\"\"Error executing the GraphQL query\"\");} finally {setTxProcessing(false);} }; `",
  "origin": "docs"
},{
  "url": "/developer-docs/provenance-toolkit/udl-uploader",
  "title": "UDL uploader",
  "description": "UI component to manage funding and withdrawing node balances",
  "text": "UDL uploader The UDL Uploader component attaches a Universal Data License to data as it's uploaded. Universal Data License The Universal Data License (UDL) provides content creators with a straightforward way to define how their content can be used. It is fully parameterized, each data point in the UI is converted to a tag at upload.Tags When using Irys to upload data to Arweave, you can attach up to 20 tags to each transaction. These tags, in the form of name / value pairs, are indexed and are queryable. When adding a UDL to an upload, you use a pre-defined set of tags to describe how you allow your data to be used. The UDL uploader has a UI that covers most UDL parameters, you can manually customize the UI to include additional parameters as needed. When uploading data, UDL parameters are converted to tags and attached to the data at upload.Code The UDL uploader does not natively support any customizations, however when forking the code, builders might choose to hide certain parameters from the UI and hardcode them during upload. For example you may want to fix the payment token to only be ETH, or disallow all commercial use.Configuring the license All of the processing for UDLUploader happens in the handleUpload() function. After validating input, an array of tags is built. This is where you could hardcode values instead of having them configurable in the UI. const tags: Tag[] = []; tags.push({ name: \"\"Content-Type\"\", value: fileType }); tags.push({name: \"\"License\"\",value: \"\"yRj4a5KMctXuOmKWCFJIjmY8DeJcusVk6-HzLiMt8\"\", }); if (licenseFeeType !== \"\"None\"\")tags.push({name: \"\"License-Fee\"\",value: licenseFeeType + \"\"-\"\" + licenseFeeUnit,}); if (commercialUse !== \"\"None\"\") tags.push({ name: \"\"Commerical-Use\"\", value: commercialUse }); tags.push({ name: \"\"Currency\"\", value: currency }); if (paymentAddress) tags.push({ name: \"\"Payment-Address\"\", value: paymentAddress }); if (derivation) tags.push({ name: \"\"Derivation\"\", value: derivation });Uploading the file And then the file is paired with tags and is uploaded using our utility function. const txId = await fundAndUpload(selectedFile, tags); `",
  "origin": "docs"
},{
  "url": "/developer-docs/provenance-toolkit/uploader",
  "title": "Uploader",
  "description": "UI component to upload single files or groups of files",
  "text": "Uploader The Uploader component is used to upload either single files or groups of files using a single wallet interaction. Uploads are signed and paid for using the user's wallet. Uploading The component uses lazy funding, only funding when the currently funded balance is not sufficient to cover the cost of this upload. Once uploaded, file URLs are stored in the fileUrls state variable. When uploading a single file, the URL generated is in the form https://gateway.irys.xyz/[transaction-id]. When uploading multiple files, they are grouped together and uploaded as a group along with a manifest. The URL generated is in the form https://gateway.irys.xyz/[manifest-id]/[file-name].Image & receipt previewOnce uploaded, the UI updates to include buttons that can be clicked to view the upload and the upload receipt. When previewing uploads, all image types are supported. If your application is working with files other than images, you can remove the upload preview or modify the code to include support for previewing your file type. If you don't choose to show the receipt, you can retrieve it later using the upload transaction id and the function irys.utils.getReceipt().Customizing the UI In default mode, the Uploader component shows both the image preview and receipt preview buttons. They can be hidden by passing config parameters to the component. | Description| Code| | ------------------------ | --------------------------------------- | | Default Behavior| ``| | Hide the image preview| ``| | Hide the receipt preview | `` | If either parameter is left blank, it defaults to true.Code The component is designed to be used as-is. Users making significant changes to the UI will need to understand the following.Gateway To download data uploded to Arweave, use a gateway. The Uploader component is currently configured to use the Arweave gateway, to change this modify this variable. const GATEWAY_BASE = \"\"https://gateway.irys.xyz/\"\";FileWrapper The Uploader component wraps the base File object with a FileWrapper instance used to track the file's progress as it gets uploaded. interface FileWrapper {file: File;isUploaded: boolean;id: string;previewUrl: string;loadingReceipt: boolean; }Single file uploads File uploads happen in the function handleUpload(). For single file uploads, first a Content-Type tag is created to assist the browser in rendering the file, then the file is upload and the FileWrapper object is updated. // This occurs when exactly one file is selected try {for (const file of files) {const tags: Tag[] = [{ name: \"\"Content-Type\"\", value: file.file.type }];const uploadedTx = await fundAndUpload(file.file, tags);file.id = uploadedTx;file.isUploaded = true;file.previewUrl = GATEWAY_BASE + uploadedTx;} } catch (e) {console.log(\"\"Error on upload: \"\", e); }Multiple file uploads When uploading multiple files at once, they are grouped together as a nested bundle and uploaded with a manifest. try {// Remove the File objects from the FileWrapper objectsconst filesToUpload: File[] = files.map((file) => file.file);console.log(\"\"Multi-file upload\"\");const manifestId = await fundAndUpload(filesToUpload);// Now that the upload is done, update the FileWrapper objects with the preview URLconst updatedFiles = files.map((file) => ({...file,isUploaded: true,previewUrl: GATEWAY_BASE + manifestId + \"\"/\"\" + file.file.name,}));setFiles(updatedFiles); } catch (e) {console.log(\"\"Error on upload: \"\", e); }Showing receipts When showing a receipt, it is first retrieved using irys.utils.getReceipt() and then set to the receipt state variable. The receipt is formatted in the class ReceiptJSONView, which can be modified if you desire custom formatting. const showReceipt = async (id: string) => {setReceiptQueryProcessing(true);try {const irys = await getIrys();const receipt = await irys.utils.getReceipt(id);console.log(receipt);setReceipt(receipt);setPreviewURL(\"\"\"\"); // Only show one or the other} catch (e) {console.log(\"\"Error fetching receipt: \"\" + e);}setReceiptQueryProcessing(false); }; `",
  "origin": "docs"
},{
  "url": "/developer-docs/provenance-toolkit",
  "title": "Provenance Toolkit",
  "description": "A collection of UI components to help kickstart your next project.",
  "text": "Provenance ToolkitThe Irys Provenance Toolkit is a collection of UI components you can use to kickstart your next application. It contains UI components for managing node balances, uploading files, performing gasless uploads, and querying transactions. The toolkit is fully open source, you are welcome to use it any way you want with or without attribution. Demo You can interact with the provenance toolkit at https://provenance-toolkit.irys.xyzPrerequisites The Provenance Toolkit is designed for intermediate to advanced developers and assumes you have a working knowledge of NextJS, TypeScript, and Tailwind. Beginning developers may want to start with our tutorials and quests which are designed for a broader audience. This guide gives an introduction to the entire toolkit, including how to use and customize the components. To learn more about how each component is built, we have separate tutorials for each.Setup Fork or clone https://github.com/Irys-xyz/provenance-toolkit Run npm install or yarn from within the project directory Rename .env.local.example to .env.local and follow the configuration instructions in that file Run npm run start from within the project directory Launch the Provenance Toolkit at http://localhost:3000/Project layoutThe project is broken into three main categories: Components: The UI components. These can be added to your project and used as is. Navigation routes: NextJS navigation routing. If you’re building your own project on top of the Provenance Toolkit, you can delete these routes and create your own. Utils: Utility functions used by the UI components.Components Included within the Provenance Toolkit are the following components: Fund / Withdraw: Manage node balances. Uploader: Upload single files or groups of files. Progress Bar Uploader: Upload large files, and provide feedback with a progress bar. UDL Uploader: Upload files and attach a UDL. Encrypted Uploader: Encrypt files before uploading. Gasless Uploader: Pay for user uploads server-side. Solana NFT Minter: Upload an image and mint on Solana as an NFT. Transaction Feed: Query Irys transactions.Customization The components are designed with a minimal UI that can be easily incorporated into any design. If you need to make significant UI customizations, the docs for each component contain a description of the code. To change colors, modify the values in tailwind.config.js.Utility Functions The following utility functions are used internally by the components. If you're using the components as-is, you can safely ignore the utility functions. For users customizing the components, these functions provide an additional abstraction layer over our SDK. titleCase.ts: Converts a string to title case getRpcUrl.ts: Returns the RPC URL for the chain associated with the specified token. getIrys.ts: Instantiates an Irys object using the parameters in .env.local. Currently designed to work with the Ethers 5 provider. You use a different provider, modify code here. fundAndUpload.ts: Determines the upload cost for the specified data, funds the node if needed, and then uploads the file. gaslessFundAndUpload.ts: Using the private key supplied in .env.local, determines the upload cost for the specified data, funds the node if needed, and then uploads the file. queryGraphQL.ts: Uses the Irys query package to search based on parameters entered in the UI",
  "origin": "docs"
},{
  "url": "/developer-docs/querying/api/fields",
  "title": "fields({})",
  "description": "Limit fields returned when searching Irys and Arweave",
  "text": "fields({}) Limits the fields returned. Parameters fields: A JSON object detailing the desired fields To limit the results, set a field's value to false or omit it entirely. The fields available for retrieval depend on the search type, when searching irys:transactions, the following fields are available: .fields({id: true, // Transaction IDtoken: true, // Token used for paymentaddress: true, // Cross-chain address used for signing and paymentreceipt: {deadlineHeight: true, // The block number by which the transaction must be finalized on Arweavesignature: true, // A signed deep hash of the JSON receipttimestamp: true, // Timestamp, millisecond accurate, of the time the uploaded was verifiedversion: true, // The receipt version, currently 1.0.0},tags: { // An array of tags associated with the uploadname: true,value: true,},signature: true, // A signed deep hash of the JSON receipttimestamp: true, // Timestamp, millisecond accurate, of the time the uploaded was verified }) When searching by arweave:transactions the following fields are available: .fields({id: true, // Transaction IDtags: {// Tags associated with the uploadname: true,value: true,},anchor: true,block: {height: true, // Block heightid: true, // Block IDprevious: true, // Todotimestamp: true, // Block timestamp},bundledIn: {id: true,},data: {size: true, // Data sizetype: true, // Date type},fee: {ar: true, // Fee paid in ARwinston: true, // Fee paid in Winston},owner: {address: true, // Transation originatorkey: true, // Public key},quantity: {ar: true, // Amount of AR transferred (for token transfers)winston: true, // Amount of AR transferred (for token transfers)},recipient: true, // Transfer recipient (for token transfers)signature: true, // Transaction signature }) When searching by arweave:blocks the following fields are available: .fields({height: true,id: true,previous: true,timestamp: true, }) `",
  "origin": "docs"
},{
  "url": "/developer-docs/querying/api/from",
  "title": "from([addresses])",
  "description": "Searches by the wallet addresses used when signing and paying for the upload",
  "text": "from([addresses]) Queries by the wallet addresses used when signing and paying for the upload. Parametersaddresses: An array of IDs passed as stringsSearch By Transaction Sender When querying Irys, accepts addresses from any of Irys' supported chains are accepted. const results = await myQuery.search(\"\"irys:transactions\"\").from([\"\"UsWPlOBHRyfWcbrlC5sV3-pNUjOQEI5WmDxLnypc93I\"\",\"\"0x4adDE0b3C686B4453e007994edE91A7832CF3c99\"\"]); When querying Arweave, accepts Arweave addresses only. const results = await myQuery.search(\"\"arweave:transactions\"\").from([\"\"TrnCnIGq1tx8TV8NA7L2ejJJmrywtwRfq9Q7yNV6g2A\"\"]); `",
  "origin": "docs"
},{
  "url": "/developer-docs/querying/api/fromTimestamp",
  "title": "fromTimestamp(timeStamp)",
  "description": "Searches Arweave based on block height",
  "text": "fromTimestamp(timeStamp) Use the fromTimestamp() and toTimestamp() functions to search for transactions by timestamp. Results returned are >= fromTimestamp and ` ParameterstimeStamp: Timestamp as Date object or UNIX timestamp in milliseconds You can search by passing Date objects to the functions: const results = await myQuery.search(\"\"irys:transactions\"\").fromTimestamp(new Date(\"\"2023-07-01\"\")).toTimestamp(new Date(\"\"2023-07-03\"\")); Or by using UNIX timestamps in millisecond format: const results = await myQuery.search(\"\"irys:transactions\"\").fromTimestamp(1688144401000).toTimestamp(1688317201000);Irys timestamps are accurate to the millisecond, so you need to provide a timestamp in millisecond format. You canconvert from human-readable time to UNIX timestamp using websites like Epoch101, besure to convert in millisecond format, not second. ",
  "origin": "docs"
},{
  "url": "/developer-docs/querying/api/ids",
  "title": "ids([ids])",
  "description": "Searches either by transaction ID or block ID",
  "text": "ids([ids]) Queries either by transaction ID or block ID (depending on the value passed to search()). Parametersids: An array of IDs passed as stringsSearch By Transaction ID Use the ids() function to by transaction ID. The search employs OR logic, returning transactions tagged with ANY provided value: const results = await myQuery.search(\"\"irys:transactions\"\").ids([\"\"xXyv3u9nHHWGiMJlDMgLwwRdOTlIlQZyqaKrOkNZw\"\",\"\"xE7tG1kl2FgCUDgJ5jNJeVA6R5kuys7A6f1qfh9Kw\"\"]); You can also search Arweave by transaction ID. const results = await myQuery.search(\"\"arweave:transactions\"\").ids([\"\"xXyv3u9nHHWGiMJlDMgLwwRdOTlIlQZyqaKrOkNZw\"\",\"\"xE7tG1kl2FgCUDgJ5jNJeVA6R5kuys7A6f1qfh9Kw\"\"]);Search By Block ID Use the ids() function to search for Arweave blocks with the specified IDs. const results = await myQuery.search(\"\"arweave:blocks\"\").ids([\"\"R0ZLe4RvHxLJLzI1Z9ppyYVWFyHW4D1YrxXKuA9PGrwkk2QAuXCnD1xOJe-QOz4l\"\"]) `",
  "origin": "docs"
},{
  "url": "/developer-docs/querying/api/limit",
  "title": "limit(limitNumber)",
  "description": "Limits the maximum number of results returned.",
  "text": "limit(limitNumber) Limits the maximum number of results returned. This overrides the default value of 1000 results when searching Irys and 100 when searching Arweave directly. ParameterslimitNumber: The number of results desired const results = await myQuery.search(\"\"irys:transactions\"\").ids([\"\"xXyv3u9nHHWGiMJlDMgLwwRdOTlIlQZyqaKrOkNZw\"\",\"\"xE7tG1kl2FgCUDgJ5jNJeVA6R5kuys7A6f1qfh9Kw\"\"]).limit(20); `",
  "origin": "docs"
},{
  "url": "/developer-docs/querying/api/maxHeight",
  "title": "maxHeight(height)",
  "description": "Searches Arweave based on block height",
  "text": "maxHeight(height) Queries Arweave based on block height, returning all blocks at the specified height and earlier. Commonly used with minHeight().Parametersheight: Block height const results = await myQuery.search(\"\"arweave:blocks\"\").minHeight(1188272).maxHeight(1188279); `",
  "origin": "docs"
},{
  "url": "/developer-docs/querying/api/minHeight",
  "title": "minHeight(height)",
  "description": "Searches Arweave based on block height",
  "text": "minHeight(height) Queries Arweave based on block height, returning all blocks at the specified height and after. Commonly used with maxHeight().Parametersheight: Block height const results = await myQuery.search(\"\"arweave:blocks\"\").minHeight(1188272).maxHeight(1188279); `",
  "origin": "docs"
},{
  "url": "/developer-docs/querying/api/search",
  "title": "irys.search(queryName)",
  "description": "Sets the search location (Irys or Arweave).",
  "text": "irys.search(queryName) Sets the query type / location. ParametersqueryName: The query type / location.Accepted Values irys:transactions: Searches transactions uploaded to Arweave via any of Irys' nodes arweave:transactions: Searches all transactions posted to Arweave arweave:blocks: Searches all of Arweave for a specific block const results = await myQuery.search(\"\"irys:transactions\"\").tags([{ name: \"\"Content-Type\"\", values: [\"\"image/png\"\", \"\"image/jpg\"\"] }]); `",
  "origin": "docs"
},{
  "url": "/developer-docs/querying/api/sort",
  "title": "sort(\"ASC\" | \"DESC\")",
  "description": "Sorts search results by timestamp",
  "text": "sort(\"\"ASC\"\" | \"\"DESC\"\") Sorts query results by timestamp either in ascending or descending format. Parameters sortType: Either \"\"ASC\"\" (ascending) or \"\"DESC\"\" (descending) const results = await myQuery.search(\"\"irys:transactions\"\").token(\"\"ethereum\"\").sort(\"\"ASC\"\"); const results = await myQuery.search(\"\"arweave:transactions\"\").tags([{ name: \"\"Content-Type\"\", values: [\"\"image/png\"\", \"\"image/jpg\"\"] }]);.sort(\"\"DESC\"\"); `",
  "origin": "docs"
},{
  "url": "/developer-docs/querying/api/stream",
  "title": "stream()",
  "description": "Returns an iterable stream that continuously yields results",
  "text": "stream() Returns an iterable stream that continuously yields results as long as your query keeps producing them. // Create the stream const stream = await myQuery.search(\"\"irys:transactions\"\").token(\"\"solana\"\").stream(); // Iterate over the results for await (const result of stream) {console.log(result); } `",
  "origin": "docs"
},{
  "url": "/developer-docs/querying/api/tags",
  "title": "tags([{ name, value }])",
  "description": "Searches Irys or Arweave via tags",
  "text": "tags([{ name, value }]) Queries using metadata tags attached to transactions during upload.Parameters[{ name, value }]: An array of tag name / value pairs Search for a single tag name / value pair: const results = await myQuery.search(\"\"irys:transactions\"\").tags([{ name: \"\"Content-Type\"\", values: [\"\"image/png\"\"] }]); Search for a single tag name with a list of possible values. The search uses OR logic and returns transactions tagged with ANY provided value: const results = await myQuery.search(\"\"irys:transactions\"\").tags([{ name: \"\"Content-Type\"\", values: [\"\"image/png\"\", \"\"image/jpg\"\"] }]); Search for multiple tags. The search uses AND logic and returns transactions tagged with ALL provided values: const results = await myQuery.search(\"\"irys:transactions\"\").tags([{ name: \"\"Content-Type\"\", values: [\"\"image/png\"\"] },{ name: \"\"Application-ID\"\", values: [\"\"myApp\"\"] }]); You can also search Arweave by tags: const results = await myQuery.search(\"\"arweave:transactions\"\").tags([{ name: \"\"Content-Type\"\", values: [\"\"image/png\"\", \"\"image/jpg\"\"] }]); `",
  "origin": "docs"
},{
  "url": "/developer-docs/querying/api/to",
  "title": "to([addresses])",
  "description": "Searches by the wallet addresses",
  "text": "to([addresses]) Queries by the wallet addresses used when signing and paying for the upload. Parametersaddresses: An array of IDs passed as stringsSearch By Transaction Sender When querying Irys, accepts addresses from any of Irys' supported chains are accepted. const results = await myQuery.search(\"\"irys:transactions\"\").from([\"\"UsWPlOBHRyfWcbrlC5sV3-pNUjOQEI5WmDxLnypc93I\"\",\"\"0x4adDE0b3C686B4453e007994edE91A7832CF3c99\"\"]); When querying Arweave, accepts Arweave addresses only. const results = await myQuery.search(\"\"arweave:transactions\"\").from([\"\"TrnCnIGq1tx8TV8NA7L2ejJJmrywtwRfq9Q7yNV6g2A\"\"]); `",
  "origin": "docs"
},{
  "url": "/developer-docs/querying/api/toTimestamp",
  "title": "toTimestamp(timeStamp)",
  "description": "Searches Arweave based on block height",
  "text": "toTimestamp(timeStamp) Use the fromTimestamp() and toTimestamp() functions to search for transactions by timestamp. Results returned are >= fromTimestamp and ` ParameterstimeStamp: Timestamp as Date object or UNIX timestamp in milliseconds You can search by passing Date objects to the functions: const results = await myQuery.search(\"\"irys:transactions\"\").fromTimestamp(new Date(\"\"2023-07-01\"\")).toTimestamp(new Date(\"\"2023-07-03\"\")); Or by using UNIX timestamps in millisecond format: const results = await myQuery.search(\"\"irys:transactions\"\").fromTimestamp(1688144401000).toTimestamp(1688317201000);Irys timestamps are accurate to the millisecond, so you need to provide a timestamp in millisecond format. You canconvert from human-readable time to UNIX timestamp using websites like Epoch101, besure to convert in millisecond format, not second. ",
  "origin": "docs"
},{
  "url": "/developer-docs/querying/api/token",
  "title": "token(tokenName)",
  "description": "Searches by token used for payment",
  "text": "token(tokenName) Queries by token used for payment. Accepts any token supported by Irys.ParameterstokenName: The name of the token const results = await myQuery.search(\"\"irys:transactions\"\").token(\"\"solana\"\"); `",
  "origin": "docs"
},{
  "url": "/developer-docs/querying/graphql",
  "title": "Querying With GraphQL",
  "description": "Searching Irys using GraphQL",
  "text": "Querying With GraphQL In addition to the query library, you can also query Irys transactions directly using GraphQL.Irys vs Arweave GraphQL This document covers how to query Irys directly, Arweave also has docs on their query schema.GraphQL clients You can query using an HTTP library like fetch or axios. You can also use specialized clients like Apollo Client or urql.Anatomy of a query A GraphQL query is made up of: Query Arguments: Arguments that specify search parameters, limit the number of results returned, or enable pagination. Results Fields: Fields that define the data you want to retrieve. Query arguments Any of the following query arguments can be used as search parameters: | Field| Description| | ------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | ids| An array of transaction IDs passed as strings. Values are ORed together, matching results will include transactions that have any of the supplied IDs.| | owner | The address used when posting the transaction. Can be a native address from any of the chains supported by Irys. Note in results fields, this is referred to as address. | | token | The token used to pay for the transaction.| | tags| An array of tag name / value pairs passed as JSON objects.|Results fields When building a query, any of the following values be included in your results: | Field | Description | |---|---| | id | The transaction ID. | | address | The address used when posting the transaction. Can be a native address from any of the chains supported by Irys. Note in query arguements, this is referred to as owner. | | token | The token used to pay for the transaction. | | receipt { &nbsp;&nbsp;deadlineHeight &nbsp;&nbsp;signature&nbsp;&nbsp;version } | An optional receipt, only exists if a user requested one at upload. deadlineHeight: The block number by which the transaction must be finalized on Arweave. signature: A signed deep hash of the JSON receipt. | | tags {&nbsp;&nbsp;name&nbsp;&nbsp;value} | An array of tags supplied as name / value pairs. Exists if the user added them at upload. | |timestamp | The timestamp, accurate to the millisecond of when the transaction was posted. This value is the same as the receipt timestamp. |Mainnet & devnet We have two GraphQL endpoints, one for mainnet and one for devnet. | Node| Endpoint| | ------- | ---------------------------------------- | | Mainnet | https://arweave.mainnet.irys.xyz/graphql | | Devnet| https://arweave.devnet.irys.xyz/graphql|GraphQL sandbox Clicking on any of the endpoint URLs above will direct you to the GraphQL Sandbox used for building and testing queries. Press Control+Space at any time to see an interactive popup window of either query arguments or results fields. Sample queries Queries return transaction metadata. To then retrieve data, use the returned transaction ID and download the data from a gateway using a URL formed as follows https://gateway.irys.xyz/[transaction-id].Transaction ids Search by transaction IDs. query getByIds {transactions(ids: [\"\"--52WQHJIJodrni8pkl1Vxt9MFGoXZAm8SC7ex6C1o\"\", \"\"--52THRWpXRJzGcNXmtQ2DSP37d1e1VQ4YmvbY5ZXo\"\"]) {edges {node {idtags {namevalue}}}} }Timestamps Search by timestamps: query getByTimestamp {transactions(timestamp: { from: 1688144401000, to: 1688317201000 }) {edges {node {id}}} }Irys timestamps are accurate to the millisecond, so you need to provide a timestamp in millisecond format. You canconvert from human-readable time to UNIX timestamp using websites like Epoch101, be sureto convert in millisecond format, not second. Owners Search for transactions matching the wallet address used when posting the transaction: query getByOwner {transactions(owners: [\"\"0xBcb812C6e26F4F0F78Bd7B6222461FF24F2942AE\"\", \"\"0xaC568a981B1370B2e1bAA8cE30BD5AC9E28C572D\"\"]) {edges {node {idaddress}}} }Tags Search for transactions matching tag name / value pairs: query getAllPNGs {transactions(tags: [{ name: \"\"Content-Type\"\", values: [\"\"image/png\"\"] }]) {edges {node {idaddress}}} } Search for transactions matching the tag with name Content-Type and the values of image/png OR image/jpg: query getTagsWithOR {transactions(tags: [{ name: \"\"Content-Type\"\", values: [\"\"image/png\"\", \"\"image/jpg\"\"] }]) {edges {node {tags {namevalue}}}} } Search for transactions matching the tag with name Content-Type and the values of image/png AND image/jpg: query getTagsWithAnd {transactions(tags: [{ name: \"\"Content-Type\"\", values: [\"\"image/jpg\"\"] }, { name: \"\"Content-Type\"\", values: [\"\"image/png\"\"] }]) {edges {node {tags {namevalue}}}} }Limiting results Limit the number of results returned by including the limit parameter: query getAllPNGs {transactions(limit: 10, tags: [{ name: \"\"Content-Type\"\", values: [\"\"image/png\"\"] }]) {edges {node {idaddress}}} }Pagination You can request a maximum of 100 results returned from each query, to obtain additional results use pagination. When using pagination you: Retrieve the cursor field, this acts like a bookmark in the search results you can then return to. Use saved cursor value to obtain subsequent search results. The following query returns 10 transactions tagged image/png occurring after the cursor with value: LS02d1NsM3R6aUprd3dKUzVjN1FXaWg5aUxsbXh5dVJJbGlydHJtNlpPbw. To then obtain the next 10 transactions, use the final cursor value returned from this query as the value of the after parameter in the following query. query getPNGs {transactions(limit: 10tags: [{ name: \"\"Content-Type\"\", values: [\"\"image/png\"\"] }]after: \"\"LS02d1NsM3R6aUprd3dKUzVjN1FXaWg5aUxsbXh5dVJJbGlydHJtNlpPbw\"\") {edges {node {id}cursor}} }Sorting You can sort results by timestamp in either ascending or descending order using the order field. query getAllByOwnerAsc {transactions(owners: [\"\"0xBcb812C6e26F4F0F78Bd7B6222461FF24F2942AE\"\"], order: ASC) {edges {node {idaddress}}} } query getAllByOwnerDesc {transactions(owners: [\"\"0xBcb812C6e26F4F0F78Bd7B6222461FF24F2942AE\"\"], order: DESC) {edges {node {idaddress}}} } `",
  "origin": "docs"
},{
  "url": "/developer-docs/querying/query-package",
  "title": "Irys Query Package",
  "description": "Search Irys and Arweave with this JavaScript package",
  "text": "Irys Query PackageThe query package enables users to search Irys and Arweave through an intuitive JavaScript package. It is easily implemented in a few lines of code.The query package is for searching transaction metadata on Irys and Arweave, and also Arweave block information. Once you've found transactions, use the transaction ID to download the associated data. Installation Install via npm: npm install @irys/query and yarn: yarn add @irys/queryImports Import with:Creating a Query object Start by instantiating a new Query object, this is a shared instance you can reuse each time you want to execute a new query. const myQuery = new Query(); Then execute a query by chaining together a series of functions that collaboratively narrow down the results returned. To retrieve the 20 latest transactions with the tag Content-Type set to image/png on Irys: const results = await myQuery.search(\"\"irys:transactions\"\").tags([{ name: \"\"Content-Type\"\", values: [\"\"image/png\"\"] }]).sort(\"\"ASC\"\").limit(20);Query location (mainnet, devnet, arweave) The Query class defaults to querying Irys' mainnet. To search Irys' devnet or Arweave, use the network parameter.Irys mainnet // Either will work const myQuery = new Query(); const myQuery = new Query({ network: \"\"mainnet\"\" });Irys devnet const myQuery = new Query({ network: \"\"devnet\"\" });Arweave const myQuery = new Query({ network: \"\"arweave\"\" });Overriding default Endpoint You can override the default GraphQL endpoint using the url parameter. Most users will not need this feature. const myQuery = new Query({ url: \"\"https://arweave-search.goldsky.com/graphql\"\" });Query type Using the Query class users can search any of: Irys transactions Arweave transactions Arweave blocks The search location is specified by passing a parameter to the search() function. const results = await myQuery.search(\"\"irys:transactions\"\"); The selected search type influences the returned fields and the availability of specific query functions. | Function| irys:transactions | arweave:transactions | arweave:blocks | | ------------------------------------------------ | ----------------- | -------------------- | -------------- | | search()| Yes| Yes| Yes| | tags()| Yes| Yes| No| | ids()| Yes| Yes| Yes| | from()| Yes| Yes| No| | to()| No| Yes| No| | token()| Yes| No| No| | fromTimestamp()| Yes| No| Yes| | toTimestamp()| Yes| No| Yes| | minHeight()| No| No| Yes| | maxHeight()| No| No| Yes| | sort()| Yes| Yes| Yes| | limit()| Yes| Yes| Yes| | stream()| Yes| Yes| Yes| | fields()| Yes| Yes| Yes|Timestamp Use the fromTimestamp() and toTimestamp() functions to search for transactions by timestamp. Results returned are >= fromTimestamp and `Irys timestamps are accurate to the millisecond, so you need to provide a timestamp in millisecond format. You canconvert from human-readable time to UNIX timestamp using websites like Epoch101, besure to convert in millisecond format, not second. Tags Use the tags() function to search metadata tags attached to transactions during upload. Search for a single tag name / value pair: const results = await myQuery.search(\"\"irys:transactions\"\").tags([{ name: \"\"Content-Type\"\", values: [\"\"image/png\"\"] }]); Search for a single tag name with a list of possible values. The search uses OR logic and returns transactions tagged with ANY provided value. const results = await myQuery.search(\"\"irys:transactions\"\").tags([{ name: \"\"Content-Type\"\", values: [\"\"image/png\"\", \"\"image/jpg\"\"] }]); Search for multiple tags. The search uses AND logic and returns transactions tagged with ALL provided values. const results = await myQuery.search(\"\"irys:transactions\"\").tags([{ name: \"\"Content-Type\"\", values: [\"\"image/png\"\"] },{ name: \"\"Application-ID\"\", values: [\"\"myApp\"\"] }, ]); You can also search Arweave by tags: const results = await myQuery.search(\"\"arweave:transactions\"\").tags([{ name: \"\"Content-Type\"\", values: [\"\"image/png\"\", \"\"image/jpg\"\"] }]);Transaction id Use the ids() function to by transaction ID. The search uses OR logic and returns transactions tagged with ANY provided value: const results = await myQuery.search(\"\"irys:transactions\"\").ids([\"\"xXyv3u9nHHWGiMJlDMgLwwRdOTlIlQZyqaKrOkNZw\"\", \"\"xE7tG1kl2FgCUDgJ5jNJeVA6R5kuys7A6f1qfh9Kw\"\"]); You can also search Arweave by transaction ID. const results = await myQuery.search(\"\"arweave:transactions\"\").ids([\"\"xXyv3u9nHHWGiMJlDMgLwwRdOTlIlQZyqaKrOkNZw\"\", \"\"xE7tG1kl2FgCUDgJ5jNJeVA6R5kuys7A6f1qfh9Kw\"\"]);Transaction sender Use the from() function to search by wallet addresses used when signing and paying for the upload. Addresses from any of Irys' supported chains are accepted. The search employs OR logic, returning transactions tagged with ANY provided value: const results = await myQuery.search(\"\"irys:transactions\"\").from([\"\"UsWPlOBHRyfWcbrlC5sV3-pNUjOQEI5WmDxLnypc93I\"\", \"\"0x4adDE0b3C686B4453e007994edE91A7832CF3c99\"\"]); When searching Arweave by transaction sender, only Arweave addresses are accepted: const results = await myQuery.search(\"\"arweave:transactions\"\").from([\"\"TrnCnIGq1tx8TV8NA7L2ejJJmrywtwRfq9Q7yNV6g2A\"\"]);Transaction recipient Use the to() function to search for the wallet address of the transaction recipient. This works on Arweave only and is used when there's a fund transfer. const results = await myQuery.search(\"\"arweave:transactions\"\").to(\"\"TrnCnIGq1tx8TV8NA7L2ejJJmrywtwRfq9Q7yNV6g2A\"\");Token Use the token() function to search based on the token name used to pay for the upload. Any of these values are acceptable. const results = await myQuery.search(\"\"irys:transactions\"\").token(\"\"solana\"\");Block id Use the ids() function to search for Arweave blocks with the specified IDs. const results = await myQuery.search(\"\"arweave:blocks\"\").ids([\"\"R0ZLe4RvHxLJLzI1Z9ppyYVWFyHW4D1YrxXKuA9PGrwkk2QAuXCnD1xOJe-QOz4l\"\"]);Block height Use the mixHeight() and maxHeight() functions to search for blocks within the specified block height range. Results are `>= minHeight and = minHeight and{const timestamp = (await arweave.blocks.getByHeight(height)).timestamp;if (typeof timestamp === \"\"number\"\" && isFinite(timestamp) && !isNaN(timestamp) && timestamp > 0)return timestamp * 1000;throw new Error(Illegal block timestamp: ${timestamp}); }; export async function getBlockHeightFromTime(time: number, aimFor?: \"\"before\"\" | \"\"after\"\"): Promise {const currentHeight = (await arweave.network.getInfo()).height;const avgBlockTime = 2 * 60 * 1000;const estimateHeightDelta = Math.ceil((Date.now() - time) / avgBlockTime);const estimateHeight = currentHeight - estimateHeightDelta;// Get blocks from around the estimateconst height = estimateHeight;let wobble = 0;let closestDelta = Infinity;let closestHeight = 0;let twoClosest = 0; // Below will flip flop between two values at mimimumfor (let i = 0; i20 * 60 * 1000) {wobble += Math.floor((cDelta / avgBlockTime) * 0.75) * -1;} else {wobble += cDelta > 0 ? -1 : 1;}if (Math.abs(cDelta)0) {closestHeight -= 1;}} else if (aimFor === \"\"after\"\") {if (closestDelta < 0) {closestHeight += 1;}}return closestHeight; }Sorting Use the sort() function to sort results by timestamp in ascending order: const results = await myQuery.search(\"\"irys:transactions\"\").token(\"\"ethereum\"\").sort(\"\"ASC\"\"); or descending order: const results = await myQuery.search(\"\"irys:transactions\"\").token(\"\"matic\"\").sort(\"\"DESC\"\");First result Use the first() function to return only the first result: const results = await myQuery.search(\"\"irys:transactions\"\").tags([{ name: \"\"Content-Type\"\", values: [\"\"image/png\"\"] }]).first();Limiting search results Use the limit() function to limit the maximum number of results returned. This overrides the default value of 1000 results when searching Irys and 100 when searching Arweave directly. const results = await myQuery.search(\"\"irys:transactions\"\").ids([\"\"xXyv3u9nHHWGiMJlDMgLwwRdOTlIlQZyqaKrOkNZw\"\", \"\"xE7tG1kl2FgCUDgJ5jNJeVA6R5kuys7A6f1qfh9Kw\"\"]).limit(20);Pagination / streaming Use the stream() function to manage large results sets. This function returns an iterable stream that continuously yields results as long as your query keeps producing them. // Create the stream const stream = await myQuery.search(\"\"irys:transactions\"\").token(\"\"solana\"\").stream(); // Iterate over the results for await (const result of stream) {console.log(result); }Limiting fields returned Use the fields() function to limit the fields returned. To limit the results, set a field's value to false or omit it entirely. The fields available for retrieval depend on the search type, when searching irys:transactions, the following fields are available: .fields({id: true, // Transaction IDtoken: true, // Token used for paymentaddress: true, // Cross-chain address used for signing and paymentreceipt: {deadlineHeight: true, // The block number by which the transaction must be finalized on Arweavesignature: true, // A signed deep hash of the JSON receipttimestamp: true, // Timestamp, millisecond accurate, of the time the uploaded was verifiedversion: true, // The receipt version, currently 1.0.0},tags: { // An array of tags associated with the uploadname: true,value: true,},signature: true, // A signed deep hash of the JSON receipttimestamp: true, // Timestamp, millisecond accurate, of the time the uploaded was verified }) When searching by arweave:transactions the following fields are available: .fields({id: true, // Transaction IDtags: {// Tags associated with the uploadname: true,value: true,},anchor: true,block: {height: true, // Block heightid: true, // Block IDprevious: true, // Todotimestamp: true, // Block timestamp},bundledIn: {id: true,},data: {size: true, // Data sizetype: true, // Date type},fee: {ar: true, // Fee paid in ARwinston: true, // Fee paid in Winston},owner: {address: true, // Transation originatorkey: true, // Public key},quantity: {ar: true, // Amount of AR transferred (for token transfers)winston: true, // Amount of AR transferred (for token transfers)},recipient: true, // Transfer recipient (for token transfers)signature: true, // Transaction signature }) When searching by arweave:blocks the following fields are available: .fields({height: true,id: true,previous: true,timestamp: true, }) `",
  "origin": "docs"
},{
  "url": "/developer-docs/querying",
  "title": "Querying",
  "description": "Search Irys and Arweave",
  "text": "QueryingSearch Irys and Arweave using our query package and GraphQL endpoints.Query packageThe easiest way to search Irys and Arweave is by using the [Irys querypackage](/developer-docs/querying/query-package), a JavaScript-based abstraction that sits on top of our GraphQLendpoints.GraphQLIrys also supports querying directly using GraphQL. Users can query [Irys directly using the GraphQLsandbox](/developer-docs/querying/graphql#graphql-sandbox), or embed GraphQL queries in any other programminglanguage.",
  "origin": "docs"
},{
  "url": "/developer-docs/tags",
  "title": "Metadata Tagging",
  "description": "Tagging uploads with custom metadata.",
  "text": "Metadata Tagging Irys supports attaching metadata tags to each transaction. Tags can be used to: Categorize transactions, making it easier to search for and retrieve relevant information Build mutable references Inform web browsers how to render filesQuerying Tags are indexed by gateways and are queryable using the Irys query package and GraphQL.Content-Type The Irys CLI automatically infers and sets the appropriate Content-Type tag based on the file extension when uploading files and folders. If your use case necessitates manual Content-Type tag setting, you can specify it during the upload process. Doing so will override the default behavior and apply the Content-Type you provided. // Your file const fileToUpload = \"\"./myImage.png\"\"; // Add a custom Content-Type tag const tags = [{ name: \"\"Content-Type\"\", value: \"\"image/png\"\" }]; try {const response = await irys.uploadFile(fileToUpload, { tags: tags });console.log(File uploaded ==> https://gateway.irys.xyz/${response.id}); } catch (e) {console.log(\"\"Error uploading file \"\", e); } You can also add tags via the CLI's -t option, followed by a series of name / value pairs irys upload myImage.png -t tagName1 tagValue1 tagName2 tagValue2 -n mainnet -t matic -w bf20......c9885307Additional Uses There are no limits on the number of tags you can append to your files or folders. You're free to add as many tags as you wish, enabling the construction of semi-relational models within your data. A popular practice involves creating an application-id tag, this tag helps segregate your uploads from others. // Your file const fileToUpload = \"\"./myNFT.png\"\"; const tags = [{ name: \"\"application-id\"\", value: \"\"NFTs To The Moon\"\" }]; try {const response = await irys.uploadFile(fileToUpload, { tags: tags });console.log(File uploaded ==> https://gateway.irys.xyz/${response.id}); } catch (e) {console.log(\"\"Error uploading file \"\", e); } `",
  "origin": "docs"
},{
  "url": "/developer-docs/using-devnet",
  "title": "Using devnet",
  "description": "Build and prototype your application on Irys' Devnet",
  "text": "Using devnet Uploads to Irys' devnet are paid for using free faucet tokens and are kept for approximately 60 days. Devnet is for developers who are building projects or learning how to use our SDK. To connect to devnet, set the network parameter to devnet when instantiating either an Irys or WebIrys object.RPC / Provider URL When using devnet with the Irys class and with our CLI, you must specify an RPC address. When using the WebIrys class, the RPC address is only required when using non-EVM chains.If you encounter this message when using our SDK or CLI, make sure you are supplying the correct RPC URL for the chain you're using. Using Irys devnet requires a dev/testnet RPC to be configured! Irys class (server-side)EVM Chains const getIrys = async () => {const network = \"\"devnet\"\";const token = \"\"matic\"\";// Devnet RPC URLs change often, use a recent one from https://chainlist.org/const providerUrl = \"\"\"\";const irys = new Irys({network, // URL of the node you want to connect totoken, // Token used for paymentkey: process.env.EVMPRIVATEKEY, // EVM private keyconfig: { providerUrl }, // Provider URL, only required when using devnet});return irys; };Solana const getIrys = async () => {const network = \"\"devnet\"\";const token = \"\"solana\"\";const providerUrl = \"\"https://api.devnet.solana.com\"\";const irys = new Irys({network, // URL of the node you want to connect totoken, // Token used for paymentkey: process.env.SOLPRIVATEKEY, // SOL private keyconfig: { providerUrl }, // Provider URL, only required when using Devnet});return irys; };WebIrys class (browser)EVM Chains const getWebIrys = async () => {// Ethers5 providerawait window.ethereum.enable();const provider = new providers.Web3Provider(window.ethereum);const network = \"\"devnet\"\";const token = \"\"matic\"\";// Devnet RPC URLs change often, use a recent one from https://chainlist.orgconst rpcUrl = \"\"\"\"; // Required for devnet// Create a wallet objectconst wallet = { rpcUrl: rpcUrl, name: \"\"ethersv5\"\", provider: provider };// Use the wallet objectconst webIrys = new WebIrys({ network, token, wallet });await webIrys.ready();return webIrys; };Solana const getWebIrys = async () => {await window.solana.connect();const provider = new PhantomWalletAdapter();await provider.connect();const network = \"\"devnet\"\";const token = \"\"solana\"\";const rpcUrl = \"\"https://api.devnet.solana.com\"\"; // Required for devnet// Create a wallet objectconst wallet = { rpcUrl: rpcUrl, name: \"\"ethersv5\"\", provider: provider };// Use the wallet objectconst webIrys = new WebIrys({ network, token, wallet });await webIrys.ready();return webIrys; };CLI See CLI documentation for examples of how to use each command with our devnet. irys upload myImage.png \\-n devnet \\-t matic \\-w bf20......c9885307 \\--tags tagName1 tagValue1 tagName2 tagValue2 \\--provider-url https://rpc-mumbai.maticvigil.comDevnet RPC URLs change often, use a recent one from https://chainlist.org/ ",
  "origin": "docs"
},{
  "url": "/hands-on/quests",
  "title": "Developer quests",
  "description": "Join a global community of over 40,000 developers building on Irys.",
  "text": "Developer questsJoin a global community of over 40,000 developers building on Irys.Earn unique NFTs for each quest you complete!Season 1 quests are currently closed to new submissions.Season 2 is launching soon. Stay tuned!",
  "origin": "docs"
},{
  "url": "/hands-on/repositories",
  "title": "Repositories",
  "description": "Roll up your sleeves and start building on Irys",
  "text": "RepositoriesProvenance ToolkitKickstart your next project with Irys' opensource UI Toolkit Gasless UploaderStreamline your project's UX by paying for user uploads. Mobile PWA with PrivyUse Privy's embedded wallets to build a mobile PWA with a Web2-like login experience. Encryption with LitUse Lit Protocol to encrypt data before storing onchain with Irys Solana NFT MarketplaceBuild an NFT marketplace on Solana using Metaplex ",
  "origin": "docs"
},{
  "url": "/hands-on/tutorials/browser-based-encryption",
  "title": "Encrypting onchain data (browser-based)",
  "description": "How to encrypt data before storing onchain (browser-based edition)",
  "text": "Encrypting onchain data (browser-based) This guide teaches you how to: Encrypt a File uploaded from the browser using Lit Protocol Establish a set of rules determining who can decrypt the File Store the encrypted File on Arweave using Irys Decrypt the File using Lit Protocol Display the decrypted File in the browser Before diving into this guide, begin with \"\"Encrypting onchain data\"\".The Irys Provenance Toolkit features an [encrypted uploadercomponent](https://provenance-toolkit.irys.xyz/encrypted-uploader) that allows for file uploads directly from thebrowser, handles its encryption and decryption, and displays the decrypted file. When building your project,consider cloning the Toolkit repository to use as a foundation. Dependencies Install using npm: npm install @irys/sdk @lit-protocol/lit-node-client@^3 ethers@^5 or yarn: yarn add @irys/sdk @lit-protocol/lit-node-client@^3 ethers@^5ImportsEncrypting a FileFile uploader Add a form to an HTML page that accepts a file as input:Wallet signature Use the Lit SDK function checkAndSignAuthMessage() to prompt the user to sign a basic transaction, confirming wallet ownership. Authentication details are then saved in the browser's local storage, future calls to checkAndSignAuthMessage() will use the stored version if present. const authSig = await checkAndSignAuthMessage({chain: process.env.NEXTPUBLICLIT_CHAIN || \"\"polygon\"\", });Lit node Connect to a Lit node: const litNodeClient = new LitJsSdk.LitNodeClient({litNetwork: \"\"cayenne\"\", }); await litNodeClient.connect();Access control conditions Define rules for who to decrypt your data, limiting it to anyone with >= 0 ETH: // This defines who can decrypt the data function getAccessControlConditions() {const accessControlConditions = [{contractAddress: \"\"\"\",standardContractType: \"\"\"\",chain: \"\"ethereum\"\",method: \"\"eth_getBalance\"\",parameters: [\"\":userAddress\"\", \"\"latest\"\"],returnValueTest: {comparator: \"\">=\"\",value: \"\"0\"\", // 0 ETH, so anyone can open},},];return accessControlConditions; } To the wallet 0x50e2dac5e78B5905CB09495547452cEE64426db2 const accessControlConditions = [{contractAddress: \"\"\"\",standardContractType: \"\"\"\",chain,method: \"\"\"\",parameters: [\"\":userAddress\"\"],returnValueTest: {comparator: \"\"=\"\",value: \"\"0x50e2dac5e78B5905CB09495547452cEE64426db2\"\",},}, ]; Or by people who hold a given ERC721: const accessControlConditions = [{contractAddress: \"\"0xA80617371A5f511Bf4c1dDf822E6040acaa63e71\"\",standardContractType: \"\"ERC721\"\",chain,method: \"\"balanceOf\"\",parameters: [\"\":userAddress\"\"],returnValueTest: {comparator: \"\">\"\",value: \"\"0\"\",},}, ];Encrypting Finally, encrypt the File using Lit's encryptFileAndZipWithMetadata() function. This function takes the File object, encrypts it and stores it in a single zip file with all metadata. // Create a zip blob containing the encrypted file and associated metadata const zipBlob = await LitJsSdk.encryptFileAndZipWithMetadata({chain: process.env.NEXTPUBLICLIT_CHAIN || \"\"polygon\"\",authSig,accessControlConditions,file,litNodeClient,readme: \"\"This file was encrypted using LitProtocol and the Irys Provenance Toolkit.\"\", });Storing on Arweave via Irys Once encrypted, use webIrys.uploadFile() to upload the zip blob. In this case, we tag the upload with a tag indicating the content type of the underlying file, and another tag letting us know it's encrypted. // Tag the upload marking it as // - Binary file // - Containing a file of type file.type (used when displaying) // - Encrypted (used by our display code) const tags: Tag[] = [{name: \"\"Content-Type\"\",value: \"\"application/octet-stream\"\",},{name: \"\"Encrypted-File-Content-Type\"\",value: file.type,},{name: \"\"Irys-Encrypted\"\",value: \"\"true\"\",}, ]; const receipt = await irys.uploadFile(file, {tags, });Combined file Then, combine everything in a single file: async function encryptFile(file: File) {// 1. Connect to a Lit nodeconst litNodeClient = new LitJsSdk.LitNodeClient({litNetwork: \"\"cayenne\"\",});await litNodeClient.connect();// 2. Ensure we have a wallet signatureconst authSig = await LitJsSdk.checkAndSignAuthMessage({chain: process.env.NEXTPUBLICLIT_CHAIN || \"\"polygon\"\",});// 3. Define access control conditions.// This defines who can decrypt, current settings allow for// anyone with a ETH balance >= 0 to decrypt, which// means that anyone can. This is for demo purposes.const accessControlConditions = [{contractAddress: \"\"\"\",standardContractType: \"\"\"\",chain: \"\"ethereum\"\",method: \"\"eth_getBalance\"\",parameters: [\"\":userAddress\"\", \"\"latest\"\"],returnValueTest: {comparator: \"\">=\"\",value: \"\"0\"\",},},];// 4. Create a zip blob containing the encrypted file and associated metadataconst zipBlob = await LitJsSdk.encryptFileAndZipWithMetadata({chain: process.env.NEXTPUBLICLIT_CHAIN || \"\"polygon\"\",authSig,accessControlConditions,file,litNodeClient,readme: \"\"This file was encrypted using LitProtocol and the Irys Provenance Toolkit.\"\",});return zipBlob; } // Uploads the encrypted File (with metadata) to Irys async function uploadFile(file: File): Promise {const irys = await getIrys();try {const price = await irys.getPrice(file?.size);const balance = await irys.getLoadedBalance();if (price.isGreaterThanOrEqualTo(balance)) {console.log(\"\"Funding node.\"\");await irys.fund(price);} else {console.log(\"\"Funding not needed, balance sufficient.\"\");}// Tag the upload marking it as// - Binary file// - Containing a file of type file.type (used when displaying)// - Encrypted (used by our display code)const tags: Tag[] = [{name: \"\"Content-Type\"\",value: \"\"application/octet-stream\"\",},{name: \"\"Encrypted-File-Content-Type\"\",value: file.type,},{name: \"\"Irys-Encrypted\"\",value: \"\"true\"\",},];const receipt = await irys.uploadFile(file, {tags,});console.log(Uploaded successfully. ${GATEWAY_BASE}${receipt.id});return receipt.id;} catch (e) {console.log(\"\"Error uploading single file \"\", e);}return \"\"\"\"; } // Encrypts and then uploads a File async function encryptAndUploadFile(file: File): Promise {const encryptedData = await encryptFile(file);return await uploadFile(encryptedData); } And call it from your HTML form:document.getElementById(\"\"uploadForm\"\").addEventListener(\"\"submit\"\", function (event) {event.preventDefault();handleUpload();});async function handleUpload() {const fileInput = document.getElementById(\"\"fileToUpload\"\");const file = fileInput.files[0];if (file) {const result = await encryptAndUploadFile(file);} else {alert(\"\"Please select a file to upload.\"\");}} Decrypting a File To decrypt and display the image: Load the data from the Irys gateway Extract the zip blob Decrypt it async function decryptFile(id: string, encryptedFileType: string): Promise {try {// 1. Retrieve the file from https://gateway.irys.xyz/${id}const response = await fetch(${GATEWAY_BASE}${id});if (!response.ok) {throw new Error(Failed to fetch encrypted file from gateway with ID: ${id});}// 2. Extract the zipBlobconst zipBlob = await response.blob();// 3. Connect to a Lit nodeconst litNodeClient = new LitJsSdk.LitNodeClient({litNetwork: \"\"cayenne\"\",});await litNodeClient.connect();// 3.5 Get a reference to an AuthSig (if in local storage that will be used instead of prompting the user to sign)const authSig = await LitJsSdk.checkAndSignAuthMessage({chain: process.env.NEXTPUBLICLIT_CHAIN || \"\"polygon\"\",});// 4. Decrypt the zipBlobconst result = await LitJsSdk.decryptZipFileWithMetadata({file: zipBlob,litNodeClient: litNodeClient,authSig: authSig, // Include this only if necessary});const decryptedFile = result.decryptedFile;// 5. Convert to a blobconst blob = arrayBufferToBlob(decryptedFile, encryptedFileType);// 6. Build a dynamic URLconst dataUrl = await blobToDataURL(blob);return dataUrl;} catch (e) {console.error(\"\"Error decrypting file:\"\", e);}return \"\"\"\"; }Displaying encrypted File in the browser After decrypting the image file, you need to convert the data blob to a URL with the format data:image/png;base64,[base64-encoded-data] before setting it as the src attribute of an `` element. These functions assist in converting the data blob to a URL. // Helper functions for use in showing decrypted images function arrayBufferToBlob(buffer: ArrayBuffer, type: string): Blob {return new Blob([buffer], { type: type }); } function blobToDataURL(blob: Blob): Promise {return new Promise((resolve, reject) => {const reader = new FileReader();reader.onload = (event) => {if (event.target?.result) {resolve(event.target.result as string);} else {reject(new Error(\"\"Failed to read blob as Data URL\"\"));}};reader.readAsDataURL(blob);}); }Full code All of this code is contained in a single file as part of the Provenance Toolkit.Server-side example Server-side encryptionDemo Irys Provenance Toolkit",
  "origin": "docs"
},{
  "url": "/hands-on/tutorials/dynamic-nft",
  "title": "Create a dynamic NFT",
  "description": "Learn how to create a dynamic NFT using mutable references.",
  "text": "Create a dynamic NFT In this tutorial, you will create a dynamic NFT using Irys' mutable references.About Dynamic NFTs are NFTs whose metadata evolves over time. They are commonly used in: Gaming projects where in-game assets evolve as players progress. Loyalty programs where NFTs evolve as users accumulate points.This tutorial focuses on creating a SuperMon NFT that could evolve during gameplay. The NFT starts with a basic appearance and can be \"\"upgraded\"\" twice. We will use the Irys CLI to update the metadata, simulating the automatic changes that would occur through player interactions in an actual game.Mutable references Mutable references are a way to simulate \"\"mutability\"\". You start by creating a single static URL that is tied to a chain of transactions: const irys = await getIrys(); const receiptOne = await irys.upload(\"\"First TX\"\"); console.log(TX 1 uploaded https://gateway.irys.xyz/mutable/${receiptOne.id}); The chain can be updated at any time, and the original URL will always resolve to the most recent one: const tags = [{ name: \"\"Root-TX\"\", value: receiptOne.id }]; const receiptTwo = await irys.upload(\"\"Second TX\"\", { tags: tags }); console.log(TX 2 uploaded https://gateway.irys.xyz/mutable/${receiptOne.id});Setup In this tutorial, we will build on the Base L2. Before starting, make sure you add Base Sepolia to your EVM wallet, pre-load some Base Sepolia tokens, and export your private key.While we focus on Base Sepolia, the principles outlined can be adapted for deployment on any blockchain. Smart contract We're building an NFT, which means we need a smart contract. Here's a simple one you can use to mint the NFT we'll create. // SPDX-License-Identifier: MIT pragma solidity ^0.8.0; // Import OpenZeppelin's ERC721 and ERC721URIStorage contracts // These URLs are compatible with Remix IDE import \"\"@openzeppelin/contracts/token/ERC721/ERC721.sol\"\"; import \"\"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\"\"; import \"\"@openzeppelin/contracts/access/Ownable.sol\"\"; contract SuperMon is ERC721URIStorage {uint256 private _tokenIdCounter;// No arguments in the constructor, the owner will be the contract deployerconstructor() ERC721(\"\"SuperMon\"\", \"\"SMON\"\") {_tokenIdCounter = 0;}// Mint function to create a new NFTfunction mint(address to, string memory uri) public {uint256 tokenId = _tokenIdCounter;_tokenIdCounter += 1;_safeMint(to, tokenId);_setTokenURI(tokenId, uri);} } To deploy the smart contract using Remix IDE: Open Remix IDE. Create a new solidity file In the File Explorers pane, click on the Create New File icon. Name your file SuperMon.sol, and paste the smart contract in. Compile the contract Click on the Solidity Compiler icon in the sidebar. Select the compiler version that matches your contract's pragma (^0.8.0). Click Compile SuperMon.sol. Deploy the Contract Click on the Deploy & Run Transactions icon in the sidebar. In the ENVIRONMENT dropdown, select Injected Web3. MetaMask will prompt you to connect. Confirm the connection to your Remix session. Ensure SuperMon is selected in the CONTRACT dropdown. Click Deploy. MetaMask will ask for confirmation to proceed with the transaction.Uploading the imagesRght-click on each of the above images and save them on your local drive. Next, fund the Irys Devnet node with 0.1 Sepolia ETH to pay for your uploads.In all of these CLI examples, make sure to replace the value of the -w parameter with your own private key.irys fund 100000000000000000 \\-n devnet \\-t base-eth \\-w 6dd5e....54a120201cb6a \\--provider-url https://sepolia.base.orgThe fund command accepts a value in atomic units, 0.1 ETH is equal to 100000000000000000 in atomic units.Next, use the Irys CLI to upload each of the images to the Irys Devnet. irys upload image-level-1.png \\-n devnet \\-t base-eth \\-w 6dd5e....54a120201cb6a \\--tags Content-Type image/png \\--provider-url https://sepolia.base.org irys upload image-level-2.png \\-n devnet \\-t base-eth \\-w 6dd5e....54a120201cb6a \\--tags Content-Type image/png \\--provider-url https://sepolia.base.org irys upload image-level-3.png \\-n devnet \\-t base-eth \\-w 6dd5e....54a120201cb6a \\--tags Content-Type image/png \\--provider-url https://sepolia.base.orgUploading the metadata Create three metadata files similar to the ones below. Make sure to change the value of the image field to match the URLs generated in the previous step. {\"\"name\"\": \"\"SuperMon\"\",\"\"symbol\"\": \"\"SMON\"\",\"\"image\"\": \"\"https://gateway.irys.xyz/QH3rksVhbFg5L9vvjGzb4POUibCEG-TGPInmofp-O-o\"\",\"\"description\"\": \"\"Super dooper, changing shapes, changing power\"\",\"\"attributes\"\": [{\"\"trait_type\"\": \"\"supermon-level\"\",\"\"value\"\": \"\"1\"\"}] } {\"\"name\"\": \"\"SuperMon\"\",\"\"symbol\"\": \"\"SMON\"\",\"\"image\"\": \"\"https://gateway.irys.xyz/QH3rksVhbFg5L9vvjGzb4POUibCEG-TGPInmofp-O-o\"\",\"\"description\"\": \"\"Super dooper, changing shapes, changing power\"\",\"\"attributes\"\": [{\"\"trait_type\"\": \"\"supermon-level\"\",\"\"value\"\": \"\"2\"\"}] } {\"\"name\"\": \"\"SuperMon\"\",\"\"symbol\"\": \"\"SMON\"\",\"\"image\"\": \"\"https://gateway.irys.xyz/QH3rksVhbFg5L9vvjGzb4POUibCEG-TGPInmofp-O-o\"\",\"\"description\"\": \"\"Super dooper, changing shapes, changing power\"\",\"\"attributes\"\": [{\"\"trait_type\"\": \"\"supermon-level\"\",\"\"value\"\": \"\"3\"\"}] } And upload just the first file using the Irys CLI. irys upload metadata-level-1.json \\-n devnet \\-t base-eth \\-w 6dd5e....54a120201cb6a \\--tags Content-Type application/json \\--provider-url https://sepolia.base.org The CLI will return a URL similar to https://gateway.irys.xyz/NDtKvjlmZL2iXUPmX6P-BuvtnvAEFkUiQWG8ToyK5FM. To convert that to a mutable references URL, interpolate it by adding /mutable/ after the domain and before the transaction ID. Your final URL will be similar to https://gateway.irys.xyz/mutable/NDtKvjlmZL2iXUPmX6P-BuvtnvAEFkUiQWG8ToyK5FM.Mint the NFT To mint your NFT in Remix: Return to Remix. Under \"\"Deployed Contracts\"\", locate your contract and expand it to see its functions. Under the Mint function, enter the wallet address you want to mint the NFT to and the metadata URL (e.g. https://gateway.irys.xyz/mutable/NDtKvjlmZL2iXUPmX6P-BuvtnvAEFkUiQWG8ToyK5FM) from the previous step. Click Transact.You can now view the NFT on the Opensea Testnet.Mutating the metadata To now \"\"mutate\"\" the NFT, upload a new version of the metadata tagging it as having a Root-TX equal to the transaction ID of your first transaction. In my example, I pass the value of NDtKvjlmZL2iXUPmX6P-BuvtnvAEFkUiQWG8ToyK5FM, however make sure to change this to match your unique transaction ID. irys upload metadata-level-2.json \\-n devnet \\-t base-eth \\-w 6dd5e....54a120201cb6a \\--tags Content-Type application/json Root-TX NDtKvjlmZL2iXUPmX6P-BuvtnvAEFkUiQWG8ToyK5FM \\--provider-url https://sepolia.base.org Return to Opensea and request that it refresh your metadata.Give it a few minutes and your updated NFT should be visible.Free metadata uploads This tutorial uses the Irys Devnet where uploads are kept for ~60 days and are paid for with free faucet currencies. When deploying production projects, you'll want to use either Node 1 or 2 where uploads are permanent. On Irys' Node 2 uploads of less than 100 KiB are free, which is more than enough for most metadata files. This means projects can let users \"\"evolve\"\" their NFTs without having to pay gas fees.Caching Wallets and NFT platforms typically cache metadata to optimize performance, this can affect the visibility of updates to dynamic NFTs. While OpenSea offers a feature for users to manually request metadata refreshes, not all platforms provide this level of control. When building dynamic NFT projects, make sure to thoroughly test and understand the implications of caching on your platform.Getting help Any questions? Reach out to us in Discord.",
  "origin": "docs"
},{
  "url": "/hands-on/tutorials/encrypting-onchain-data",
  "title": "Encrypting onchain data",
  "description": "Using Lit Protocol to encrypt on-hain data with Irys and Arweave",
  "text": "Encrypting onchain data Data uploaded to Irys is stored permanently on Arweave. Once on Arweave, this data becomes publicly accessible, anyone can view it. For projects where privacy is a concern, you can use LitProtocol to encrypt your data before storing it on Irys. This guide is an overview of what Lit Protocol is and how to use it with Irys. We also have code examples teaching how to do server-side and browser-based encryption. Additionally, the open-source Irys Provenance Toolkit has an encrypted uploader component you can drop into any React-based project.Lit Protocol Lit Protocol enables developers to create and manage decentralized keys for condition-based encryption and programmatic signing for digital assets. In short, you can use it to: Encrypt data Define fine-grained access rules for who can decrypt data Decrypt data Encrypted data can be stored on Irys, then retrieved and decrypted at any point in the future.Irys + Lit use cases Using Lit Protocol with Irys opens up new opportunities for builders, including: Gating access to content Encrypting posts for Lens protocol Decentralized identity verification Creating private data marketplaces Creating NFTs only viewable by their owner Storing private personal data on-chainUsing Lit Protocol, the access control conditions provide near infinite flexibility. Imagine a system for governmentbid management: bids are required to be submitted by a specific deadline, tracked using Irys' millisecond-accuratetimestamps. The bids remain encrypted up to this deadline, aiding in preventing corruption by ensuring the bids areinaccessible to all parties until the designated time. Encrypting dataThere are three steps to encrypting data Obtain a wallet signature (AuthSig), which proves you own a wallet Define access control conditions for who can decrypt your data Connect to a Lit node and request that it encrypt your dataAccess control conditions Lit Protocol enables users to set access control conditions specifying who can decrypt data. This provides builders with the flexibility to designate data decryption permissions, including: A single wallet address DAO membership Owners of an ERC20 or ERC721 Outcomes from a smart contract call Outcomes from an API callDecrypting dataThere are three steps to decrypting data: Obtain a wallet signature (AuthSig), which proves you own a wallet Retrieve data stored on Arweave Connect to a Lit node and request that it decrypt your dataCode examples Server-side encryption Browser-based encryptionDemo Irys Provenance Toolkit",
  "origin": "docs"
},{
  "url": "/hands-on/tutorials/gasless-uploading",
  "title": "Gasless Uploading With Server-Side Signing",
  "description": "Using Server-Side signing to implement gasless transactions.",
  "text": "Gasless Uploading With Server-Side Signing Server-side signing is a method to allow you to sign (and pay) for your users' data securely (without exposing your private key). It is a form of gasless transactions. Server-side signing works in 4 main steps: The client requests the required information from the server (mainly public key). The client transfers the minimum amount of data required for signing (known as the signature info) to a server (which has access to the private key). The server then signs this data and returns the resulting signature to the client. The client then inserts this signature into their data, resulting in a signed transaction identical to if the client had access to the private key.Supported Currencies Currently, server-side signing is supported for the following: Ethereum Matic BNB Fantom Avalanche Boba-Eth Arbitrum Chainlink Boba SolanaGetting Started The quickest way to get started is to clone our example repository which supports gasless uploads from both EVM and Solana chains. We also have an online demo available as part of the Provenance Toolkit.API Routes The example app exposes three API routes, you can pick and choose which to use based on your own app design.publicKey.ts The route publicKey.ts returns the public key for the server's wallet. This is the first route called by the client.Solana-Based Wallets /**@returns The server's public key.*/ async function serverInit(): Promise {const key = process.env.PRIVATEKEYSOL;const token = \"\"solana\"\";// Change if deploying on mainnetconst providerUrl = \"\"https://api.devnet.solana.com\"\";const serverIrys = new Irys({network: \"\"devnet\"\", // Irys network \"\"mainnet\"\" || \"\"devnet\"\"token, // Token used for payment and signingkey,config: { providerUrl }, // Only required when using Devnet});const publicKey = serverIrys.tokenConfig.getSigner().publicKey;return publicKey; } export async function GET(req: Request) {return NextResponse.json({ pubKey: (await serverInit()).toString(\"\"hex\"\") }); }EVM-Based /**@returns The server's public key.*/ async function serverInit(): Promise {const key = process.env.PRIVATEKEYEVM; // your private key;if (!key) throw new Error(\"\"Private key is undefined!\"\");const signer = new TypedEthereumSigner(key);return signer.publicKey; } export async function GET(req: Request) {return NextResponse.json({ pubKey: (await serverInit()).toString(\"\"hex\"\") }); }signData.ts The route signData.ts signs the data provided using the server's private key. This is the second route called by the client.Solana-Based Wallets /*** @returns A signed version of the data, signatureData, as sent by the client.*/ async function signDataOnServer(signatureData: Buffer): Promise {const key = process.env.PRIVATEKEYSOL;const token = \"\"solana\"\";const network = process.env.NEXTPUBLICNETWORK || \"\"devnet\"\";// Change if deploying on mainnetconst providerUrl = \"\"https://api.devnet.solana.com\"\";const serverIrys = new Irys({network, // \"\"mainnet\"\" || \"\"devnet\"\"token, // Token used for payment and signingkey: key,config: { providerUrl }, // Only required when using Devnet});const encodedMessage = Buffer.from(signatureData);if (!key) throw new Error(missing required solana private key);// the client now uses HexSolanaSigner instead of SolanaSigner, so we have to use the SolanaSigner directly so the signature data isn't hex converted twice.const signature = await new SolanaSigner(key).sign(encodedMessage);const isValid = await HexInjectedSolanaSigner.verify(serverIrys.tokenConfig.getPublicKey() as Buffer,signatureData,signature,);console.log(\"\"is tx valid?\"\", isValid);return Buffer.from(signature); } async function readFromStream(stream: ReadableStream): Promise {const reader = stream.getReader();let result = \"\"\"\";while (true) {const { done, value } = await reader.read();if (done) break;result += new TextDecoder().decode(value);}return result; } export async function POST(req: Request) {//@ts-ignoreconst rawData = await readFromStream(req.body);const body = JSON.parse(rawData);const signatureData = Buffer.from(body.signatureData, \"\"hex\"\");const signature = await signDataOnServer(signatureData);return NextResponse.json({ signature: signature.toString(\"\"hex\"\") }); }EVM-Based /*** @returns A signed version of the data, signatureData, as sent by the client.*/ async function signDataOnServer(signatureData: Buffer): Promise {const key = process.env.PRIVATEKEYEVM;if (!key) throw new Error(\"\"Private key is undefined!\"\");const signer = new TypedEthereumSigner(key);return Buffer.from(await signer.sign(signatureData)); } async function readFromStream(stream: ReadableStream): Promise {const reader = stream.getReader();let result = \"\"\"\";while (true) {const { done, value } = await reader.read();if (done) break;result += new TextDecoder().decode(value);}return result; } export async function POST(req: Request) {//@ts-ignoreconst rawData = await readFromStream(req.body);const body = JSON.parse(rawData);const signatureData = Buffer.from(body.signatureData, \"\"hex\"\");const signature = await signDataOnServer(signatureData);return NextResponse.json({ signature: signature.toString(\"\"hex\"\") }); }lazyFund.ts The route lazyFund.ts is an optional route used for lazy-funding uploads. Some projects using server-side signing prefer to do upfront funding where they transfer over a budget of tokens first and then slowly use those to pay for uploads. If you're using upfront funding, you can omit this step. To perform lazy-funding of uploads, pass the exact number of bytes you want to fund to this route. The route will compute the current cost to upload those bytes and fund it using the server's private key.Solana-Based Wallets /**Given a file of the specified size, get the cost to upload, then fund a node that amount@param filesize The size of a file to fund for@returns*/ async function lazyFund(filesize: string): Promise {console.log(\"\"lazyFund SOL\"\");const key = process.env.PRIVATEKEYSOL;const token = \"\"solana\"\";const url = process.env.NEXTPUBLICNODE || \"\"\"\";// Change if deploying on Mainnetconst providerUrl = \"\"https://api.devnet.solana.com\"\";const serverIrys = new Irys({url, // URL of the node you want to connect totoken, // Token used for payment and signingkey: key,config: { providerUrl }, // Only required when using Devnet});const price = await serverIrys.getPrice(parseInt(filesize));console.log(\"\"lazyFund SOL price=\"\", price);const balance = await serverIrys.getLoadedBalance();console.log(\"\"lazyFund SOL balance=\"\", balance);let fundTx;if (price.isGreaterThanOrEqualTo(balance)) {console.log(\"\"Funding node.\"\");fundTx = await serverIrys.fund(price);console.log(\"\"Successfully funded fundTx=\"\", fundTx);} else {console.log(\"\"Funding not needed, balance sufficient.\"\");}// return the transaction idreturn fundTx?.id || \"\"\"\"; } async function readFromStream(stream: ReadableStream | null): Promise {if (!stream) return \"\"\"\";const reader = stream.getReader();let result = \"\"\"\";while (true) {const { done, value } = await reader.read();if (done) break;result += new TextDecoder().decode(value);}return result; } export async function POST(req: Request) {//@ts-ignoreconst rawData = await readFromStream(req.body as ReadableStream | null);const body = JSON.parse(rawData);const fundTx = await lazyFund(body);return NextResponse.json({ txResult: fundTx }); }EVM-Based /**Given a file of the specified size, get the cost to upload, then fund a node that amount@param filesize The size of a file to fund for@returns*/ async function lazyFund(filesize: string): Promise {const key = process.env.PRIVATEKEYEVM;const token = process.env.NEXTPUBLICTOKEN || \"\"\"\";const providerUrl = getRpcUrl(token || \"\"\"\");const serverIrys = new Irys({network: \"\"mainnet\"\", // \"\"mainnet\"\" || \"\"devnet\"\"token, // Token used for payment and signingkey: key,config: { providerUrl }, // Only required when using Devnet});console.log(\"\"serverIrysPubKey\"\",//@ts-ignoreserverIrys.tokenConfigConfig.getPublicKey().toJSON(),);const price = await serverIrys.getPrice(parseInt(filesize));const balance = await serverIrys.getLoadedBalance();let fundTx;if (price.isGreaterThanOrEqualTo(balance)) {console.log(\"\"Funding node.\"\");fundTx = await serverIrys.fund(price);console.log(\"\"Successfully funded fundTx=\"\", fundTx);} else {console.log(\"\"Funding not needed, balance sufficient.\"\");}// return the transaction idreturn fundTx?.id || \"\"\"\"; } async function readFromStream(stream: ReadableStream | null): Promise {if (!stream) return \"\"\"\";const reader = stream.getReader();let result = \"\"\"\";while (true) {const { done, value } = await reader.read();if (done) break;result += new TextDecoder().decode(value);}return result; } export async function POST(req: Request) {//@ts-ignoreconst rawData = await readFromStream(req.body as ReadableStream | null);const body = JSON.parse(rawData);const fundTx = await lazyFund(body);return NextResponse.json({ txResult: fundTx }); }Client-side On the client-side there is a single utility function that calls either the EVM or SOL routes. type Tag = {name: string;value: string; }; const gaslessFundAndUploadEVM = async (selectedFile: File, tags: Tag[]): Promise => {// obtain the server's public keyconst pubKeyRes = (await (await fetch(\"\"/api/publicKeyEVM\"\")).json()) as unknown as {pubKey: string;};const pubKey = Buffer.from(pubKeyRes.pubKey, \"\"hex\"\");// Create a provider - this mimics the behaviour of the injected provider, i.e metamaskconst provider = {// For EVM walletsgetPublicKey: async () => {return pubKey;},getSigner: () => {return {getAddress: () => pubKey.toString(), // pubkey is address for TypedEthereumSigner_signTypedData: async (_domain: never,_types: never,message: { address: string; \"\"Transaction hash\"\": Uint8Array },) => {const convertedMsg = Buffer.from(message[\"\"Transaction hash\"\"]).toString(\"\"hex\"\");console.log(\"\"convertedMsg: \"\", convertedMsg);const res = await fetch(\"\"/api/signDataEVM\"\", {method: \"\"POST\"\",body: JSON.stringify({ signatureData: convertedMsg }),});const { signature } = await res.json();const bSig = Buffer.from(signature, \"\"hex\"\");// Pad & convert so it's in the format the signer expects to have to convert from.const pad = Buffer.concat([Buffer.from([0]), Buffer.from(bSig)]).toString(\"\"hex\"\");return pad;},};},_ready: () => {},};console.log(\"\"Got provider=\"\", provider);// You can delete the lazyFund route if you're prefunding all uploads// 2. then pass the size to the lazyFund API routeconst fundTx = await fetch(\"\"/api/lazyFundEVM\"\", {method: \"\"POST\"\",body: selectedFile.size.toString(),});// Create a new WebIrys object using the provider created with server info.const token = process.env.NEXTPUBLICTOKEN || \"\"\"\";const wallet = { name: \"\"ethersv5\"\", provider: provider };const irys = new WebIrys({network: \"\"mainnet\"\", // \"\"mainnet\"\" || \"\"devnet\"\"token,wallet,});const w3signer = await provider.getSigner();const address = (await w3signer.getAddress()).toLowerCase();await irys.ready();console.log(\"\"Uploading...\"\");const tx = await irys.uploadFile(selectedFile, {tags,});console.log(Uploaded successfully. https://gateway.irys.xyz/${tx.id});return tx.id; }; const gaslessFundAndUploadSOL = async (selectedFile: File, tags: Tag[]): Promise => {// Obtain the server's public keyconst pubKeyRes = (await (await fetch(\"\"/api/publicKeySOL\"\")).json()) as unknown as {pubKey: string;};const pubKey = Buffer.from(pubKeyRes.pubKey, \"\"hex\"\");console.log(\"\"got pubKey=\"\", pubKey);// Create a providerconst provider = {publicKey: {toBuffer: () => pubKey,byteLength: 32,},signMessage: async (message: Uint8Array) => {let convertedMsg = Buffer.from(message).toString(\"\"hex\"\");const res = await fetch(\"\"/api/signDataSOL\"\", {method: \"\"POST\"\",body: JSON.stringify({signatureData: convertedMsg,}),});const { signature } = await res.json();const bSig = Buffer.from(signature, \"\"hex\"\");return bSig;},};// You can delete the lazyFund route if you're prefunding all uploadsconst fundTx = await fetch(\"\"/api/lazyFundSOL\"\", {method: \"\"POST\"\",body: selectedFile.size.toString(),});// Create a new WebIrys object using the provider created with server info.const url = process.env.NEXTPUBLICNODE || \"\"\"\";const wallet = { rpcUrl: \"\"https://api.devnet.solana.com\"\", name: \"\"solana\"\", provider: provider };const irys = new WebIrys({network: \"\"mainnet\"\", // \"\"mainnet\"\" || \"\"devnet\"\"token: \"\"solana\"\",wallet,});await irys.ready();console.log(\"\"WebIrys=\"\", irys);console.log(\"\"Uploading...\"\");const tx = await irys.uploadFile(selectedFile, {tags,});console.log(Uploaded successfully. https://gateway.irys.xyz/${tx.id});return tx.id; }; /**Uploads the selected file and tags after funding if necessary.* @param {File} selectedFile - The file to be uploaded.@param {Tag[]} tags - An array of tags associated with the file.@returns {Promise} - The transaction ID of the upload.*/ const gaslessFundAndUpload = async (selectedFile: File, tags: Tag[], blockchain: \"\"EVM\"\" | \"\"SOL\"\"): Promise => {let txId = \"\"\"\";switch (blockchain) {case \"\"EVM\"\":txId = await gaslessFundAndUploadEVM(selectedFile, tags);break;case \"\"SOL\"\":txId = await gaslessFundAndUploadSOL(selectedFile, tags);break;default:throw new Error(\"\"Unsupported blockchain\"\");}return txId; }; export default gaslessFundAndUpload; `",
  "origin": "docs"
},{
  "url": "/hands-on/tutorials/irys-explorer",
  "title": "Build a transaction explorer for Irys",
  "description": "Learn how to attach a UDL to an NFT",
  "text": "Build a transaction explorer for Irys In this tutorial you will: Learn how to query Irys and Arweave transactions based on content type, payment token and timestamp Build a powerful tool that gives you insights into how Irys is used Learn how to incorporate specialized query functionality in your applications As you build the project, you'll be introduced to the Irys Query package, which greatly simplifies querying Irys and Arweave. Instead of having to use GraphQL, you can now search transactions through a single JavaScript class, you interact with it as you would with any other JavaScript code. Prerequisites For this tutorial, ensure you have Node installed and have a foundational knowledge of TypeScript and Tailwind. You don't need to be an expert, but you should be comfortable with basic data types, project creation, component structure, and implementing styling in a project.Project setup Navigate to an empty directory and create a new NextJS project with the following: npx create-next-app tutorial-query-package When prompted, choose all of the default options, including TypeScript and Tailwind. Installing the Query package CD into the directory you just created: cd tutorial-query-package and install the Irys Query package using npm: npm install @irys/query or yarn: yarn add @irys/queryUI We'll structure our UI beginning with the page.tsx file which then incorporates three additional components: Navbar SearchResults SearchResultsItem The page.tsx file acts as a parent component, hosting these child components and managing shared state. All state is set up in page.tsx and then passed to child components when instantiated. When a user triggers a search, Navbar state gets transferred down to page.tsx, which then uses the Query package to search for transactions. The resulting data is processed, and each item is rendered in the UI as a distinct SearchResultsItem. In this tutorial, first, we’ll build out the complete UI, then go back and add in the query functionality. If you’re only interested in how to integrate the Query class, feel free to skip ahead to “Query Functionality”. page.tsx Start by modeling the application data using TypeScript interfaces. The SearchData interface models the parameters required for each search operation, these parameters include: Irys node Content-Type metatag payment token a date range The SearchResult interface models the structure of an individual search result. It includes the transaction ID, creation date, token, and an array of associated tags. // Models data points used when searching (represented in our NavBar) interface SearchData {irysNode: string;contentType: string;paymentToken: string;fromTimestamp: Date | null;toTimestamp: Date | null; } // Models the result of a single search interface SearchResult {txID: string;creationDate: string;token: string;tags: any[]; } With the interfaces defined, we’ll set up the basic page layout, including a Navbar at the top and the SearchResults at the bottom. Replace the contents of your page.tsx file with the following. \"\"use client\"\"; // Models data points used when searching (represented in our NavBar) interface SearchData {irysNode: string;contentType: string;paymentToken: string;fromTimestamp: Date | null;toTimestamp: Date | null; } // Models the result of a single search interface SearchResult {txID: string;creationDate: string;token: string;tags: any[]; } const useHome = () => {// If true a search is happening and we should show the spinnerconst [isLoading, setIsLoading] = useState(false);// If false we have yet to execute a searchconst [firstSearchRun, setFirstSearchRun] = useState(false);// State variables for our search params.// Set the variables here, and pass them to the Navbarconst [irysNetwork, setIrysNetwork] = useState(\"\"mainnet\"\"); // or \"\"devnet\"\"const [contentType, setContentType] = useState(\"\"None\"\");const [paymentToken, setPaymentToken] = useState(\"\"None\"\");const [fromTimestamp, setFromTimestamp] = useState(null);const [toTimestamp, setToTimestamp] = useState(null);// Stores the results of the searchconst [searchResults, setSearchResults] = useState([]);// Called when a user clicks \"\"Search\"\" in the UIconst handleSearch = async () => {};return {isLoading,firstSearchRun,irysNetwork,setIrysNetwork,contentType,setContentType,paymentToken,setPaymentToken,fromTimestamp,setFromTimestamp,toTimestamp,setToTimestamp,searchResults,handleSearch,}; }; const Home: React.FC = () => {const { isLoading, searchResults, firstSearchRun, handleSearch, ...navProps } = useHome();return ({isLoading ? () : searchResults.length > 0 ? () : firstSearchRun ? (No results found) : null}); }; export default Home;LoadingSpinner Depending on search criteria and number of results returned, searches may take upwards of a few seconds to execute. While a query is running, we’ll show a simple Loading … spinner in the UI. This component is selectively displayed in page.tsx, and has a simple design with no interactivity or state to manage. Create a new file called LoadingSpinner.tsx and paste in the following. // UI component, shows a \"\"Loading ...\"\" spinner when active const LoadingSpinner: React.FC = () => {return (Searching ...); }; export default LoadingSpinner;NavBar The Navbar component is where the user will configure search parameters before passing them down to page.tsx.Start by defining the properties of the Navbar component using the NavbarProps interface. This includes: Network to search (\"\"mainnet\"\" or \"\"devnet\"\") Content type Payment toke To and from timestamps An onSearch() function is also included, which is triggered when a search operation is initiated by the user clicking Search. All of these values are passed to Navbar from page.tsx, ensuring state is shared between all components. interface NavbarProps {irysNetwork: string;setIrysNetwork: React.Dispatch>;contentType: string;setContentType: React.Dispatch>;paymentToken: string;setPaymentToken: React.Dispatch>;fromTimestamp: Date | null;setFromTimestamp: React.Dispatch>;toTimestamp: Date | null;setToTimestamp: React.Dispatch>;onSearch: () => void; } Next, build a custom React hook called useNavbar() that handles all the state setting for the component. cconst useNavbar = ({ props }: { props: NavbarProps }) => {const handleIrysNetworkChange = (e: React.ChangeEvent) => {props.setIrysNetwork(e.target.value);};const handleContentTypeChange = (e: React.ChangeEvent) => {props.setContentType(e.target.value);};const handlePaymentTokenChange = (e: React.ChangeEvent) => {props.setPaymentToken(e.target.value);};const handleFromTimestampChange = (e: React.ChangeEvent) => {props.setFromTimestamp(e.target.value ? new Date(e.target.value) : null);};const handleToTimestampChange = (e: React.ChangeEvent) => {props.setToTimestamp(e.target.value ? new Date(e.target.value) : null);};return {handleIrysNetworkChange,handleContentTypeChange,handlePaymentTokenChange,handleFromTimestampChange,handleToTimestampChange,}; }; Now, combine the state management logic with some basic HTML, and you’ve got your Navbar UI. Create a new file called Navbar.tsx and paste in the following. interface NavbarProps {irysNetwork: string;setIrysNetwork: React.Dispatch>;contentType: string;setContentType: React.Dispatch>;paymentToken: string;setPaymentToken: React.Dispatch>;fromTimestamp: Date | null;setFromTimestamp: React.Dispatch>;toTimestamp: Date | null;setToTimestamp: React.Dispatch>;onSearch: () => void; } const useNavbar = ({ props }: { props: NavbarProps }) => {const handleIrysNetworkChange = (e: React.ChangeEvent) => {props.setIrysNetwork(e.target.value);};const handleContentTypeChange = (e: React.ChangeEvent) => {props.setContentType(e.target.value);};const handlePaymentTokenChange = (e: React.ChangeEvent) => {props.setPaymentToken(e.target.value);};const handleFromTimestampChange = (e: React.ChangeEvent) => {props.setFromTimestamp(e.target.value ? new Date(e.target.value) : null);};const handleToTimestampChange = (e: React.ChangeEvent) => {props.setToTimestamp(e.target.value ? new Date(e.target.value) : null);};return {handleIrysNetworkChange,handleContentTypeChange,handlePaymentTokenChange,handleFromTimestampChange,handleToTimestampChange,}; }; const Navbar: React.FC = (props) => {const {handleIrysNetworkChange,handleContentTypeChange,handlePaymentTokenChange,handleFromTimestampChange,handleToTimestampChange,} = useNavbar({ props });return (Irys NodemainnetdevnetContent-TypeNoneimage/jpgimage/pngimage/gifPayment TokenNoneSolanaMaticEthereumArweaveFrom TimestampTo TimestampSearch); }; export default Navbar;SearchResults The SearchResults component is a simple container that fills the bottom part of the search. It first defines two interfaces that model the results of a search. // Defines the shape of a search result interface SearchResult {txID: string;creationDate: string;token: string;tags: any[]; } // Defines the properties of the SearchResults component interface SearchResultsProps {results: SearchResult[]; // array of search results } It then iterates over these values, and uses them to dynamically build an array of SearchResultsItems components. Create a new file titled SearchResults.tsx and paste in the following. // Defines the shape of a search result interface SearchResult {txID: string;creationDate: string;token: string;tags: any[]; } // Defines the properties of the SearchResults component interface SearchResultsProps {results: SearchResult[]; // array of search results } // Functional component that receives an array of SearchResult items const SearchResults: React.FC = ({ results }) => {return ({// For each result, render a SearchResultsItem componentresults &&results.map((result) => ())}); }; export default SearchResults;SearchResultsItemThe SearchResultsItem component models a single search result, you’ll instantiate a new one for each result found. Start by modeling the data that will be shown in the component. // Describes the structure of a metadata tag export interface Tag {name: string;value: string; } // Defines the properties of the SearchResultsItem component interface SearchResultsItemProps {txID: string; // Transaction IDcreationDate: string; // Date of transaction creationtoken: string; // Token used for paymenttags: Tag[]; // Array of Tags } And then combine it with some basic styling to complete the component. // Describes the structure of a metadata tag export interface Tag {name: string;value: string; } // Defines the properties of the SearchResultsItem component interface SearchResultsItemProps {txID: string; // Transaction IDcreationDate: string; // Date of transaction creationtoken: string; // Token used for paymenttags: Tag[]; // Array of Tags } // Functional component that displays information for an individual search result const SearchResultsItem: React.FC = ({ txID, creationDate, token, tags }) => {return ({/* Display thumbnail image */}{/* Display truncated Transaction ID */}Tx ID: {txID.slice(0, 5).concat(\"\".....\"\", txID.slice(-5))}{/* Display creation date */}Creation Date: {creationDate}{/* Display token info */}Token: {toTitleCase(token)}{/* List all associated tags */}{tags.map((tag: Tag, i: number) => ({tag.name}: {tag.value.length > 10 ? tag.value.substring(0, 10) + \"\"...\"\" : tag.value}))}); }; export default SearchResultsItem;utils Ok, you are almost done, let’s create one quick utility function. Create a new folder called utils and in it a file called titleCase.tsx. Paste in the following code we’ll use to properly format text in SearchResultsItem. This function accepts any string and returns it properly formatted using title case, the first letter is capitalized while the others are in lowercase. const toTitleCase = (str: string): string => {return str.replace(/\\w\\S*/g, (txt: string): string => {return txt.charAt(0).toLocaleUpperCase() + txt.substr(1).toLocaleLowerCase();}); }; export default toTitleCase;Query Functionality Having assembled the application's UI, running npm run dev in your CLI now displays a functional UI with a Navbar and a designated area for search results. However, the \"\"Search\"\" button doesn’t do anything as we have yet to build out the handleSearch() function. Let’s jump back to page.tsx and finish coding the handleSearch() function. Irys has a mainnet and devnet. When querying, // Create a new Query object pointing to the node selected by the user const query = new Query({ network: irysNetwork }); Moving forward, the Query object is configured to exclusively search Irys' transactions and limit the results to 42. The location of the search is determined by the value passed to search(), if you’re modifying this tutorial to search Arweave instead, you would change this value. Although this tutorial limits results to 42 for simplicity, implementing streaming would enable a continuously expanding page of results triggered by user scroll. const myQuery = query.search(\"\"irys:transactions\"\").limit(42); Next up is where the meat of the query happens. Using the tags(), currency(), fromTimestamp() and toTimestamp() functions, we programmatically set query parameters. // Set query params based on input in NavBar if (contentType !== \"\"None\"\") myQuery.tags([{ name: \"\"Content-Type\"\", values: [contentType] }]); if (paymentToken !== \"\"None\"\") myQuery.currency(paymentToken.toLowerCase()); if (fromTimestamp) myQuery.fromTimestamp(fromTimestamp); if (toTimestamp) myQuery.toTimestamp(toTimestamp); And finally, we execute the query by calling it with the await keyword. // Having configured the query, call await on it to execute const results = await myQuery; Here’s the full handleSearch() function, go back to your page.tsx file and paste this function on top of the existing empty function signature. // Called when a user clicks \"\"Search\"\" in the UI const handleSearch = async () => {// Show the LoadingSpinnersetIsLoading(true);setFirstSearchRun(true);// Clear the previous search results (if exists)setSearchResults([]);// Create a new Query object pointing to the node selected by the userconst query = new Query({ url: irysNode + \"\"/graphql\"\" });// Create a new query pointing to Irys, limit results to 42// for purposes of this tutorial, but feel free to change.const myQuery = query.search(\"\"irys:transactions\"\").limit(42);// Set query params based on input in NavBarif (contentType !== \"\"None\"\") myQuery.tags([{ name: \"\"Content-Type\"\", values: [contentType] }]);if (paymentToken !== \"\"None\"\") myQuery.currency(paymentToken.toLowerCase());if (fromTimestamp) myQuery.fromTimestamp(fromTimestamp);if (toTimestamp) myQuery.toTimestamp(toTimestamp);// Having configured the query, call await on it to executeconst results = await myQuery;// Iterate over the search results, adding each to an array of SearchResultconst resultsBuilder: SearchResult[] = [];for (const result of results) {const newEntry: SearchResult = {txID: result.id,creationDate: new Date(result.timestamp).toLocaleString(),token: result.currency,tags: result.tags,};resultsBuilder.push(newEntry);}// Store SearchResult array in statesetSearchResults(resultsBuilder);// Turn of the LoadingSpinnersetIsLoading(false); };What’s Next? Excellent job! In under an hour, you've constructed an explorer that showcases content uploaded to Irys in real time. The flexibility of the Query pacakge opens a world of opportunities for creative Web3 development. You could expand on this tutorial to allow more advanced tag searching or even repurpose it to query Arweave directly instead. When uploading to Irys, you have complete freedom over which tags you add to each transaction. Using custom tags you can build semi-relational models within your data and then use these models to construct complex queries, analyze data patterns, or create personalized user experiences. What are you going to build? LFB!",
  "origin": "docs"
},{
  "url": "/hands-on/tutorials/irys-sdk",
  "title": "Irys SDK tutorial",
  "description": "Everything you need to start building with Irys + NodeJS",
  "text": "Irys SDK tutorialIn this tutorial you will learn how to use Irys with NodeJS to permanently store data with strong provenance using a few lines of code.Prerequisites To use this tutorial, you will need: A crypto wallet with a small amount of Devnet tokens A recent version of NodeJS A code editor (VSCode or others)Installing First, make sure you have Node installed: node -v If you get a version number like \"\"v16.14.0\"\" back, you’re good to go. Otherwise, install Node. Next, create a new directory and cd into it. mkdir irys-basics cd irys-basics And then install the SDK using npm: npm install @irys/sdk or using yarn: yarn add @irys/sdk When you use npm or yarn to install the SDK, it will create a file titled package.json in your root directory. Open up that file and add \"\"type\"\" : \"\"module\"\" to the beginning, allowing you to use ES6 module imports. Finally, run the following in your command prompt to create a new JavaScript file, then fire up your code editor of choice. touch irys-basics.jsdotenv Install the free dotenv package. We will store our private key in a .env file and access it using the dotenv package. npm install dotenv Now create a file called .env in your main directory: touch .env And edit it to contain the private key of a wallet file that has been funded with free MUMBAI MATIC. ETHPRIVATEKEY=__Connecting to Irys Start by connecting to Irys. In this example, we connect to the Irys devnet, which also requires you to pass an RPC URL. When connecting to Irys' mainnet, you don't need to supply an RPC address. const getIrys = async () => {const network = \"\"devnet\"\";// Devnet RPC URLs change often, use a recent one from https://chainlist.org/const providerUrl = \"\"\"\";const token = \"\"matic\"\";const irys = new Irys({network, // \"\"mainnet\"\" || \"\"devnet\"\"token, // Token used for paymentkey: process.env.ETHPRIVATEKEY, // Private keyconfig: { providerUrl }, // Optional provider URL, only required when using Devnet});return irys;console.log(wallet address = ${irys.address}); }; await getIrys(); Paste the above code into the irys-basics.js file you created and then run it by typing:node irys-basics.js from your CLI, if it successfully prints your wallet address, you’re good to go.Funding a node To fund a node, pass the amount you want to fund in atomic units. Assuming you setup Irys to use Mumbai Matic, the following will fund 0.5 MATIC: const fundNode = async () => {const irys = await getIrys();try {const fundTx = await irys.fund(irys.utils.toAtomic(0.5));console.log(Successfully funded ${irys.utils.fromAtomic(fundTx.quantity)} ${irys.token});} catch (e) {console.log(\"\"Error uploading data \"\", e);} }; await fundNode(); Paste the above code into irys-basics.js and run as you did before.Checking upload price You can check the cost to upload data by passing a number of bytes to the function irys.getPrice(). This code checks the cost to upload 1 Megabyte (1048576 bytes). const checkPrice = async () => {const irys = await getIrys();const numBytes = 1048576; // Number of bytes to checkconst priceAtomic = await irys.getPrice(numBytes);// Convert from atomic units to standard unitsconst priceConverted = irys.utils.fromAtomic(numBytes);console.log(Uploading ${numBytes} bytes costs ${priceConverted}); }; await checkPrice();Uploading data If it can be reduced to 1s and 0s, it can be uploaded to Arweave via Irys using the function irys.upload(), as with this example that uploads the string \"\"GM world.\"\" const uploadData = async () => {const irys = await getIrys();const dataToUpload = \"\"GM world.\"\";try {const receipt = await irys.upload(dataToUpload);console.log(Data uploaded ==> https://gateway.irys.xyz/${receipt.id});} catch (e) {console.log(\"\"Error uploading data \"\", e);} }; await uploadData();Uploading a file You can upload a file by passing its name to the function irys.uploadFile(). To run this code, find a PNG file on your local drive, rename it to myImage.png and place it in the same directory as the irys-basics.js file. const uploadFile = async () => {const irys = await getIrys();// Your fileconst fileToUpload = \"\"./myImage.png\"\";const tags = [{ name: \"\"application-id\"\", value: \"\"MyNFTDrop\"\" }];try {const receipt = await irys.uploadFile(fileToUpload, { tags: tags });console.log(File uploaded ==> https://gateway.irys.xyz/${receipt.id});} catch (e) {console.log(\"\"Error uploading file \"\", e);} }; await uploadFile();Uploading a folder You can also upload an entire folder of images with a single line of code. To run this example, create a directory in the same folder as irys-basics.js and fill it with image files. const uploadFolder = async () => {const irys = await getIrys();// Upload an entire folderconst folderToUpload = \"\"./my-images/\"\"; // Path to foldertry {const receipt = await irys.uploadFolder(\"\"./\"\" + folderToUpload, {indexFile: \"\"\"\", // optional index file (file the user will load when accessing the manifest)batchSize: 50, //number of items to upload at oncekeepDeleted: false, // whether to keep now deleted items from previous uploads}); //returns the manifest IDconsole.log(Files uploaded. Manifest Id ${receipt.id});} catch (e) {console.log(\"\"Error uploading file \"\", e);} }; await uploadFolder(); Files uploaded via irys.uploadFolder(folderToUpload) can be retrieved in one of two ways. Creating a URL with the format https://gateway.irys.xyz/[manifest-id]/[original-file-name]. Creating a URL using the transaction ID of each individual file uploaded with the format https://gateway.irys.xyz/[transacton-id] After a successful folder upload, two files are written to your local project directory [folder-name].csv and [folder-name].json. The example below highlights a folder called “llama_folder” with a total of 5 files in it. The transaction id for each file can be used to retrieve the uploaded data by forming a URL with the format https://gateway.irys.xyz]/[transaction-id] Uploading a static website You can also use the SDK to uplaod an entire static website to the permaweb.Getting help If you get stuck or need help, reach out in our Discord and someone will get back to you quickly. And, most importantly pleaase let us know how you're using Irys and what you're building. Let us know how we can best support you!",
  "origin": "docs"
},{
  "url": "/hands-on/tutorials/lens",
  "title": "Storing Lens metadata on Irys",
  "description": "Uploading Lens metadata using Irys",
  "text": "Storing Lens metadata on Irys In this tutorial, you will learn how to use Irys with the Lens React hooks to upload post metadata. Lens Protocol is a composable and decentralized social graph; it allows you to quickly create social applications without having to build your own backend services.React hooks The React hooks for Lens make client-side development easier as they streamline much of the development, including generating correct metadata for you to upload.upload() pattern When working with hooks like useUpdateProfileDetails() and useCreatePost(), Lens works using a pattern where you define a function called upload() that matches the following signature. export const upload = (data: unknown): Promise => {const serialized = JSON.stringify(data);const url = // upload serialized to a public locationreturn url; } The upload() function is passed to the hooks on initialization, the hooks then prepare the required metadata and pass it to upload() in the data parameter. When implementing the function, it's up to you to serialize the metadata (JSON object), store it on Irys and then return the URL from the function. The hook then takes the URL to the uploaded metadata and continues using it to update profile details or create a new post. A full ready-to-use implementation of the upload() function is as follows: const getIrys = async () => {await window.ethereum.enable();const provider = new providers.Web3Provider(window.ethereum);const wallet = { name: \"\"ethersv5\"\", provider: provider };const network = \"\"mainnet\"\"; // Or \"\"devnet\"\"const token = \"\"matic\"\";const webIrys = new WebIrys({ network, token, wallet });await webIrys.ready();return webIrys; }; export const upload = async (data) => {try {const irys = await getIrys();const serialized = JSON.stringify(data);// fund (if needed)const price = await irys.getPrice(new Blob([serialized]).size);await irys.fund(price);const tx = await irys.upload(serialized, {tags: [{ name: \"\"Content-Type\"\", value: \"\"application/json\"\" }],});console.log(Upload success content URL= https://gateway.irys.xyz/${tx.id});return https://gateway.irys.xyz/${tx.id};} catch (e) {console.log(\"\"error on upload \"\", e);}return \"\"\"\"; };If you incorrectly set the Content-Type attribute, Lens will not read your data. ",
  "origin": "docs"
},{
  "url": "/hands-on/tutorials/livepeer",
  "title": "Using Livepeer to transcode video",
  "description": "Using Livepeer to transcode video stored on Arweave",
  "text": "Using Livepeer to transcode video Livepeer is a decentralized video protocol for transcoding video content. For projects involving both live and recorded video, Livepeer combined with Irys allows you to optimize video delivery for each unique client.Transcoding Transcoding is the process of converting between video file format types. When streaming video, it's important as it allows you to optimize video delivery based on factors such as a client's device size, preferences and the quality of their internet connection. This allows you to upload a high-resolution 4K video file, and then deliver formats optimized for TV streaming, tablets and mobile. You can even allow clients to specify lower-quality formats to help economize bandwidth charges.Setup To get started, you'll need to create an API key first. If you're working with React, you can install the Livepeer React SDK with: npm @livepeer/reactTranscoding a video stored on Arweave Video files can be uploaded to Arweave via Irys using our CLI, or SDK. Using the ` tag from the Livepeer SDK you can embed an Arweave URL, the URL format can be either ar://aqvPKxi-EDcmAHPAPpDcaYyGekp-06T16ElvNTnJNk or https://gateway.irys.xyz/aqvPKxi-EDcmAHPAPpDcaYyGekp-06T16ElvNTnJNk`. The first time Livepeer encounters the URL it will transcode the file, the transcoded versions are then stored in an account tied to your API key. Transcoded files are kept for as long as your account is active.In order to properly transcode your video, the ` component must have access to a Livepeer client that contains a valid API key. Best practice is to use the provider pattern and the ` component. For example, to make the client available to all child components in your app, you would structure your index.js file as follows. const livepeerClient = createReactClient({provider: studioProvider({apiKey: process.env.LIVEPEERAPIKEY,}), }); const root = ReactDOM.createRoot(document.getElementById(\"\"root\"\")); root.render(, ); `",
  "origin": "docs"
},{
  "url": "/hands-on/tutorials/metaplex",
  "title": "Build a Solana NFT marketplace with Metaplex",
  "description": "Build a Solana NFT Marketplace With Metaplex",
  "text": "Build a Solana NFT marketplace with Metaplex In this tutorial, you will learn everything you need to know to launch your own NFT collection on Solana using Metaplex. You will use Metaplex’s tools to upload your NFTs to Irys before setting them up to mint on Solana, finally, you will build a full website your community can use to mint your creations.We'll be using NextJS, TypeScript, and Tailwind for this tutorial. A basic understanding of each is essential, but you don't need to be an expert. If you're familiar with JavaScript but new to TypeScript, don’t worry, you’ll be fine. Also, you should have a basic knowledge of Github, enough to handle tasks like cloning a repository.Prerequisites To complete this tutorial you will need: A recent version of Node A code editor (I use VSCode, but use whatever you prefer) A Solana wallet (I use Phantom, but others are fine) Some Devnet (not Testnet) Solana tokens, available for free from a faucetMetaplex Metaplex offers a full suite of tools that simplify creating and minting NFTs on Solana. In this tutorial you will work with: Sugar: A CLI for uploading NFT images and metadata Umi: A modular framework for building and using JavaScript that interacts with Solana Candy Machine: A minting and distribution program for NFT collections on SolanaSetupTutorial repository To help you get going quickly and let you focus on learning how to use Metaplex with Irys, I created a Github repository with some artwork you can use for your NFTs. Additionally, I created a framework UI for the minting website. Start by cloning this repository. At the top-level are two folders, one called NFTs that contains 20 PNGs we'll turn into NFTs, and a second one called mint-storefront that contains the NextJS project representing the UI for the minting website. Solana CLI Start by installing the Solana CLI. Follow these instructions and then return to this tutorial. If you are not sure if you have already installed the CLI, you can try running: solana --version As new versions of the CLI are constantly being released, it’s recommended you update before continuing: solana-install update Next setup a Solana Devnet wallet: solana-keygen new --outfile ~/.config/solana/devnet.json The results of that command will look something like this: Wrote new keypair to /Users/luke/.config/solana/devnet.json pubkey: 69Z4dXS8aAvDhP4QDRs5C2LePnpYApZX8rvnZ69r6ic1 Save this seed phrase and your BIP39 passphrase to recover your new keypair: trend own mixture your spike keys elite run coins not lyrics fadeWithin the results is a 12-word keyphrase that can be used to access your wallet, if you share this information withanyone they can access your funds. I decided to show mine to make this tutorial easy to follow, however, I only usedthe wallet while writing this tutorial.Now switch to the Solana Devnet: solana config set -u devnet And fund your wallet with free Devnet faucet tokens: solana airdrop 2The airdrop command is sometimes unreliable. If you have trouble funding your wallet, you may need to use the [SolanaFaucet](https://solfaucet.com/). Be sure to request Devnet tokens and not Testnet tokens. You can find your walletaddress using the command solana address.You can test that you have a balance using: solana balanceSugar You’ll use Metaplex’s Sugar to upload your NFT assets. Start by installing the Sugar CLI with the following command, when prompted, choose the latest version. bash[resize] Here's a breakdown of each command line argument: folder_path: The path to the directory where your images are stored. file_extension: This should be either \"\"png\"\" or \"\"jpg\"\", depending on the format of the images you're working with. name: The base name for your NFTs. For images not named \"\"collection\"\", a number will be appended (e.g., \"\"Space Llamas #1\"\"). symbol: A short representation of your NFT's name, such as \"\"SPL\"\". description: A brief description of your NFT collection. [resize]: If you provide \"\"resize\"\" as the sixth argument, the script will resize each image to 800x800 pixels. If you don’t have the open-source ImageMagick library installed, you will be prompted to install it. (optional) After running the script, your images and corresponding JSON metadata files will be properly organized and prepared for uploading with Sugar. The original files are copied to an originals subfolder, which can be deleted if you no longer want them. Name your collection anything you want, I named my collection Space Llamas and preapred them using this command: ./prepare-imges.sh assets png \"\"Space Llamas\"\" \"\"SPL\"\" \"\"These llamas are going to the moon\"\" resizeUploading with Sugar Now that your images are ready to go, you’ll use Metaplex’s Sugar CLI to upload them to Irys. Again, make sure you’re in the NFTs directory, and start by creating a sugar config file: sugar config create You’ll be prompted with a series of questions. In the first one, if Sugar reports finding the correct number of files, press y. If you’re working with my sample images you should have 20 file pairs: Found 20 file pairs in \"\"assets\"\". Is this how many NFTs you will have in your candy machine? Next, you’ll need to confirm the symbol used for your collection, press y to confirm: Found symbol \"\"SPL\"\" in your metadata file. Is this value correct? Next, you’ll need to confirm the royalty you want to charge on secondary sales. The number is supplied in basis points, which are percentage times 100. To charge a 5% royalty, enter 500: What is the seller fee basis points? Next, decide how you want to manage index generation. Candy Machine supports sequential and random mint indexes. In most cases, you will want to choose n here so that the random mint index makes it harder for botters to snipe specific NFTs: Do you want to use a sequential mint index generation? We recommend you choose no. Each NFT collection can have a max of 4 creator wallets that payments are automatically split between, for this tutorial just choose 1: How many creator wallets do you have? (max limit of 4) › Enter your wallet address (you can find the wallet address you created earlier by entering solana address from a new command prompt): Enter creator wallet address #1 › Finally, assign 100% of revenue to that wallet: Enter royalty percentage share for creator #1 (e.g., 70). Total shares must add to 100. › When prompted to add extra features, just press the enter to skip: Which extra features do you want to use? (use [SPACEBAR] to select options you want and hit [ENTER] when done) › Metaplex uses a Solana program (equivalent of a smart contract on Ethereum) to track ownership of NFTs and gives users options about where to store the NFT assets. For your NFT to be permanent, it must be fault-tolerant, tamperproof, and paid-for: Fault-tolerant:This means that the data is stored so that it can survive unexpected events, including data corruption and loss. Tamperproof:The stored data is immutable so it can’t be maliciously changed. Paid-for:This means that the cost of storing the data permanently is covered up-front, and there is a mechanism for paying miners on an acceptable cadence. This provides strong incentives for storing the data forever. Arweave is all of these things, and by using Irys to upload your NFTs to Arweave, you’re guaranteed they will be available forever. Not all of the upload options supported by Sugar offer these same guarantees of permanence, which is why we recommend always choosing Irys to upload.Irys was previously named Bundlr. At the time this tutorial was released,the Metaplex tools still refer to us by our old name. When uploading with sugar, you can choose either Bundlr or Irys,your NFTs will still be uploaded and permanently stored on Arweave.? What upload method do you want to use? › ❯ Bundlr AWS NFT Storage SHDW Pinata Select y again to make your NFTs mutable: Do you want your NFTs to remain mutable? We HIGHLY recommend you choose yes. After the process completes, you'll see two new files in your local directory. cache.json: Lists each NFT, including links to where your images and metadata are stored on Arweave. config.json: Contains information describing your project setup. You will need to manually modify this file to set the mint price for each NFT. Now find this section:\"\"guards\"\": null, And replace it with the following. Make sure to change the value for the destination field to the wallet address you created earlier. If you forget the value, just enter solana address from the command line. \"\"guards\"\": {\"\"default\"\": {\"\"solPayment\"\": {\"\"value\"\": 0.1,\"\"destination\"\": \"\"69Z4dXS8aAvDhP4QDRs5C2LePnpYApZX8rvnZ69r6ic1\"\"}} }, I've used a price of 0.1 SOL, but you can change as you want. Just be careful, don't make the price too high, you'll use Devnet SOL in your wallet to test minting. If the mint price is too high, you'll need to go back to the faucet often to get more funds. After modifying the file, run this command to update your configuration: sugar guard add And finalize your upload: sugar uploadIrys supports payment with most popular tokens, when using the Metaplex tools the walletyou previously set up will be automatically debited with SOL to cover the costs. You should already have Devnet SOL,which is all you’ll need now. If you decide to launch your collection on Mainnet later, ensure your wallet hassufficient Mainnet SOL first.Create and deploy a candy machine: sugar deploy And verify successful deployment: sugar verifyBuilding the marketplace Your NFTs are now uploaded to Irys and prepared to be minted on Solana. The last Metaplex tool we’ll use is Candy Machine, which handles the minting and distribution of your NFTs. If you again look at the cache.json file that was generated by Sugar when uploading, you’ll notice this section at the top. \"\"program\"\": {\"\"candyMachine\"\": \"\"CUSxUaAHZrNcuqpt1vTcpSkyAJaqHptrSLiiBAKmLFsz\"\",\"\"candyGuard\"\": \"\"Bjwk3LvE4FHbrV5wtkAn5Au1umBAxmVFwp8Rd6aTrtgW\"\",\"\"candyMachineCreator\"\": \"\"8GfTtubZ8K1q4UJBp1L5ZeahazQQSpdMjB8Gco6Xixvd\"\",\"\"collectionMint\"\": \"\"7K3zV7mS3XMGi7vQhwQzXnuvQDF4r56mqx7PVupntmUV\"\" }, This indicates that a Candy Machine instance has already been set up for your project. Note the value of the candyMachine property, you’ll need that soon.Folder structure Within the GitHub repository you downloaded, there is a subdirectory called mint-storefront. cd into this directory and take a look at the folder structure. As this tutorial focuses on building with Metaplex, I created a UI framework so we don’t have to spend time covering the basics of how to use NextJS and Tailwind. The NextJS project has been set up for you and the UI framework is there. Return to your terminal and from the mint-storefront directory run: npm install And then npm run dev If you open up http://localhost:3000/ in your browser, you’ll see the beginning of the UI. The top nav is there, but the buttons don’t work yet, and the bottom preview area is empty.Take a moment to look through the code, both the UI components in the components folder and the utility functions in the utils folder. Focus specifically on the components highlighted in the image below, that’s where you’re going to be all of your building. .env.local Inside the mint-storefront directory, look for a file called .env.local.example and rename it to .env.local. The file contains two fields: NEXTPUBLICRPC_URL: is where you can put a custom Solana RPC, like the fast ones from Helius. This parameter is optional, if left blank, the code will revert to using the free shared endpoints. NEXTPUBLICCANDY_MACHINE: is where you should put the value of the candyMachine field from the cache.json file generated by Sugar earlier. After renaming this file and configuring the file, restart your NextJS server for them to take effect. NEXTPUBLICRPC_URL= NEXTPUBLICCANDY_MACHINE= There are two features we need to implement in for our NFT Marketplace to be complete. Previewing NFTs Minting NFTsPreviewing NFTs: utils/loadNFTs.ts & components/NFTs Previewing NFTs is managed by a utility function called utils/loadNFTs.ts, and a UI component called components/NFTs. The NFTs component covers the whole bottom part of the screen, and then inside that, we’ll render each individual NFT using the NFT component. Start with the file utils/loadNFTs.ts, inside it you’ll notice an empty function called loadNFTs(). /**Loads preview images of all NFTs in the collection*/ export const loadNFTs = async (): Promise => {}; The purpose of this function is to load preview images of all NFTs in our collection. To complete the function, type in the following lines between the main curly braces of the function. const umi = createUmi(process.env.NEXTPUBLICRPC_URL || \"\"https://api.devnet.solana.com\"\"); const candyMachine = await fetchCandyMachine(umi, process.env.NEXTPUBLICCANDY_MACHINE || \"\"\"\"); const arrayBuilder: string[] = []; for (let i = 0; i{}, []); const doLoadNFTs = async () => {}; In Next / React projects, the useEffect() function is called when a component loads. Add a single line to this function calling doLoadNFTs(), and then inside doLoadNFTs() add one line of code where you call our loadNFTs() utility function. Take the results of this and set it as React state variable called nftMetadata. Your completed code should look like this. useEffect(() => {doLoadNFTs(); }, []); const doLoadNFTs = async () => {setNftMetadata(await loadNFTs()); }; Return to http://localhost:3000/ and you should see all 20 of your NFTs previewed.Minting NFTs: utils/doMint.ts & components/MintButton The final step before launching our NFT Marketplace is finalizing the mint function. With Candy Machine, the minting process has an element of surprise. Users can't select a specific NFT; they receive them in sequence. Often, NFT creators make some pieces rarer than others. Since users can't choose which one they’re minting, some may mint multiple times, hoping for a rarer NFT with a higher resale value. Again starting with `utils/doMint.ts, you’ll notice an empty function. /**Mints a random NFT from the collection owned by the*/ export const doMint = async (wallet: WalletAdapter) => {}; Replace it with this. You’ll notice it starts out similar to loadNFTs() in that it gets a reference to UMI and CandyMachine objects, but this time it goes further and executes a transaction instead of simply reading data. export const doMint = async (wallet: WalletAdapter) => {// Get a reference to the UMI object, our conduit to the Solana blockchainconst umi = createUmi(process.env.NEXTPUBLICRPC_URL || \"\"https://api.devnet.solana.com\"\").use(mplCandyMachine());umi.use(walletAdapterIdentity(wallet));// Get a reference to our collection's unique Candy Machineconst candyMachinePublicKey = publicKey(process.env.NEXTPUBLICCANDY_MACHINE || \"\"\"\");// Get a reference to the transaction signerconst collectionUpdateAuthority = generateSigner(umi);const candyMachine = await fetchCandyMachine(umi, candyMachinePublicKey);const nftMint = generateSigner(umi);// Get a reference to the collection's metadataconst nftMetadata = await fetchMetadataFromSeeds(umi, { mint: candyMachine.collectionMint });// Build and execute the mint functionawait transactionBuilder().add(setComputeUnitLimit(umi, { units: 800_000 })).add(mintV2(umi, {candyMachine: candyMachine.publicKey,candyGuard: candyMachine.mintAuthority,nftMint,collectionMint: candyMachine.collectionMint,collectionUpdateAuthority: nftMetadata.updateAuthority,tokenStandard: candyMachine.tokenStandard,mintArgs: {solPayment: { destination: candyMachine.authority },},}),).sendAndConfirm(umi); }; Just one last piece and you’re done. Open up components/MintButton and look for this empty function. const mintNFT = async () => {}; And then type in this. The function does very little other than set a few state variables and call our doMint() function. const mintNFT = async () => {// Set isLoading state variable to true// We use this to disable the button and show a spinner insteadsetIsLoading(true);try {// Execute our doMint function passing in the user's wallet (for signing)await doMint(wallet);// Set a state variable used to show confettisetShowConfetti(true);// Show a confirmation messagesetMessage(\"\"NFT minted, check your wallet!\"\");} catch (e) {setMessage(\"\"Error minting NFT: \"\" + e);}// Set isLoading state variable back to false to re-enable// the mint button and hide the spinnersetIsLoading(false); };Testing The App If you did everything correctly, your NFT Marketplace should now be fully functional. Make sure you’ve installed the Phantom wallet and funded it with Devnet Solana. Then, return to your browser, click Select Wallet button to connect your wallet, and the Mint Random NFT button to mint an NFT.Once the confetti rains down and you see a success message, reach up and check your Phantom wallet. If everything worked properly you should see the NFTs in your wallet. It will look something like this. Troubleshooting If things didn’t work, again return to your code and make sure you typed everything in correctly. If you’re still stuck though, jump on over to the Irys Discord and someone will help you debug it.Extending Candy Machine with Guards The purpose of this tutorial was to introduce the fundamentals of creating a Solana NFT marketplace using Metaplex and Irys. While this guide offers a foundational understanding, it doesn't cover all of Metaplex's features. For example, instead of using the Sugar CLI, you can instead set up your collection using their JS SDK. One feature you will likely want to take advantage of to customize your collection is guards, a modular piece of code that can restrict access to the mint of a Candy Machine and add new features to it. With a variety of guards available, each can be tailored and activated as desired. While I didn’t call it out at the time, when you added a mint price of 0.1 SOL to your collection, you were configuring a guard. For a deeper dive into guards, refer to the official documentation. Some noteworthy guards include: Start Date/End Date guards: Limits minting within a specific timeframe. Token Gate/NFT Gate guards: Allows minting only for select token or NFT holders. Allow List guard: Limits minting to a specified wallet list.Thank you! When you’re done, make sure to share some screenshots on X (Twitter) and tag us at @irys_xyz and the team at @metaplex. LFB frens!",
  "origin": "docs"
},{
  "url": "/hands-on/tutorials/monitor-node-balance",
  "title": "Monitor Node Balance With A Script",
  "description": "Monitor your node balance using JavaScript, our CLI, or cURL",
  "text": "Monitor Node Balance With A Script Irys' upfront funding simplifies the uploading process by allowing you to pre-fund your uploads. This eliminates the need for individual funding calls for each upload as the loaded balance is automatically deducted from with each upload. To keep track of your loaded balance, users commonly create scripts that periodically check their balance and provide notifications when it approaches zero. This tutorial offers examples of how to monitor your balance using JavaScript, our Command Line Interface (CLI), and cURL. These techniques are all equally effective options for balance monitoring, choose the method that aligns with your unique architecture and requirements.JavaScript dotenv.config(); const getIrys = async () => {const network = \"\"devnet\"\";// Devnet RPC URLs change often, use a recent one from https://chainlist.org/const providerUrl = \"\"\"\";const token = \"\"matic\"\";const irys = new Irys({network, // \"\"mainnet\"\" || \"\"devnet\"\"token, // Token used for paymentkey: process.env.PRIVATE_KEY, // ETH or SOL private keyconfig: { providerUrl }, // Optional provider URL, only required when using Devnet});return irys; }; const checkBalance = async () => {const irys = await getIrys();// Get loaded balance in atomic unitsconst atomicBalance = await irys.getLoadedBalance();// Convert balance to standard unitsconst convertedBalance = irys.utils.fromAtomic(atomicBalance);return convertedBalance; }; const checkAndPrintBalance = async () => {const balance = await checkBalance();const threshold = 0.1; // 10% thresholdif (Math.abs(balance) /account/balance/?address=. For example to check the Devnet MATIC balance of the wallet with address 0xaC568a981B1370B2e1bAA8cE30BD5AC9E28C572D`, you would use the command https://arweave.devnet.irys.xyz/account/balance/matic?address=0xaC568a981B1370B2e1bAA8cE30BD5AC9E28C572D Just as with our CLI, you don’t need to provide your private key. This version is also more streamlined than the CLI version as you don’t need to include the provider URL when checking the Devnet balances. #!/bin/bashDefine your variables address=\"\"0xaC568a981B1370B2e1bAA8cE30BD5AC9E28C572D\"\" # Public wallet address node_address=\"\"https://arweave.devnet.irys.xyz\"\" token=\"\"token\"\" balance_output=\"\"\"\";Create the API endpoint URL balancecheckurl=\"\"${node_address}/account/balance/${token}?address=${address}\"\"Make the cURL request and capture the response balanceoutput=$(curl -s \"\"$balancecheck_url\"\")Parse the balance from the response using awk parsedbalance=$(echo \"\"$balanceoutput\"\" | awk -F'\"\"' '{print $4}')Define the decimal factor for conversion (this works for MATIC and others with 18 decimals) decimal_factor=1000000000000000000For Solana currencies with 9 decimals, use decimalfactor=1000000000Convert parsedbalance to standard units balanceinstandardunits=$(awk -v parsedbalance=\"\"$parsedbalance\"\" -v decimalfactor=\"\"$decimalfactor\"\" 'BEGIN{printf \"\"%.18f\"\", parsedbalance/decimal_factor}')Define your threshold in standard units threshold=0.1Check if balanceinstandard_units is within a threshold of 0 isclosetozero=$(awk -v balance=\"\"$balanceinstandardunits\"\" -v threshold=\"\"$threshold\"\" 'BEGIN{if(balance < threshold) print 1; else print 0}') if [ $iscloseto_zero -eq 1 ]; thenecho \"\"Balance ${balanceinstandard_units} is within $(echo \"\"$threshold*100\"\" | bc -l)% of 0, please fund.\"\" elseecho \"\"Balance ${balanceinstandard_units} funding not yet needed\"\" fi To run a bash script periodically, use cron. Assuming you saved the above script as a file checkBalance.sh, open up your crontab file using crontab -e and then add an entry to call the script periodically. To call it every 30 minutes, you’d add the following: /30* * * /path/to/your/script/checkBalance.sh",
  "origin": "docs"
},{
  "url": "/hands-on/tutorials/react",
  "title": "Using Irys With npx create-react-app",
  "description": "Using the Irys SDK with create-react-app.",
  "text": "Using Irys With npx create-react-appIf you're using React with Vite, polyfills are handled differently. You'll need to follow [this guideinstead](./vite).Irys is fully compatible with React, however, if you’re using npx create-react-app to create your project, you will need to do some additional configuration and installation. This guide details how to create a new React project and add Irys support, if you already have a React project open, free to skip down a few steps. Create a new directory for your project, cd into it, and create your React project: mkdir irys-react cd irys-react npx create-react-app . Install the Irys SDK and ethers: npm install @irys/sdk ethers@5 In your App.js file write an initialization function that sets up a WebIrys object. The following code shows how to use ethers5, if you're using a different provider make sure to specify it when creating the wallet. function App() {const initialiseIrys = async () => {await window.ethereum.enable();const provider = new providers.Web3Provider(window.ethereum);const wallet = { name: \"\"ethersv5\"\", provider: provider };const network = \"\"mainnet\"\"; // Or \"\"devnet\"\"const token = \"\"matic\"\";const webIrys = new WebIrys({ network, token, wallet });await webIrys.ready();return webIrys;};return Irys Test; } export default App; Viewing that page, you'll get a bunch of errors saying BREAKING CHANGE: webpack < 5 used to include polyfills for node.js core modules by default. To fix this you'll need to include NodeJS polyfills which are no longer included by default. Install first react-app-rewired, a package that allows for editing of the webpack config file to fix polyfill issue. Then install the missing dependencies. npm install react-app-rewired npm install --save-dev crypto-browserify stream-browserify assert stream-http https-browserify os-browserify url buffer process npm install browserify-zlib path-browserify path At the root level of your project, create a new file called config-overrides.js and paste the following in: const webpack = require(\"\"webpack\"\"); module.exports = function override(config) {const fallback = config.resolve.fallback || {};config.resolve.alias = { ...(config?.resolve?.alias ?? {}), stream: \"\"stream-browserify\"\" };Object.assign(fallback, {crypto: require.resolve(\"\"crypto-browserify\"\"),stream: require.resolve(\"\"stream-browserify\"\"),assert: require.resolve(\"\"assert\"\"),http: require.resolve(\"\"stream-http\"\"),https: require.resolve(\"\"https-browserify\"\"),os: require.resolve(\"\"os-browserify\"\"),url: require.resolve(\"\"url\"\"),zlib: require.resolve(\"\"browserify-zlib\"\"),});config.resolve.fallback = fallback;config.plugins = (config.plugins || []).concat([new webpack.ProvidePlugin({process: \"\"process/browser\"\",Buffer: [\"\"buffer\"\", \"\"Buffer\"\"],}),]);return config; }; Override package.json to include the new webpack configuration. Look for this code block\"\"scripts\"\": {\"\"start\"\": \"\"react-scripts start\"\",\"\"build\"\": \"\"react-scripts build\"\",\"\"test\"\": \"\"react-scripts test\"\",\"\"eject\"\": \"\"react-scripts eject\"\"}, and replace it with this block: \"\"scripts\"\": {\"\"start\"\": \"\"react-app-rewired start\"\",\"\"build\"\": \"\"react-app-rewired build\"\",\"\"test\"\": \"\"react-app-rewired test\"\",\"\"eject\"\": \"\"react-scripts eject\"\" }, Quit React server and restart it with npm run start you should be good to go.",
  "origin": "docs"
},{
  "url": "/hands-on/tutorials/server-side-encryption",
  "title": "Encrypting onchain data (server-side)",
  "description": "How to encrypt data before storing onchain (server-side edition)",
  "text": "Encrypting onchain data (server-side) This guide teaches you how to: Encrypt data using Lit Protocol Establish a set of rules determining who can decrypt the data Store encrypted data on Arweave using Irys Decrypt data using Lit Protocol Before diving into this guide, begin with \"\"Encrypting onchain data\"\". All of the code from this guide is also contained in GitHub repository.Dependencies Install using npm: npm install @irys/sdk @lit-protocol/lit-node-client-nodejs@^3 dotenv ethers@^5 siwe@^2.1.4 or yarn: yarn add @irys/sdk @lit-protocol/lit-node-client-nodejs@^3 dotenv ethers@^5 siwe@^2.1.4Imports dotenv.config();Encrypting dataWallet signature A wallet signature (AuthSig) proves ownership of a wallet. By signing a basic transaction, regardless of its contents, you verify access to the wallet. First, create a file called .env with a single value, and include your private key. PRIVATE_KEY= Then, create a helper function that creates a message and signs it using your private key.Lit Protocol supports both wallet signatures and [sessionsignatures](https://developer.litprotocol.com/v3/sdk/authentication/session-sigs/intro). This guide focuses solely onwallet signatures, as session signatures are currently in development and only available for Ethereum.async function getAuthSig() {const litNodeClient = await getLitNodeClient();let nonce = litNodeClient.getLatestBlockhash();// Initialize the signerconst wallet = new ethers.Wallet(process.env.PRIVATE_KEY);const address = ethers.getAddress(await wallet.getAddress());// Craft the SIWE messageconst domain = \"\"localhost\"\";const origin = \"\"https://localhost/login\"\";const statement = \"\"This is a test statement.You can put anything you want here.\"\";// expiration time in ISO 8601 format.This is 7 days in the future, calculated in millisecondsconst expirationTime = new Date(Date.now() + 1000 * 60 * 60 * 24 * 7).toISOString();const siweMessage = new siwe.SiweMessage({domain,address: address,statement,uri: origin,version: \"\"1\"\",chainId: 1,nonce,expirationTime,});const messageToSign = siweMessage.prepareMessage();// Sign the message and format the authSigconst signature = await wallet.signMessage(messageToSign);const authSig = {sig: signature,derivedVia: \"\"web3.eth.personal.sign\"\",signedMessage: messageToSign,address: address,};return authSig; }Access control conditions Define rules for who to decrypt your data, limiting it to anyone with >= 0 ETH: // This defines who can decrypt the data function getAccessControlConditions() {const accessControlConditions = [{contractAddress: \"\"\"\",standardContractType: \"\"\"\",chain: \"\"ethereum\"\",method: \"\"eth_getBalance\"\",parameters: [\"\":userAddress\"\", \"\"latest\"\"],returnValueTest: {comparator: \"\">=\"\",value: \"\"0000000000000\"\", // 0 ETH, so anyone can open},},];return accessControlConditions; } To the wallet 0x50e2dac5e78B5905CB09495547452cEE64426db2 const accessControlConditions = [{contractAddress: \"\"\"\",standardContractType: \"\"\"\",chain,method: \"\"\"\",parameters: [\"\":userAddress\"\"],returnValueTest: {comparator: \"\"=\"\",value: \"\"0x50e2dac5e78B5905CB09495547452cEE64426db2\"\",},}, ]; Or by people who hold a given ERC721: const accessControlConditions = [{contractAddress: \"\"0xA80617371A5f511Bf4c1dDf822E6040acaa63e71\"\",standardContractType: \"\"ERC721\"\",chain,method: \"\"balanceOf\"\",parameters: [\"\":userAddress\"\"],returnValueTest: {comparator: \"\">\"\",value: \"\"0\"\",},}, ];Connecting to a Lit node Next, connect to a Lit node: async function getLitNodeClient() {// Initialize LitNodeClientconst litNodeClient = new LitJsSdk.LitNodeClientNodeJs({alertWhenUnauthorized: false,litNetwork: \"\"cayenne\"\",});await litNodeClient.connect();return litNodeClient; }Encrypt data Finally, write a function that encrypts a string. In this guide we're using the Lit function encryptString() which encrypts a string and returns both the encrypted string and a hash of the original string. Lit also has encryptFile() for encrypting files directly. async function encryptData(dataToEncrypt) {const authSig = await getAuthSig();const accessControlConditions = getAccessControlConditions();const litNodeClient = await getLitNodeClient();// 1. Encryption//encryptedString//dataToEncryptHashconst { ciphertext, dataToEncryptHash } = await LitJsSdk.encryptString({authSig,accessControlConditions,dataToEncrypt: dataToEncrypt,chain: \"\"ethereum\"\",},litNodeClient,);return [ciphertext, dataToEncryptHash]; }Storing on Arweave via Irys To use Irys to store data on Arweave, first connect Irys' mainnet or devnet. This function uses the same private key from our .env file and connects to the Irys Devnet where uploads are stored for 60 days. In a production environment, you would change this to use Irys' mainnet where uploads are permanent.This code is configured to MATIC to pay for uploads, and while working with the Irys Devnet, you need to fund yourwallet with free MUMBAI MATIC Devnet tokens. Alternatively, you could use [any otherDevnet token](/overview/supported-tokens#devnet-tokens) supported by Irys.async function getIrys() {const network = \"\"devnet\"\";// Devnet RPC URLs change often, use a recent one from https://chainlist.org/const providerUrl = \"\"\"\";const token = \"\"matic\"\";const irys = new Irys({network, // \"\"mainnet\"\" || \"\"devnet\"\"token, // Token used for paymentkey: process.env.PRIVATE_KEY, // Private keyconfig: { providerUrl }, // Optional provider URL, only required when using Devnet});return irys; } Then, write a function that takes the encrypted data, the original data hash, and the access control conditions, and stores it all on Arweave using Irys. Irys' upload function returns a signed receipt containing the exact time (in milliseconds) of the upload and also a transaction ID, which can then be used to download the data from a gateway.For simplicity, we'll consolidate all three values into a JSON object and upload it to Irys in one transaction. Thisis a design choice; you have the flexibility to store these values as you see fit in your own implementation.async function storeOnIrys(cipherText, dataToEncryptHash) {const irys = await getIrys();const dataToUpload = {cipherText: cipherText,dataToEncryptHash: dataToEncryptHash,accessControlConditions: getAccessControlConditions(),};let receipt;try {const tags = [{ name: \"\"Content-Type\"\", value: \"\"application/json\"\" }];receipt = await irys.upload(JSON.stringify(dataToUpload), { tags: tags });} catch (e) {console.log(\"\"Error uploading data \"\", e);}return receipt?.id; }Decrypting dataRetrieving data from Arweve using the Irys gateway To download data stored on Arweave, connect to a gateway and request the data using your transaction ID. This function downloads the data JSON object, parses out the three values and returns them as an array of strings. async function retrieveFromIrys(id) {const gatewayAddress = \"\"https://gateway.irys.xyz/\"\";const url = ${gatewayAddress}${id};try {const response = await fetch(url);if (!response.ok) {throw new Error(Failed to retrieve data for ID: ${id});}const data = await response.json();return [data.cipherText, data.dataToEncryptHash, data.accessControlConditions];} catch (e) {console.log(\"\"Error retrieving data \"\", e);} }Decrypting data Finally, we decrypt the data using Lit's decryptString() function. async function decryptData(ciphertext, dataToEncryptHash, accessControlConditions) {const authSig = await getAuthSig();const litNodeClient = await getLitNodeClient();let decryptedString;try {decryptedString = await LitJsSdk.decryptToString({authSig,accessControlConditions,ciphertext,dataToEncryptHash,chain: \"\"ethereum\"\",},litNodeClient,);} catch (e) {console.log(e);}return decryptedString; }Main function Now write a main() function that calls the calls our encrypt, store and decrypt code. async function main() {const messageToEncrypt = \"\"Irys + Lit is 🔥x2\"\";// 1. Encrypt dataconst [cipherText, dataToEncryptHash] = await encryptData(messageToEncrypt);// 2. Store cipherText and dataToEncryptHash on Irysconst encryptedDataID = await storeOnIrys(cipherText, dataToEncryptHash);console.log(Data stored at https://gateway.irys.xyz/${encryptedDataID});// 3. Retrieve data stored on Irys// In real world applications, you could wait any amount of time before retrieving and decryptingconst [cipherTextRetrieved, dataToEncryptHashRetrieved, accessControlConditions] = await retrieveFromIrys(encryptedDataID,);// 4. Decrypt dataconst decryptedString = await decryptData(cipherTextRetrieved, dataToEncryptHashRetrieved, accessControlConditions);console.log(\"\"decryptedString:\"\", decryptedString); } main(); You can also access the code as a single file in GitHub.Browser-based example Browser-based encryptionDemo Irys Provenance Toolkit",
  "origin": "docs"
},{
  "url": "/hands-on/tutorials/udl-erc20",
  "title": "Create an ERC20 profit-sharing token for NFTs with UDL",
  "description": "Create an ERC20 profit-sharing token for NFTs with UDL",
  "text": "Create an ERC20 profit-sharing token for NFTs with UDL In this tutorial, you will create a custom ERC20 token and use it to manage fractional ownership of NFTs that have a Universal Data License (UDL).Monetizing UDL Using the UDL, creators can define a set of rules that clearly define how their content can be used and what fees are charged for different uses. To charge a fee of 42 tokens, you’d add this tag: { \"\"name\"\": \"\"License-Fee\"\", \"\"value\"\": \"\"One-Time-42\"\" } To specify the Matic token, you’d add this tag: { \"\"name\"\": \"\"Currency\"\", \"\"value\"\": \"\"MATIC\"\" } To specify that payments should be made to a given address, you’d add this tag: { \"\"name\"\": \"\"Payment-Address\"\", \"\"value\"\": \"\"0xBundlooor\"\" } However this only allows for a single owner, in cases where you want to have fractional ownership, you would attach a profit-sharing token (PST) contract to the UDL using the Contract tag: { \"\"name\"\": \"\"Contract\"\", \"\"value\"\": \"\"0xFoo\"\" } When the Contact tag is present, you have to further define how payments should be distributed: Either setting it so that fees are split between all holders proportionally to their holdings: { \"\"name\"\": \"\"Payment-Mode\"\", \"\"value\"\": \"\"Global-Distribution\"\" } Or randomly distributed to one holder, with distribution weighted proportionally to holdings: { \"\"name\"\": \"\"Payment-Mode\"\", \"\"value\"\": \"\"Random-Distribution\"\" } In this tutorial, we’ll write an ERC20 profit-sharing token contract. The contract will be set to either global or random distribution at creation and will expose a function called distributeRevenue() which accepts payments and distributes it between holders. You can use the contract as is, or use its logic as a base for building your own contracts.Prerequisites To complete this tutorial, you should have a basic understanding of the UDL and the opportunities it affords builders. You should understand the basics of Solidity but do not need to be an expert.The smart contract Our contract, named MySong, represents ownership in a single music NFT. This contract is an ERC20 token, and we've set its total supply to a fixed 100 tokens.Having 100 tokens makes it easy to mentally model ownership amounts, as having 1 coin means you own 1% of the total.In practice, the number of coins could be anything.The majority of the contract is boilerplate ERC20, it mints 100 tokens to the contract deployer at creation, and through inheritance, it includes functions for transferring tokens between addresses. In its constructor, the contract is set to either global or random mode, and then exposes a function called distributeRevenue(), which splits revenue payments among token-holders. The function accepts payment in the form of ETH, then either does global or random distribution. To simplify things, this contract uses pseudo-random number generation which comes with an element of risk. When building your own solutions, you might choose to use a verifiable random number generator.This is just one way revenue distribution could be handled, another way would be for the contract to hold all paymentsand let recipients claim them when it makes sense. This method would help save gas costs, as recipients could chooseto only take distributions when their balance is higher the gas fees.// SPDX-License-Identifier: MIT pragma solidity ^0.8.9; import \"\"@openzeppelin/contracts/token/ERC20/ERC20.sol\"\"; import \"\"@openzeppelin/contracts/access/Ownable.sol\"\"; import \"\"@openzeppelin/contracts/utils/math/SafeMath.sol\"\"; contract MySong is ERC20, Ownable {using SafeMath for uint256;enum PaymentMode { GLOBAL, RANDOM }PaymentMode public paymentMode;constructor(PaymentMode _paymentMode) ERC20(\"\"MySong\"\", \"\"MSG\"\") {_mint(msg.sender, 100);paymentMode = _paymentMode;}function distributeRevenue() external payable onlyOwner {uint256 totalSupply = totalSupply();require(totalSupply > 0, \"\"No tokens exist.\"\");if (paymentMode == PaymentMode.GLOBAL) {_distributeGlobal();} else if (paymentMode == PaymentMode.RANDOM) {_distributeRandom();}}function _distributeGlobal() private {for (uint256 i = 0; i0) {uint256 amountToDistribute = msg.value.mul(holderBalance).div(totalSupply());payable(holder).transfer(amountToDistribute);}}}function _distributeRandom() private {uint256 randomValue = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender))) % totalSupply();uint256 cumulativeSum = 0;for (uint256 i = 0; i < _holders.length; i++) {address holder = _holders[i];uint256 holderBalance = balanceOf(holder);cumulativeSum = cumulativeSum.add(holderBalance);if (randomValue < cumulativeSum) {payable(holder).transfer(msg.value);break;}}}address[] private _holders;function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {super._beforeTokenTransfer(from, to, amount);if (from == address(0)) {_addHolder(to);} else if (to == address(0)) {_removeHolder(from);} else {_addHolder(to);}}function _addHolder(address newHolder) private {if (balanceOf(newHolder) == 0) {_holders.push(newHolder);}}function _removeHolder(address oldHolder) private {if (balanceOf(oldHolder) == 0) {for (uint256 i = 0; i < _holders.length; i++) {if (_holders[i] == oldHolder) {holders[i] = holders[_holders.length - 1];_holders.pop();break;}}}} } // MySongTesting on Remix To understand how token works, let’s test it in the Remix IDE.Deploying the contract Launch Remix Select Environment: In the left sidebar, under the \"\"Deploy & run transactions\"\" tab, ensure \"\"Remix VM (Shanghai)\"\" is selected as the environment. Paste the Contract: In the “File explorer” tab click the + icon to create a new file. Name it MySong.sol and paste in the MySong contract code. Compile the Contract: In the left sidebar, click on the \"\"Solidity compiler\"\" tab, then click the \"\"Compile MySong.sol\"\" button. Deploy: Go back to the \"\"Deploy & run transactions\"\" tab. MySong should be selected in the \"\"Contract\"\" dropdown. Click the orange \"\"Deploy\"\" button and either enter 0 for global distribution or 1 for random distribution.Transferring tokens Once the contract is deployed, under \"\"Deployed Contracts\"\", find MySong. You'll see buttons representing contract functions. To transfer tokens: Click the transfer function. Enter the recipient address in the \"\"to\"\" field (choose from the \"\"Account\"\" dropdown at the top of the page) Specify the number of tokens to send in the \"\"value\"\" field ({\"\"<=\"\"} 100) Click the transact button.Sending revenue Once you’ve distributed tokens between holders, test revenue distribution. In the \"\"Deploy & run transactions\"\" tab, above to the \"\"Deploy\"\" button, there's a field labeled \"\"Value\"\". Enter the amount of Ether you want to distribute as revenue. n the \"\"Deployed Contracts\"\" section, find MySong and click the distributeRevenue() function. Click the transact button. Check Balances: After distributing revenue, you can switch between accounts in the \"\"Account\"\" dropdown at the top to see how the Ether balance of each account has changed.Contract tag After creating and deploying the contract, fork the Irys Provenance Toolkit and use the Irys UDL Uploader to upload a new asset while setting the Contract tag to be the address of the smart contract you just deployed. This pairs the UDL-protected asset with the smart contract, establishing a payment management rule for platforms.Alternatives While creating a custom ERC20 and attaching it to the NFT’s UDL via the Contract tag works fine, it has one possible downside that the ERC20 needs to be created before the NFT. You create the ERC20 contract and then attach the contract address to the NFT’s UDL. In cases where you have an existing NFT with UDL, and want to layer on fractional ownership afterwards, you will need an alternative approach, like the one implemented in this repository.Extending Using an ERC20 token to model ownership of a UDL asset opens up new ideas for builders including: Creating a DEX that focuses on trading the tokens, where the market cap of the token represents the value placed on the UDL NFT. Creating a lending platform that uses the tokens as collateral. The platform could base the loan amount on the artist’s historical sales data. Gifting long-term token holders with tokens from new creations. The UDL's strength lies in its parametrized rules without preset enforcement. As builders, you have the freedom to craft tools that uphold these rules and also innovate beyond them. What will you build?",
  "origin": "docs"
},{
  "url": "/hands-on/tutorials/udl-nft",
  "title": "Define NFT licensing with the UDL",
  "description": "Learn how to attach a UDL to an NFT",
  "text": "Define NFT licensing with the UDL In this tutorial, you'll learn how to attach a Universal Data License (UDL) to an NFT. The UDL is a parameterized license you can use to explicitly define how you allow your content to be used.Overview Purchasing an NFT not only gives you ownership of the token itself but, depending on the collection, may also grant certain rights over the underlying intellectual property. These rights cover things like creating derivative works or merchandising the artwork on items such as t-shirts. Each NFT collection varies in the rights it provides to its token holders and historically, there hasn't been a standard license attached to NFTs. With the UDL creators now have a simple, customizable license they can easily attach to NFT metadata at upload that spells out the permissions they grant to the token holders.Adding UDL to NFTs Creating an NFT is (generally) a four step process: Upload the visual asset (image or video) Embed the URL to the visual asset in a metadata file Upload the metadata file Use the link to the metadata when minting the NFT For more details on this, we have a separate tutorial. When uploading the metadata, you can attach a UDL in the form of tags with name / value pairs. If you’re using our NodeJS SDK to upload your metadata files, you can modify your upload script to include the UDL parameters. Not all UDL tags are required, and the ones you use will depend on how you want to allow your content to be used. The script below demonstrates how to add common tags to a metadata file upload, when using it for your own project, customize as needed. dotenv.config(); // Returns a reference to an Irys node const getIrys = async () => {const network = \"\"devnet\"\";// Devnet RPC URLs change often, use a recent one from https://chainlist.org/const providerUrl = \"\"\"\";const token = \"\"matic\"\";const privateKey = process.env.PRIVATE_KEY;const irys = new Irys({network, // \"\"mainnet\"\" || \"\"devnet\"\"token, // Token used for paymentkey: privateKey, // ETH or SOL private keyconfig: { providerUrl }, // Optional provider URL, only required when using Devnet});return irys; }; // Path to metadata file const fileToUpload = \"\"./metadata.json\"\"; // Define the Tag type type Tag = {name: string;value: string; }; // Define your unique license const tags: Tag[] = [{ name: \"\"Content-Type\"\", value: \"\"application/json\"\" },{ name: \"\"Contract\"\", value: \"\"0xd9145CCE52D386f254917e481eB44e9943F39138\"\" },{ name: \"\"Payment-Mode\"\", value: \"\"Global-Distribution\"\" },{ name: \"\"License\"\", value: \"\"yRj4a5KMctXuOmKWCFJIjmY8DeJcusVk6-HzLiMt8\"\" },{ name: \"\"License-Fee\"\", value: \"\"Monthly-1\"\" },{ name: \"\"Derivation\"\", value: \"\"Allowed-With-Credit\"\" },{ name: \"\"Commerical-Use\"\", value: \"\"Allowed\"\" },{ name: \"\"Currency\"\", value: \"\"ETH\"\" }, ]; // Upload the metadata with UDL tags const uploadMetadata = async () => {try {const irys = await getIrys();const response = await irys.uploadFile(fileToUpload, { tags: tags });console.log(File uploaded ==> https://gateway.irys.xyz/${response.id});} catch (e) {console.log(\"\"Error uploading file \"\", e);} }; uploadMetadata();Using the provenance toolkit You can also use the Irys Provenance Toolkit repository which provides a simple graphical interface. Fork or clone the repository Use the Uploader component to upload your visual assets Use the UDL Uploader component to upload your metadata file",
  "origin": "docs"
},{
  "url": "/hands-on/tutorials/uploading-nfts",
  "title": "Uploading NFTs to Irys",
  "description": "How to upload NFT assets to Irys",
  "text": "Uploading NFTs to Irys When you use Irys to store NFT data on Arweave, you’re guaranteed your NFT will be both permanent and immutable. Here’s how you do it.NFT assetsThere are generally three parts to an NFT: Smart contract NFT metadata NFT assets The smart contract can be on any chain, the metadata and assets are stored on an external storage provider. The smart contract stores a pointer to the NFT metadata, and then the NFT metadata contains links to the NFT assets. In the example above for the Developer Quests NFT, there is a name and description that are shown on platforms like Opensea when the NFT is viewed. The image parameter points to a static image of the NFT. The animation_url parameter is optional and points to a video, song, or HTML animation file.Creating an NFT Three steps to creating an NFT: Upload your assets to Irys Embed the URLs to the assets in NFT metadata Upload metadata to Irys Use the metadata URL to mint your NFTThis guide does not cover the smart contract setup, if you’re unsure of how to do this,Thirdweb has free, audited contracts available for use. Uploading assets (SDK) After installing the Irys SDK, use the following to upload your assets. dotenv.config(); // Returns a reference to an Irys node const getIrys = async () => {const network = \"\"devnet\"\";// Devnet RPC URLs change often, use a recent one from https://chainlist.org/const providerUrl = \"\"\"\";const token = \"\"matic\"\";const privateKey = process.env.PRIVATE_KEY;const irys = new Irys({network, // \"\"mainnet\"\" || \"\"devnet\"\"token, // Token used for paymentkey: privateKey, // ETH or SOL private keyconfig: { providerUrl }, // Optional provider URL, only required when using Devnet});return irys; }; const uploadImage = async () => {const irys = await getIrys();const fileToUpload = \"\"./myNFT.png\"\";// Get size of fileconst { size } = await fs.promises.stat(fileToUpload);// Get cost to upload \"\"size\"\" bytesconst price = await irys.getPrice(size);console.log(Uploading ${size} bytes costs ${irys.utils.fromAtomic(price)} ${token});await irys.fund(price);// Upload metadatatry {const response = await irys.uploadFile(fileToUpload);console.log(File uploaded ==> https://gateway.irys.xyz/${response.id});} catch (e) {console.log(\"\"Error uploading file \"\", e);} };Uploading assets (CLI) Alternatively, you can upload using our CLI. irys upload myNFT.png \\-n devnet \\-t matic \\-w bf20......c9885307 \\--tags Content-Type image/png \\--provider-url https://rpc-mumbai.maticvigil.comCreating metadata Embed the URLs generated from the above script into your NFT metadata. The following example is from the Developer Quests NFT. {\"\"name\"\": \"\"Irys Developer Quests Quests\"\",\"\"description\"\": \"\"Irys Developer Quests #42\"\",\"\"image\"\": \"\"https://gateway.irys.xyz/737m0bA1kW4BlIJOgkOGUpHAAI-3Ec9bdo8SxTFKI\"\",\"\"animationurl\"\": \"\"https://gateway.irys.xyz/peRdpP3pjyFQ6m4Hca5fZY5zgz7RSlE86j-5BEwnW0\"\",\"\"background_color\"\": \"\"FEF4EE\"\" }Uploading metadata (SDK) Finally, upload your NFT metadata to Irys and use the URL generated to mint the NFT. dotenv.config(); // Returns a reference to an Irys node const getIrys = async () => {const network = \"\"devnet\"\";// Devnet RPC URLs change often, use a recent one from https://chainlist.org/const providerUrl = \"\"\"\";const token = \"\"matic\"\";const privateKey = process.env.PRIVATE_KEY;const irys = new Irys({network, // \"\"mainnet\"\" || \"\"devnet\"\"token, // Token used for paymentkey: privateKey, // ETH or SOL private keyconfig: { providerUrl }, // Optional provider URL, only required when using Devnet});return irys; }; const uploadMetadata = async () => {const irys = await getIrys();const fileToUpload = \"\"./metadata.json\"\";const tags = [{ name: \"\"Content-Type\"\", value: \"\"application/json\"\" }];// Get size of fileconst { size } = await fs.promises.stat(fileToUpload);// Get cost to upload \"\"size\"\" bytesconst price = await irys.getPrice(size);console.log(Uploading ${size} bytes costs ${irys.utils.fromAtomic(price)} ${token});await irys.fund(price);// Upload metadatatry {const response = await irys.uploadFile(fileToUpload, { tags: tags });console.log(File uploaded ==> https://gateway.irys.xyz/${response.id});} catch (e) {console.log(\"\"Error uploading file \"\", e);} };Uploading metadata (SDK) Alternatively, you can upload using our CLI. irys upload metadata.json \\-n devnet \\-t matic \\-w bf20......c9885307 \\--tags Content-Type application/json \\--provider-url https://rpc-mumbai.maticvigil.com `",
  "origin": "docs"
},{
  "url": "/hands-on/tutorials/uploading-static-sites",
  "title": "Uploading static websites",
  "description": "How to upload a static website to the permaweb using Irys",
  "text": "Uploading static websites You can use Irys to upload entire static websites directly to the permaweb using only a few lines of code. You can use the uploadFolder() SDK function, or the upload-dir command with the CLI.Maintaining link structure When you upload an entire folder of assets to Irys at the same time, two link structures are generated. You can download each asset directly using the transaction ID generated when uploading that unique asset. You can also download each asset using a link generated by combining the manifest ID generated for the entire folder upload with the relative path to the file. For example, if you upload a folder with the following structure: index.html styles.css images/hero.jpg images/logo.png you can download the logo with the link https://gateway.irys.xyz/[manifest-id]/images/logo.png. Because relative paths are maintained, as long as your website uses relative links, you will not need to change any of your HTML when moving to the permaweb.Using the SDK You can upload the entire website using the Irys SDK's uploadFolder() functions. dotenv.config(); const getIrys = async () => {const network = \"\"devnet\"\";// Devnet RPC URLs change often, use a recent one from https://chainlist.org/const providerUrl = \"\"\"\";const token = \"\"matic\"\";const irys = new Irys({network, // \"\"mainnet\"\" || \"\"devnet\"\"token, // Token used for payment and signingkey: process.env.PRIVATE_KEY, // ETH or SOL private keyconfig: { providerUrl }, // Optional provider URL, only required when using Devnet});return irys; }; const uploadFolder = async () => {const irys = await getIrys();// Upload an entire folderconst folderToUpload = \"\"./my-spa/\"\"; // Path to website foldertry {const response = await irys.uploadFolder(\"\"./\"\" + folderToUpload, {indexFile: \"\"index.html\"\", // Your site's index filebatchSize: 50, // Number of items to upload at oncekeepDeleted: false, // wWhether to keep now deleted items from previous uploads}); // Returns the manifest IDconsole.log(Website uploaded. Manifest ID ${response.id});} catch (e) {console.log(\"\"Error uploading file \"\", e);} };Using the CLI You can also achieve the same using our CLI and the upload-dir command. Make sure to change the parameter options to provide your own private key and the name of your site's index file. irys upload-dir ./my-spa --index-file index.html -n mainnet t -w bf20......c9885307 `",
  "origin": "docs"
},{
  "url": "/hands-on/tutorials/vite",
  "title": "Using Irys With React + Vite",
  "description": "Using the Irys SDK with create-react-app and Vite.",
  "text": "Using Irys With React + Vite This guide covers how to setup an Irys project using React + Vite. Setup a new project: mkdir irys-vite cd irys-vite npm create vite@latest . npm install Choose React and either TypeScript or JavaScript, then: npm install Install the Irys SDK and ethers: npm install @irys/sdk ethers@5 Change your App.tsx file as follows. This example uses ethere5, if you're using a different provider make sure to specify it when creating the wallet. function App() {const [connectedAddress, setConnectedAddress] = useState(\"\"\"\");const getWebIrys = async () => {await window.ethereum.enable();const provider = new providers.Web3Provider(window.ethereum);console.log(\"\"provider=\"\", provider);const network = \"\"mainnet\"\";const token = \"\"matic\"\";const wallet = { name: \"\"ethersv5\"\", provider: provider };console.log(\"\"wallet=\"\", wallet);const webIrys = new WebIrys({ network, token, wallet });console.log(\"\"webIrys=\"\", webIrys);await webIrys.ready();setConnectedAddress(webIrys.address);};return (Vite + React + Irys{connectedAddress && connectedAddress.length > 0 && Connected from: {connectedAddress}}Connect To Irys Node); } export default App; When you load your app, you will see a blank white screen and find the following in your developer console. Vite error Class extends value undefined is not a constructor or null To fix this, first install: npm install -D crypto-browserify stream-browserify os-browserify path-browserify vite-plugin-node-polyfills vite-plugin-notifier And then modify vite.config.ts to use the following: // https://vitejs.dev/config/ export default defineConfig({resolve: {alias: {process: \"\"process/browser\"\",path: \"\"path-browserify\"\",os: \"\"os-browserify\"\",},},plugins: [react(),nodePolyfills({// To exclude specific polyfills, add them to this list.exclude: [\"\"fs\"\", // Excludes the polyfill for fs and node:fs.\"\"stream\"\",],// Whether to polyfill specific globals.globals: {Buffer: true,global: true,process: true,},// Whether to polyfill node: protocol imports.protocolImports: true,}),], }); Restart React+Vite and you should be good to go.",
  "origin": "docs"
},{
  "url": "/hands-on/tutorials",
  "title": "Guides & Tutorials",
  "description": "Roll up your sleeves and start building on Irys",
  "text": "Guides & TutorialsUse Irys with npx create-react-app Use Irys with React + Vite Learn the Irys SDK Monitor node balance with a script Upload a website to the permaweb Use Livepeer to transcode video Build a transaction explorer Perform gasless uploadsPermanently upload NFT assets Build a Solana NFT Marketplace With Metaplex Build a dynamic NFTDefine NFT licensing with UDL Create an ERC20 token to manage UDL ownershipUpload Lens metadataEncrypting onchain data overview Encrypting data server-side Encrypting data in the browser ",
  "origin": "docs"
},{
  "url": "/index",
  "title": "Irys Docs",
  "description": "",
  "text": " title: Docs description: Unlock the full potential of Irys’ technology with our developer resources. Start building on Irys today!{`:global(nav) {min-width: 100% !important;padding-right: 79px !important;padding-left: 79px !important;}@media (max-width: 768px) {:global(nav) {padding-right: 16px !important;padding-left: 16px !important;}}`}Irys DocsUnlock the full potential of Irys' technology with our developerresourcesUse our SDK and start storing data permanently with 3 lines of code.{`const irys = new Irys({ network, token, key }); const fundTx = await irys.fund(irys.utils.toAtomic(0.05)); const receipt = await irys.uploadFile(\"\"./myImage.png\"\");`}What is IrysLearn moreLearn with our tutorials and guides, or fork a repository and kickstart your next project.{[{Title: \"\"Tutorials / Guides\"\",FirstParagraph:\"\"Learn with tutorials and guides for all skill levels.\"\",URL: \"\"/hands-on/tutorials\"\",},{Title: \"\"Repositories\"\",FirstParagraph:\"\"Repositories to kickstart your next project.\"\",URL: \"\"/hands-on/repositories\"\",},].map((item, index) => ({/* make image as background of rectangle box */}{item.Title}{item.FirstParagraph}Explore))}",
  "origin": "docs"
},{
  "url": "/learn/bundles",
  "title": "Bundles",
  "description": "Bundles are the data structure used to post data from Irys to Arweave.",
  "text": "BundlesA bundle is a data structure representing a group of transactions. Any number of layer 2 data transactions can be compressed and included in a single bundle layer 1 transaction.Why Bundles? Bundles allow for infinite transaction scaling - allowing up to 2^256 transactions to be stored in a single bundle. As bundle sizes increase, Arweave's transaction capacity can increase linearly - i.e. using 1 million item bundles allows for a 1,000,000x increase in layer 1 transaction capacity. The bundle spec, designed by Irys, is open-sourced and is currently implemented in JavaScript, Go, and Rust. To learn more, please refer to the spec documents.",
  "origin": "docs"
},{
  "url": "/learn/bundling",
  "title": "Bundling",
  "description": "Bundling helps Arweave scale",
  "text": "BundlingIrys uses Bundling to help Arweave scale.Uploading large numbers of files to Arweave can be technically challenging due to Arweave's limit of 1000 transactions per block. When demand spikes, that drives up fees, making permanent data unaffordable for many users. To address these challenges, bundlers are used to collate transactions into a single bundle and submit them to Arweave. These transactions are instantly retrievable and available to be queried. It is not necessary to wait for uploads to be confirmed and seeded on Arweave before they appear in query results. The implementation of bundlers and bundles has helped stabilize feeds on Arweave.",
  "origin": "docs"
},{
  "url": "/learn/funding-withdrawing",
  "title": "Funding / withdrawing",
  "description": "Understand what happens each step of the way when transferring tokens to or from a node.",
  "text": "Funding / withdrawingUsers fund nodes to pay for uploads. Funds can be withdrawn at any time.Tracking DepositsEach Irys node has a collection of per-token wallets and an internal ledger system. The per-token wallets collect user deposits. All deposits for a given token are consolidated into a single designated wallet address. An internal ledger maintains a list of user wallet addresses, and records the amount deposited by each user into the node's corresponding wallet. This enables the system to accurately track each user's deposit history. To see the list of wallets for a given node, append /info to the network address. https://arweave.mainnet.irys.xyz/info https://arweave.devnet.irys.xyz/info Example: {\"\"version\"\": \"\"0.2.0\"\",\"\"addresses\"\": {\"\"arweave\"\": \"\"ZE0N-8P9gXkhtK-07PQu9d8me5tGDxa_i4Mee5RzVYg\"\",\"\"ethereum\"\": \"\"0x474E7A206bd6186B0C51ad9b1D406c12c4fed9c1\"\",\"\"matic\"\": \"\"0x474E7A206bd6186B0C51ad9b1D406c12c4fed9c1\"\",\"\"bnb\"\": \"\"0x474E7A206bd6186B0C51ad9b1D406c12c4fed9c1\"\",\"\"avalanche\"\": \"\"0x474E7A206bd6186B0C51ad9b1D406c12c4fed9c1\"\",\"\"solana\"\": \"\"AFxXJjdXd4i4pvdFbYAd2TmJqQFu9aYCysAFRmPZ4jTo\"\",\"\"arbitrum\"\": \"\"0x474E7A206bd6186B0C51ad9b1D406c12c4fed9c1\"\",\"\"boba-eth\"\": \"\"0x474E7A206bd6186B0C51ad9b1D406c12c4fed9c1\"\",\"\"boba\"\": \"\"0x474E7A206bd6186B0C51ad9b1D406c12c4fed9c1\"\",\"\"chainlink\"\": \"\"0x474E7A206bd6186B0C51ad9b1D406c12c4fed9c1\"\",\"\"near\"\": \"\"bundlr2.near\"\",\"\"aptos\"\": \"\"0xed50b11ce7f4402bee43f357e593ca46515f530ecca991d1460dc0557617d033\"\"},\"\"gateway\"\": \"\"gateway.irys.xyz\"\" }How funding worksThe funding process is as follows: Tokens are transferred from the user's wallet to the node's wallet address associated with the relevant token. The transaction ID from the first step is forwarded to the selected Irys node. The Irys node verifies that the transaction was directed to one of its designated wallets. Once verified, the node proceeds to update an internal ledger that tracks the sender's wallet and the number of tokens transferred.How withdrawing worksThe withdrawing process is as follows: The node performs a validation of the request's field order and format, creates a deep hash of the supplied data, and subsequently verifies it using the provided signature. The node checks if the request comes from a wallet listed on its internal ledger. The node confirms if the requested withdrawal amount does not exceed the user's balance. The requested funds are transferred back to the user from the node's wallet, with the user responsible for paying the associated gas fees for the transfer. The internal ledger is updated with the user's new balance. The request for withdrawal is sent as a JSON object with the following fields: const data = {nonce,publicKey,token,amount,signature,sigType, }; | Field| Description| | --------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | | nonce| A counter tracking the total number of withdrawals performed by this wallet (used to prevent man-in-the-middle attacks) | | publicKey | The user's public key| | token| The token being withdrawn| | amount| The amount being withdrawn| | signature | Signature generated by hashing and then signing the token, amount, and nonce| | sigType| Used internally|For implementation and usage details, see the SDK documentation for fund() andwithdrawBalance()). ",
  "origin": "docs"
},{
  "url": "/learn/irys-arweave",
  "title": "Irys & Arweave",
  "description": "Irys handles 90% of all traffic on Arweave.",
  "text": "Irys & ArweaveIrys started out as a solution to both scale Arweave and reduce pain points experienced by developers. Our horizontal and linear scaling solutions radically increased transactions per second, from 9 TPS on Arweave directly to more than 50,000 TPS when using Irys. When uploading to Arweave, you pay for uploads in their native token AR, and sign the transaction using their native cryptography. The AR token isn’t widely available, and the cryptography needed to sign transactions isn’t as familiar to Web3 developers as the cryptography used by Ethereum and Solana. We eased this pain point by including support for 14 different tokens and their related cryptography. Developers can pay using the tokens they have and sign using any private key, including those from Solana and Ethereum. When uploading to Arweave, data is priced in increments of 256KB. This means if you upload 1KB or 255KB you pay the same. We eased this pain point by charging a straight fee per byte. You only pay for the data you need, no more. When uploading to Arweave, your transaction is considered confirmed once it’s included in a block. Your transaction is considered final once 50 confirmations have passed. With a block time of 2 minutes, it takes roughly 100 minutes before a transaction uploaded to Arweave can be considered final. Transaction finality is important, because in the event of a blockchain fork, only finalized transactions are guaranteed not to be dropped. We eased this pain point and streamlined the upload process by introducing optimistic finality. In addition to easing developer pain points encountered when working with Arweave, Irys also adds strong provenance to every upload.",
  "origin": "docs"
},{
  "url": "/learn/optimistic-cache",
  "title": "Optimistic cache",
  "description": "Optimistic caching makes your uploads instantly available",
  "text": "Optimistic cacheThe optimistic cache ensures all data uploaded to Irys is immediately available via gateways, which are responsible for making data available to users. When a user requests data from a gateway, it searches for it in its local cache. If the data is not found, the gateway requests it from Arweave. If the data is still not found, the gateway requests it from Irys' optimistic cache. The optimistic cache is essential for providing users with real-time access to uploaded data, as it provides access to transactions that have not yet been seeded on Arweave, but are expected to be seeded soon.The optimistic cache queries each Irys node sequentially until the data is found. Node 1 and 2 are queried first, followed by Devnet. If the data is found, it is returned instantly. Otherwise, a 404 code is returned. On Irys' Devnet, uploads are kept for approximately 60 days, during this time, the data is available from gateways in the same way that normal uploads are.",
  "origin": "docs"
},{
  "url": "/learn/receipts",
  "title": "Receipts",
  "description": "Signed receipts provide unrefutable proof of time",
  "text": "ReceiptsReceipts give you cryptographic proof of the exact time, accurate to the millisecond, that a transaction occurred.Receipts & Timestamps When you upload data to Irys, it is stamped with a millisecond-accurate timestamp before being passed to Arweave where it is stored permanently. Blockchains rely on timestamps to sequence the order of transactions and blocks. Transaction sequencing plays a critical role in blockchain security as it ensures that all transactions are recorded in the correct order, and that order is never changed. Receipts provide cryptographic proof of a timestamp. This creates a secure and tamper-proof sequence of all transactions, enabling proof of authenticity, permanence, and provenance.Ordering & streaming Ordering and streaming applications process and deliver data in real-time. They're commonly used for messaging, event processing, and data integration. They transfer high data volumes between independent applications while maintaining high performance and scalability. Popular examples include Apache Kafka and RabbitMQ. Users could use Irys' receipts to: Build a category-based event streaming application by using Irys query packageWhy use signed receipts? Cryptographically signed receipts open up new development options for builders. For example: Sequential ordering of posts, likes and comments for a decentralized social protocol. Sequential ordering of data generated by a group messaging protocol. Automatically adjudicating music copyright claims. Preserving history, ensuring it's not manipulated over time. Preserving scientific research using Irys' pay-once, store-forever model.Receipt permanence Upon posting a transaction to Irys, a receipt is immediately returned to the user. Irys maintains an internal registry of all receipts, which can be queried whenever a receipt is needed. These receipts are stored in a centralized fashion, which may be sufficient for users comfortable with the trust assumptions of centralized services. Users also have the option to use Irys to store the receipt on Arweave. These receipts inherit Arweave’s permanence, meaning you can verify transaction sequencing at any time, even if Irys is no longer available.Receipt format Receipts are a JSON object with the following format: {id: '1Txlbl5NgEqUbIkDnnunHC0gFx0n8_Y92zAsoX54kI8',timestamp: 1676891681110,version: '1.0.0',public: '...',signature: '...',deadlineHeight: ...,block: ...,validatorSignatures: [], } | Field| Description| | ------------------- | ---------------------------------------------------------------------- | | id| Transaction id (used to download the data)| | timestamp| Timestamp (UNIX milliseconds) of when the transaction was created| | version| The version of this JSON file, currently 1.0.0| | public| Public key of the bundler node used| | signature| A signed deep hash of the JSON receipt| | deadlineHeight| The block number by which the transaction must be finalized on Arweave | | block| Deprecated| | validatorSignatures | Deprecated|Verifying receipts You may need to verify a receipt at some point after it was issued. For example, if your application’s security depends on the order of transactions, you can then verify every receipt to ensure its order has not been tampered with. The receipt contains a signature field, which is generated by creating a deep hash of information from the receipt, including transaction ID and timestamp. It is then signed it by Irys. Using the Irys SDK you can verify the signature using the using the same values from the receipt along with the supplied public key.Timestamp generation Irys records the precise time of each transaction with a UNIX timestamp in milliseconds. This timestamp is generated by the node that first receives and verifies the transaction.",
  "origin": "docs"
},{
  "url": "/learn/strong-provenance",
  "title": "Strong provenance",
  "description": "Data on Irys has strong provenance, it's permanent, precise and unconstrained",
  "text": "Strong provenanceAll data stored on Irys has strong provenance. Strong provenance, which includes permanence, precision, and unconstrained access, is the key to restoring clarity and confidence in the authorship and authenticity of data. It is best illustrated by the provenance trilemma showing the tradeoffs that proto-provenance layers made between data being permanent, precise, and unconstrained. Permanent Data uploaded to Irys is stamped with a timestamp and attestation details before being passed to Arweave where it is stored permanently.Precise The timestamp assigned to transactions at upload is millisecond-accurate, this is unique in the blockchain space as most blockchains base their timestamps on block time. If the block time is 10 minutes - like with Bitcoin - then the timestamps generated by the chain are accurate to +/-10 minutes. The timestamp assigned by Irys is recorded in a signed receipt that can be verified by anyone at any time, even if Irys is no longer around. This timestamp can be used to chronologically order transactions.Unconstrained Irys provides completely unconstrained provenance, there are no limits on file size uploads and there are no limits on who can verify the data. Irys is fully permissionless.",
  "origin": "docs"
},{
  "url": "/learn/transaction-lifecycle",
  "title": "Transaction lifecycle",
  "description": "Understand each step of the process as a transaction is processed by Irys.",
  "text": "Transaction lifecycleWhen you post a transaction to Irys, you are instantly given back a signed receipt. While it takes over 100 minutes to achieve transaction finality on Arweave, we optimistically consider the transaction final at upload time as our nodes have internal safeguards that ensure transaction finality on Arweave. Internally, all data submitted to Irys is collected by a bundler. Roughly every 2 minutes, the bundler groups transactions, merges them into a single bundle, and submits them to Arweave. Since we’re submitting data to Arweave, it’s important to understand what happens over there too. Arweave currently uses its 2.x transaction format, which includes an id, a signature, a public key, meta tags, and the amount of money you’re sending. While the 1.0 format included your data, the 2.0 format notably does not include your data. The reason they moved away from including the data in the transaction was to accommodate larger uploads. With a block time of roughly 2 minutes, the maximum upload to Arweave was limited by network transmission speeds. The laws of physics and the current state of network hardware created an upper limit on data size which constrained Arweave’s ability to scale.There are no limits restricting the amount of data that can be uploaded to Arweave via Irys.In the current 2.6 Arweave version, miners submit the smaller header information first, and then they seed the actual data to their peers afterward. To incentivize miners to store as much data as possible, Arweave operates under a protocol called Succinct Proof of Random Access (SPoRA) where miners need to prove they have access to a random piece of historical data. The more data a miner stores, the greater the number of mining rewards they can earn. Miners have the option of how much data to store, and while there are storage costs associated with storing the full dataset, storing data is also the path to earning more mining rewards.After submitting your transaction header to Arweave, Irys continually monitors the submission, if finality is not achieved, the transaction is automatically resubmitted. In addition to submitting the transaction header, Irys also submits your data to a network of miners. In general, your data is submitted to a minimum of 10 miners and is guaranteed to be seeded to a minimum of 3 miners. Irys decides which miners to seed your data to based on our internal reliability score. We constantly scan Arweave, starting first at a known miner, then recursively scanning all of its peers, all of those peer’s peers, and so on. Each miner is given a reliability score that while initially based on the scores of its peers, is continually updated based on that miner’s behavior. Miners are praised for good behavior and punished for bad behavior. As any one instance of bad behavior can be detrimental to the network, we use a logarithmic scoring system. The higher a miner’s score, the harder it becomes to increase that score. However, any instance of bad behavior causes an immediate and linear decrease in a miner’s score. Miners are extra careful to avoid bad behavior as a single instance will cause their score to drop significantly and due to the logarithmic scoring system, it will then take time to rebuild a previous reliability score. Our praise and punish reputation system has an additional added benefit of helping responsible miners earn greater rewards. Responsible behavior leads to a higher reputation score, a higher score means we seed data directly to them, which means they’re able to supply the recall block quicker, which in turn means they’re able to complete the block quicker and earn greater rewards. ",
  "origin": "docs"
},{
  "url": "/learn/udl",
  "title": "UDL & builders",
  "description": "UDL opportunities for builders",
  "text": "UDL & buildersThe Universal Data License (UDL) provides content creators with a straightforward way to define how their content can be used, along with the prices they set for its use. It is a standardized and parameterized approach that opens up new financial opportunities for creators and builders.Content marketplaces Traditionally, online content sales tied creators to the licensing terms of individual platforms. This meant conforming to multiple different agreements for streaming on platforms, like with Spotify and Apple Music. These platforms are designed to extract the maximum value from creators, leaving them with only a small percentage of revenue, and while major artists might have the power to negotiate better terms, most creators find themselves constrained. With the UDL, creators can detail exactly how they allow their content to be used. Using the UDL, marketplaces can then identify and autonomously promote content, bypassing manual permissions as the licensee has already granted approval.UDL and NFTs NFT ownership is managed by a smart contract, and while the contract clearly calls out who owns which NFT, it does nothing to define what usage rights are granted to each owner. This means each NFT comes with unique rights, and that owners end up having to wade through detailed contracts to understand. For example, purchasing a Bored Apes NFT offers the buyer expansive rights, even allowing them to feature the NFT in media productions. Conversely, with Coke's NFT release, owning the NFT doesn't authorize you to repurpose the Coke logo for competing ventures. The Universal Data License (UDL) provides a structured way to clarify these permissions for NFT holders. To add a UDL to an NFT, creators simply need to incorporate UDL-specific tags when uploading NFT metadata. We also have a tutorial on adding a UDL to NFTs.UDL and AI The UDL introduces the Derivation tag, specifically designed to grant the right to create derivative works based on the original content. When considering the training of AI models, especially those that generate images, the source data's licensing terms are crucial. AI models ingest and learn from this data, with the quality and diversity of the input data directly influencing the type of images the AI produces. If an AI is trained on data protected by copyrights that prohibit the creation of derivative works, users run the risk of violating these copyrights when using the AI's outputs. Conversely, training an AI exclusively on data that explicitly permits the creation of derivative works ensures that all images or outputs generated by that AI remain free from potential copyright infringements.UDL and Creative Commons The UDL and Creative Commons (CC) both aim to empower creators by giving them tools to define the terms under which their content can be used. However, a key distinction between them is the parameterized nature of the UDL. While Creative Commons offers a set of predefined licenses, each with its own fixed terms, the UDL allows creators to define specific usage terms via standardized metadata. This means that with the UDL, creators can customize license terms when they upload content by setting metadata tags. In contrast, Creative Commons' static nature requires creators to pick from the available licenses without the ability to customize individual parameters. Additionally, CC is primarily focused on credit and attribution, it doesn’t define terms for fees or revenue share. UDL is both more customizable than CC and more expansive.UDL is not DRM The UDL is a licensing framework, and Digital Rights Management (DRM) is a set of access control technologies that limit the use of digital media or devices after sale. They are two different, but complementary technologies. While UDL defines usage terms via metadata, it doesn't enforce any control of content access. Encryption-based DRM could be used alongside UDL to enforce the terms specified, ensuring both clarity of rights and security of content.Crosschain opportunities One potential way to manage ownership of UDL assets is with the use of custom tokens. You’d do this by creating a smart contract that creates a new token with a fixed supply. The tokens would be fully tradeable and their ownership would represent ownership of the UDL asset. The smart contract would expose a function that accepts revenue payments and automatically distributes them proportionally based on token ownership. If you’re interested in learning more, we have a tutorial on building an ERC20 token to manage UDL ownership.Opportunities for Builders UDL is a set of rules and notably does not include any definition for how those rules are to be enforced. This opens up significant opportunities for builders looking to make an impact in the space. Opportunities like: Building an NFT platform where users can easily define licensing rules for their creations. An AI image generation model trained only on assets that allow derivative works. A TikTok-like app that allows users to remix songs that allow derivative works to be created. A platform for automatically deploying ERC20 tokens to manage ownership of UDL content. A DRM system that uses LitProtocol to encrypt data, and making it available under terms defined by the UDL. What will you build?",
  "origin": "docs"
},{
  "url": "/learn/volumetric-scaling",
  "title": "Volumetric scaling",
  "description": "Irys’ scaling is volumetric because it can independently scale across three vectors - writing, reading, and verification.",
  "text": "Volumetric scalingIrys’ scaling is volumetric because it can independently scale across three vectors: writing, reading, and verification. This scaling architecture enables each axis to adapt to meet fluctuating demand. Bundlers (writers) Arweave has a limit of 1,000 transactions per block. When demand surges, fees shoot up, and spikes in network traffic can cause fees to increase exponentially, rendering permanent data unaffordable for many users. To solve this problem, Irys uses bundlers to collate transactions together into a bundle before submitting them to Arweave as a single transaction. Irys handles over 90% of all traffic on Arweave, has been tested at 50K TPS, and could easily scale to over 1,000,000 TPS.Gateways (readers) Gateways are responsible for indexing, serving, and making data and transactions on Arweave available to users. While many users rely on well-known gateways such as arweave.net and gateway.irys.xyz, it's also possible to run your own gateway using the AR.io open-source offering. This means that anyone can spin up a new gateway at any point in time to meet their unique demand requirements.Verification When you upload a transaction to Irys, you’re given a receipt containing a millisecond-accurate timestamp, authorship details, and other metadata. This receipt can be permissionlessly verified either by manually creating a deep hash of all its fields and comparing it against the receipt's signature or by using the SDK function irys.utils.verifyReceipt(), an abstraction of the manual verification process.Transaction verification In addition to verifying receipts, you can verify transactions by creating a deep hash of all transaction fields and verifying that the transaction signature was generated using the deep hash.Volumetric scaling now and in the future Irys is a fully unconstrained point of entry to Arweave, making permanent data with strong provenance accessible with just a few lines of code. Irys can handle millions of transactions per second and limitless data volumes, all while being permissionlessly verifiable. Arweave scales horizontally by increasing the number of miners storing data; therefore, more miners on Arweave means more bandwidth on the network. Irys is designed to handle more than just current demand; we're built for growth. Our scalability tests go beyond today's needs, ensuring we're prepared for what comes next. We're future-proof.",
  "origin": "docs"
},{
  "url": "/overview/about",
  "title": "About Irys",
  "description": "Unlock the full potential of Irys' technology with our developer resources.",
  "text": "About IrysIrys is the only provenance layer. It enables users to scale permanent data and precisely attribute its origin. A provenance layer is a ledger of record for digital information, tracking the origins and modifications of data. Data uploaded to Irys is permanent, precise, and unconstrained. PermanentData stored on Irys is censorship-resistant and immutable, forever. There's no counterpartyrisk of data being removed. PreciseEach piece of data is timestamped with a high-precision timestamp, providing a reliable sequence ofevents. UnconstrainedUsers can always read, write, and easily discover data at any scale, making the data fully composable. Irys is permissionlessand offers limitless permanent data, enabling it to provide provenance for all information. All uploads to Irys are verifiable. After uploading data, you’re given a receipt that can be used by anyone to verify the data’s provenance at any time.Building with Irys Irys' developer tools make it easy to add permanent data with strong provenance to your projects.",
  "origin": "docs"
},{
  "url": "/overview/cost-to-upload",
  "title": "Cost to upload",
  "description": "Understand our dynamic fee structure.",
  "text": "Cost to uploadThe cost to upload data to Arweave using Irys is based on the number of bytes uploaded.Price calculator The calculator provides the real-time cost of permanently uploading your data.Fee breakdown Fees are computed as follows: irys_fee(X = number of bytes) = arweave_cost(max(X, 10000)) * conversion_rate(\"\"AR\"\", token) * global_multiplier * oracle_fee arweavecost is cost of storing X number of bytes on Arweave using linear pricing (i.e. ignoring minimum chunk size). e.g. if arweavecost(256KB) = $2.56 then arweave_cost(1KB) = $0.01 conversion_rate is the conversion rate between AR and some other token (e.g. MATIC). This allows users to pay the same fees in different currencies. global_multiplier is a multiplier applied to all transactions which can be seen as a “profit margin”. oracle_fee is a risk multiplier which accounts for cost of treasury management and asset volatility.Free uploads Uploads below 100 KiB are free on Irys. This is a public good for users to be encouraged to try Irys. Uploads are rate-limited to 600 transactions per minute, with upload counts resetting every minute. If you upload more than 600 transactions within a minute and have a funded balance, that balance will be used to pay for the transaction. If you don't have a balance, then you'll get a 402 - Free transaction limit exceeded, funds required error.",
  "origin": "docs"
},{
  "url": "/overview/fees",
  "title": "Fees",
  "description": "Understand our dynamic fee structure.",
  "text": "FeesIyrs' fee is dynamic and depends on several parameters.Fees are computed as follows: irys_fee(X = number of bytes) = arweave_cost(max(X, 10000)) * conversion_rate(\"\"AR\"\", token) * global_multiplier * oracle_fee arweavecost is cost of storing X number of bytes on Arweave using linear pricing (i.e. ignoring minimum chunk size). e.g. if arweavecost(256KB) = $2.56 then arweave_cost(1KB) = $0.01 conversion_rate is the conversion rate between AR and some other token (e.g. MATIC). This allows users to pay the same fees in different currencies. global_multiplier is a multiplier applied to all transactions which can be seen as a “profit margin”. oracle_fee is a risk multiplier which accounts for cost of treasury management and asset volatility.Free uploads Uploads below 100 KiB are free on Node 2. This is a public good for users to be encouraged to try Irys. Uploads are rate-limited to 600 transactions per minute, with upload counts resetting every minute. If you upload more than 600 transactions within a minute and have a funded balance on Node 2 that balance will be used to pay for the transaction. If you don't have a balance, then you'll get a 402 - Free transaction limit exceeded, funds required error.",
  "origin": "docs"
},{
  "url": "/overview/gateways",
  "title": "Gateways",
  "description": "Gateways are responsible for indexing and serving data.",
  "text": "GatewaysGateways are responsible for indexing, serving, and making data available to users.Indexing To ensure that all transactions on Arweave are easily searchable and accessible, gateways index all transaction metadata, including transactions posted via Irys, and transactions posted directly to Arweave. Gateways monitor Arweave for new blocks, and indexes them as they are propagated. Whenever a user posts a transaction to Irys, gateways detect it and add it to its own database. During the indexing process, gateways extract transactions from each block and index the metadata. When a bundle is encountered, gateways index all the transactions within. Similarly, if a manifest is found, gateways indexes it. By indexing manifests, gateways create a virtual directory structure that mimics the original folder system. This allows users to access data using the URL format https://gateway.irys.xyz/[manifest-id]/[file-name].Querying Transaction metadata can be queried directly using the Irys query package a REST API or GraphQL. This enables users to create tailored queries, such as searching for specific tags or addresses. Irys supports adding custom metadata tags to each upload, these tags allow users to build data models, all queryable via GraphQL. When a user posts a transaction to Irys, gateways pick it up and store it in their database. This allows gateways to support optimistic GraphQL, meaning query results include both transactions seeded on Arweave as well as those expected to be seeded soon. This ensures users have access to the most up-to-date data and can use it to build real-time applications.Serving DataWhen a transaction is seeded on Arweave, its header and data are stored separately (as explained in transaction lifecycle). To access this data, users request it from a gateway. Because it can be complex, computationally heavy, and difficult for average users to access data directly from miners on Arweave, gateways are crucial in making [downloading data](/developer-docs/downloading) as simple as uploading. When a user requests data from a given gateway, the gateway first checks its internal cache, serving the data from there if it's available. If not, the gateway then checks Arweave to see if the data is stored there. If found, that gateway retrieves the data and serves it to the user, caching it for future use and providing faster response times for frequently requested data. If the data is not found on Arweave or the gateway’s local cache, the gateway checks Irys' optimistic cache to see if the data is available. By doing this, the gateway allows for instant access to data uploaded to Irys, even if it hasn't been finalized on Arweave. This also means data uploaded to Irys' Devnet, where uploads are kept for approximately 60 days, is available via gateways.Scaling Gateways are a crucial component in Irys' scaling strategy. To effectively scale, it's important to separate read and write components so they can be optimized independently. In Irys' approach, bundlers handle writing while gateways handle reading.Gateway schema / endpoints To download data from a gateway, use the transaction id obtained during upload. The most commonly used gateway is https://gateway.irys.xyz, and the format used to download data is https://gateway.irys.xyz/[transaction-id]. For example https://gateway.irys.xyz/CO9EpX0lekJEfXUOeXncUmMuG8eEp5WJHXl9U9yZUYA. For GraphQL queries, you can connect to either of these endpoints: | Node| Endpoint| | ------- | ---------------------------------------- | | Mainnet | https://arweave.mainnet.irys.xyz/graphql | | Devnet| https://arweave.devnet.irys.xyz/graphql|",
  "origin": "docs"
},{
  "url": "/overview/networks",
  "title": "Networks",
  "description": "URLs for Irys' 3 nodes",
  "text": "NetworksIrys has two networks: mainnet and devnet.Mainnet Uploads to Irys' mainnet are stored permanently on Arweave. Your upload will remain accessible at all times, even if Irys is no longer available. Uploads of less than 100 KiB are free. Uploads can be paid for in any of the many tokens we support.Devnet Uploads to Irys' Devnet are kept for roughly 60 days. Devnet is for building and prototyping projects along with learning our SDK. Uploads can be paid for using free tokens available from faucets.Node URLs Most users will not need the direct node URLs as the SDK abstracts this away. If needed, you can use the following: https://arweave.mainnet.irys.xyz https://arweave.devnet.irys.xyzChain integrations Irys is multichain, supporting both paying for uploads with most popular tokens and signing the upload using that token’s cryptography. The signature type used to sign a transaction is tracked at the transaction-level.Connecting to Irys See our SDK docs for code samples showing how to connect to our mainnet and devnet.",
  "origin": "docs"
},{
  "url": "/overview/ordering",
  "title": "Ordering",
  "description": "Irys enables users to instantly sequence data with extreme precision.",
  "text": "OrderingIrys enables users to instantly sequence data with extreme precision.This supports applications that require a guarantee on order such as execution layers (rollups), messaging and event processing, among others. Proof of time Each transaction comes with a signed receipt that includes a verifiable timestamp, which is accurate to the millisecond. With this, users can always rely on the chronology of their data.Search seamlessly Tags categorize transactions. Timestamps order them. Together, tags and timestamps enable users to categorize and order their data to efficiently search for data with single queries.Getting started You can upload multiple transactions and sequence them using our SDK and query package in a few lines of code.Uploading // Connect and fund const irys = new Irys({ network, token, key }); const fundTx = await irys.fund(irys.utils.toAtomic(0.05)); // Tag your uploads const tags = [{ name: \"\"application-id\"\", value: \"\"my-tx-sequence\"\" }]; // Upload 10 transactions for (let i = 0; i < 10; i++) {const receipt = await irys.upload(\"\"GM \"\" + i, { tags: tags });console.log(Transaction #${i} uploaded at ${receipt.timestamp}); }Ordering const myQuery = new Query(); const results = await myQuery.search(\"\"irys:transactions\"\").tags([{ name: \"\"application-id\"\", values: [\"\"my-tx-sequence\"\"] }]).sort(\"\"ASC\"\").stream(); // Iterate over the results for await (const result of stream) {console.log(result); } `",
  "origin": "docs"
},{
  "url": "/overview/permanent-data",
  "title": "Permanent data",
  "description": "Permanence guarantees your data can be retrieved at any point in the future.",
  "text": "Permanent dataPermanence guarantees your data can be retrieved at any point in the future.Permanent data is fault-tolerant, tamperproof, and paid-for: Fault-tolerantData is stored so that it can survive unexpected events, including data corruption and loss. TamperproofStored data is immutable, it can’t be maliciously changed. Paid-forThe cost of storing the data permanently is covered up-front, and [there is a mechanism for paying miners on an acceptablecadence](/learn/transaction-lifecycle).Fault-tolerant Your data is replicated across multiple Arweave nodes. Current estimates show there are 781+ complete replicas of the data, ensuring that no number of failed drives or natural disasters can damage your data.Tamperproof Your data is identifiable by a unique identifier formed by hashing the upload. Every piece of data produces a distinct hash, even a minute change in the original content results in a completely different identifier. This makes it easy to verify and ensure that the stored data remains unaltered over time.Paid-for When you upload data you pay a single up-front fee. The upload fee is divided, 5% is paid to the miner who includes your transaction in a winning block, and 95% is reserved for future funding of storage via the Arweave endowment. The Arweave endowment uses the current cost of storage combined with a conservative estimate of how much storage costs decline year on year to ensure there are always enough funds available to pay miners for continued storage. Arweave has published simulations showing how the current endowment will last at least 10,000 years.How will this evolve? The Arweave endowment is based on current storage technology, their current cost and declining costs over time. The Arweave yellow-paper acknowledges that the most important thing is data permanence, not network permanence and at some point in the future when \"\"a permanent information storage system more suited to the challenges of the time emerges, the Arweave’s data will be ‘subsumed’ into this network.\"\"Why does permanent data matter? Permanence ensures the security of all data posted to Irys. No hostile party, not even a government, can alter this. It also enables composability. Chunks of permanent data can be used as primitives to power the next iteration of the internet, the permaweb. Irys enables a global dataset that will always be reliable and accessible.Getting started You can permanently upload data in 3 lines of code. // Connect and fund const irys = new Irys({ network, token, key }); const fundTx = await irys.fund(irys.utils.toAtomic(0.05)); // Upload data const receipt = await irys.uploadFile(\"\"./myImage.png\"\"); For full code examples, you can copy and paste into your projects, check out our SDK. If you are building a browser-based app, check out Irys in the browser, and the Provenance Toolkit, a suite of UI open-source UI components for managing node balances and uploading files. Our query package contains everything you need to search Irys transaction metadata. Beginners should start with our SDK tutorial.What can you build with permanent data? Learn more in our use-cases section.",
  "origin": "docs"
},{
  "url": "/overview/querying-tagging",
  "title": "Querying & tagging",
  "description": "Querying and tagging combine to allow you to build semi-relational data models",
  "text": "Querying & taggingUsers can add custom metadata tags to each upload, these tags allow users to build semi-relational data models, all instantly queryable.Tagging Irys supports attaching metadata tags to each transaction. Tags can be used to: Categorize transactions, making it easier to search for and retrieve relevant information using GraphQL Build mutable references Inform web browsers how to render image filesQuerying Contained within the transaction header is the metadata, this is available for querying via our query package and GraphQL.",
  "origin": "docs"
},{
  "url": "/overview/supported-tokens",
  "title": "Tokens",
  "description": "Pay for your upload with most popular tokens.",
  "text": "TokensIyrs supports most poppular tokens for paying for uploads.Mainnet tokens On Nodes 1 and 2 can pay for uploads in any of these tokens: | Token / Blockchain | Token | Parameter Value | Irys Support | WebIrys Support| | ------------------ | ----- | --------------- | -------------- | ------------------- | | Aptos| APT| aptos| yes| yes| | Algorand| ALGO| algorand| yes| no| | Arbitrum| ETH| arbitrum| yes| yes| | Arweave| AR| arweave| yes| yes (via Arconnect) | | Avalanche C-Chain| AVAX| avalanche| yes| yes| | Binance Coin| BNB| bnb| yes| yes| | Boba| BOBA| boba| yes| yes| | Boba-eth| ETH| boba-eth| yes| yes| | Chainlink| LINK| chainlink| yes| yes| | Ethereum| ETH| ethereum| yes| yes| | Base Ethereum| ETH| base-eth| yes| yes| | Fantom| FTM| fantom| yes| yes| | Near| NEAR| near| yes| yes| | Polygon| MATIC | matic| yes| yes| | Solana| SOL| solana| yes| yes| | USDC (on Ethereum) | USDC| usdc-eth| yes| yes| | USDC (on Polygon)| USDC| usdc-polygon| yes| yes|Devnet tokens On Devnet, you can pay for uploads in any of these tokens: | Token / Blockchain| Token | Parameter Value | Irys Support | WebIrys Support | | ----------------------- | ----- | --------------- | -------------- | ----------------- | | Aptos| APT| aptos| yes| yes| | Algorand| ALGO| algorand| yes| no| | Arbitrum| ETH| arbitrum| yes| yes| | Avalanche C-Chain| AVAX| avalanche| yes| yes| | Berachain| BERA| bera| yes| yes| | Binance Coin| BNB| bnb| yes| yes| | Chainlink| LINK| chainlink| yes| yes| | Ethereum (Sepolia)| ETH| ethereum| yes| yes| | Base Ethereum (Sepolia) | ETH| base-eth| yes| yes| | Near| NEAR| near| yes| yes| | Polygon (Mumbai)| MATIC | matic| yes| yes| | Solana| SOL| solana| yes| yes| | USDC (on Ethereum)| USDC| usdc-eth| yes| yes| | USDC (on Polygon)| USDC| usdc-polygon| yes| yes|Specifying token To use a different token, link your private key and supply the token name when creating a new Irys object. The accepted values for token are listed in the third column of the tables above. Example: const getIrys = async () => {const network = \"\"devnet\"\";// Devnet RPC URLs change often, use a recent one from https://chainlist.org/const providerUrl = \"\"\"\";const token = \"\"matic\"\";const irys = new Irys({network, // \"\"mainnet\"\" || \"\"devnet\"\"token, // Token used for paymentkey: process.env.PRIVATE_KEY, // ETH or SOL private keyconfig: { providerUrl }, // Optional provider URL, only required when using Devnet});return irys; }; `",
  "origin": "docs"
},{
  "url": "/overview/tools",
  "title": "Tools",
  "description": "Get started building with Irys today.",
  "text": "ToolsGet started building with Irys today.Irys SDK Permanent data with strong provenance using only three lines of code with our SDK. CLI Permanent data with strong provenance from your CLI. Provenance Toolkit Rapidly build your next project using our library of UI components. Irys query package Query Irys and Arweave transactions using our JavaScript package. Arweave packageA fork of arweave-js that introduces better typing, increased NodeJScompatibility, and better support for using streams.WhistleblowerA light client for monitoring Irys nodes and ensuring transactions are finalized on Arweave and seeded to miners.Explorer A transaction explorer and analytics platform for Irys. ",
  "origin": "docs"
},{
  "url": "/terminology",
  "title": "Terminology",
  "description": "",
  "text": " title: Terminology description: Technical terms to help you understand IrysTerminologyTechnical terms to help you understand IrysBundle | Bundler | Deep Hash | Provenance | Provenance Layer | Proto-provenance layer | Gateways | Optimistic finalization | Provenance | Transaction | Transaction ReceiptBundle A set of transactions joined into a single Arweave transaction.Bundler A node on Irys that receives transactions, handles payment channels and produces bundles.Deep Hash A hash algorithm that takes a nested list of values as input and produces a 384 bit hash, where a change of any value or the structure will affect the hash.Provenance The history of data. It can describe where data came from, how it was created, and who has handled it. Data provenance provides transparency into the lifecycle of data and is critical for building trust in the data.Gateways Nodes that listen to both bundlers and the Arweave L1 with the purpose of aggregating and indexing transactions. This allows you to retrieve and lookup transactions from clusters of bundlers without maintaining your own index.Optimistic finalization An incentive mechanism used by Irys to provide instant upload times. On Arweave, a block is considered confirmed after 50 block confirmations. Data is considered seeded after it is stored by a minimum number of miners. This can take up to 100 minutes. When you post a transaction to Irys, you are given a signed receipt. At this point, we can optimistically consider the transaction final because there is a greater financial incentive for nodes to behave honestly than there is for malicious behavior.Provenance The issuing of signed receipts, including a timestamp accurate to the millisecond, that provide irrefutable proof of data provenance.Provenance layer A ledger of record for digital information that tracks the origins and modifications of data. Data on a provenance layer must be permanent, precise, and unconstrained.Proto-provenance layer Previous projects that have provided degrees of provenance, but have fundamentally failed to be provenance layers. They fail to fulfill the Provenance Trilemma, by either not being permanent, precise or unconstrained.Provenance Trilemma A representation of the tradeoffs proto-provenance layers have had to make in the past. It describes the tradeoffs between data being permanent, precise, and unconstrained.Transaction A single item sent to a specific address, usually contains a data payload.Transaction Receipt A proof that an Iyrs transaction gets on to Arweave by an expected block. The transaction receipt format is.",
  "origin": "docs"
}
]