{"/404":{"title":"404","data":{"":"Oops, page not found!\n\nPlease try searching or use any of the links below!"}},"/developer-docs/cli/commands/balance":{"title":"balance","data":{"":"Returns the amount of funds available on the specified node. Provide your public wallet address as an argument, along with the following required paramters.Parameters\n\n\n-h: The node to check\n-t: The token to use when funding.\n--provider-url: RPC URL to use. This is only required when using Devnet.","examples#Examples":"","nodes-1-and-2#Nodes 1 and 2":"irys balance 0xac568a981b1370b2e1baa8ce30bd5ac9e28c572d \\\n-t matic \\\n-h https://node1.irys.xyz","devnet#Devnet":"irys balance 0x591B5Ce7cA10a55A9B5d1516eF89693D5b3586b8 \\\n-t matic \\\n-h https://devnet.irys.xyz \\\n--provider-url https://rpc-mumbai.maticvigil.com\n\nDevnet RPC URLs change often, use a recent one from https://chainlist.org/chain/80001"}},"/developer-docs/cli/commands/fund":{"title":"fund","data":{"":"Funds the Irys node you connected to with the specified amount of tokens. Fund the node you intend to upload to, funded balances are not shared between nodes.\nNot all calls to fund will post immediately to your account, some blockchains are faster than others. When funding with AR, it can take upwards of 40 minutes before the balance post. For MATIC, ETH and SOL, balances will usually post in < 10s.\nParameters\n\n\n-h: The node to fund\n-t: The token to use when funding.\n-w: Your private key.\n--provider-url: RPC URL to use. This is only required when using Devnet.","examples#Examples":"","nodes-1-and-2#Nodes 1 and 2":"irys fund 1000000000000000 \\\n-h https://node1.irys.xyz \\\n-t matic \\\n-w bf20......c9885307","devnet#Devnet":"irys fund 1000000000000000 \\\n-h https://devnet.irys.xyz \\\n-t matic \\\n-w bf20......c9885307 \\\n--provider-url https://rpc-mumbai.maticvigil.com\n\nDevnet RPC URLs change often, use a recent one from https://chainlist.org/chain/80001"}},"/developer-docs/cli":{"title":"CLI","data":{"":"CLI\nPermanently store files on Arweave using Irys' Command Line Interface (CLI).","prerequisites#Prerequisites":"To install our CLI, you will need to install a current version of node first.","installing-the-cli#Installing the CLI":"Install our CLI globally using the -g flag. Depending on your setup, you may or may not need to use sudo.\nnpm i -g @irys/sdk\nsudo npm i -g @irys/sdk","using-private-keys#Using private keys":"When executing CLI commands involving funding nodes or signing transactions, you must provide a private key.Use the -w flag to specify a private key along with the -c flag to indicate the token you'll use.\nirys -w <wallet-file-name> -t <token>\nThe methods for supplying private keys differ for Ethereum and Solana compared to Arweave.","ethereum--solana#Ethereum / Solana":"For Ethereum and Solana, specify the private key directly in the command line every time you execute a CLI command. Note that the CLI does not store the private key, it needs to be included with each command.\nirys fund 1000000000000000 -t matic -w bf20......c9885307 -h https://node1.irys.xyz","arweave#Arweave":"When using Arweave, the private key is typically stored in a file (commonly named wallet.json). This file is then referenced in the CLI command, instead of specifying the private key directly.\nirys fund 1000000000000000 -t arweave -w wallet.json -h https://node1.irys.xyz","nodes#Nodes":"Fund the Node you plan to upload to, balances are not shared between Nodes. You can connect to Nodes 1 and 2 directly.\nirys -h https://node1.irys.xyz\nWhen connecting to Devnet, you must supply the additional --provider-url parameter.\nirys -h https://devnet.irys.xyz --provider-url https://rpc-mumbai.maticvigil.com\n\nDevnet RPC URLs change often, use a recent one from https://chainlist.org/chain/80001","funding#Funding":"Use the fund command to fund a node.\nirys fund 1000000000000000 -h https://node1.irys.xyz -t matic -w bf20......c9885307","withdrawing-funds#Withdrawing funds":"Use the withdraw command to withdraw funds from a node.\nirys withdraw 1000000000000000 -h https://node1.irys.xyz -t matic -w bf20......c9885307","uploading-a-file#Uploading a file":"Use the upload command to upload a file.\nirys upload myImage.png -h https://node1.irys.xyz -t matic -w bf20......c9885307","uploading-a-folder#Uploading a folder":"Use the upload-dir command to upload a folder.\nirys upload-dir ./myImages -h https://node1.irys.xyz -t matic -w bf20......c9885307","using-tags#Using tags":"Use the -t option, followed by a series of name / value pairs to append metadata tags to your upload.Irys supports adding any optional metadata tags to each upload. When uploading files with a filename extension, the related Content-Type (MIME type) tag is automatically added.\nirys upload myImage.png -t tagName1 tagValue1 tagName2 tagValue2 -h https://node1.irys.xyz -t matic -w bf20......c9885307","pricing#Pricing":"Use the price command, followed by a number of bytes to get the cost to upload that number of bytes. You must also provide a token (-t) and a node URL (-h)\nirys price 1000000 -t matic -h https://node1.irys.xyz"}},"/developer-docs/cli/commands/price":{"title":"price","data":{"":"Checks the price to upload the specified number of bytes.Parameters\n\n\n-t: The token used for payment.\n-h: URL of the node you will upload to.\n--provider-url: RPC URL to use. This is only required when using Devnet.","examples#Examples":"","nodes-1-and-2#Nodes 1 and 2":"irys price 1000000 \\\n-t matic \\\n-h https://node1.irys.xyz","devnet#Devnet":"irys price 1000000 \\\n-t matic \\\n-h https://devnet.irys.xyz \\\n--provider-url https://rpc-mumbai.maticvigil.com\n\nDevnet RPC URLs change often, use a recent one from https://chainlist.org/chain/80001"}},"/developer-docs/cli/commands/upload":{"title":"upload","data":{"":"Uploads a single file.Parameters\n\n\n-h: The you'll node upload to\n-t: The token to use when uploading.\n-w: Your private key.\n--tags: Tags to include, format <name> <value>\n--provider-url: RPC URL to use. This is only required when using Devnet.","examples#Examples":"","nodes-1-and-2#Nodes 1 and 2":"irys upload myImage.png \\\n-h https://node1.irys.xyz \\\n-t matic \\\n-w bf20......c9885307 \\\n--tags tagName1 tagValue1 tagName2 tagValue2","devnet#Devnet":"irys upload myImage.png \\\n-h https://devnet.irys.xyz \\\n-t matic \\\n-w bf20......c9885307 \\\n--tags tagName1 tagValue1 tagName2 tagValue2 \\\n--provider-url https://rpc-mumbai.maticvigil.com\n\nDevnet RPC URLs change often, use a recent one from https://chainlist.org/chain/80001","downloading#Downloading":"Files uploaded via irys upload can be downloaded using the transaction ID provided after a successful upload.\nirys upload myImage.png \\\n-h https://node1.irys.xyz \\\n-t matic \\\n-w bf20......c9885307 \\\n--tags tagName1 tagValue1 tagName2 tagValue2\n\nLoaded address: 0xac568a981b1370b2e1baa8ce30bd5ac9e28c572d\nUploaded to https://gateway.irys.xyz/yPX6_rwxfJ_2gTvXSHGoumIvlFR-EwuRlUMmHpeLHUM"}},"/developer-docs/cli/commands/upload-dir":{"title":"upload-dir","data":{"":"Uploads an entire directory of files.Parameters\n\n\n-h: The you'll node upload to\n-t: The token to use when uploading.\n-w: Your private key.\n--index-file: Name of the file to use as an index for manifests.\n--provider-url: RPC URL to use. This is only required when using Devnet.","examples#Examples":"","nodes-1-and-2#Nodes 1 and 2":"irys upload-dir ./myImages \\\n-h https://node1.irys.xyz \\\n-t matic \\\n-w bf20......c9885307","devnet#Devnet":"irys upload-dir ./myImages \\\n-h https://devnet.irys.xyz \\\n-t matic \\\n-w bf20......c9885307 \\\n--provider-url https://rpc-mumbai.maticvigil.com\n\nDevnet RPC URLs change often, use a recent one from https://chainlist.org/chain/80001","downloading#Downloading":"Files uploaded via irys upload-dir can be retrieved in one of two ways.\nCreating a URL with the format https://gateway.irys.xyz/[manifest-id]/[original-file-name].\nCreating a URL using the transaction ID of each individual file uploaded with the format https://gateway.irys.xyz/[transacton-id]\n\nAfter a successful folder upload, two files are written to your local project directory:\n[folder_name].csv\n[folder_name].json\n\nThe example below highlights a folder called “llama_folder” with a total of 5 files in it. The transaction id for each file can be used to retrieve the uploaded data by forming a URL with the format https://gateway.irys.xyz]/[transaction-id]"}},"/developer-docs/cli/commands/withdraw":{"title":"withdraw","data":{"":"Withdraws funds from specified Irys node.\nNot all calls to withdraw will post immediately to your account, some blockchains are faster than others. When funding with AR, it can take upwards of 40 minutes before the balance post. For MATIC, ETH and SOL, balances will usually post in < 10s.\nParameters\n\n\n-h: The node to withdraw funds from\n-t: The token to withdraw.\n-w: Your private key.\n--provider-url: RPC URL to use. This is only required when using Devnet.","examples#Examples":"","nodes-1-and-2#Nodes 1 and 2":"irys withdraw 1000000000000000 \\\n-h https://node1.irys.xyz \\\n-t matic \\\n-w bf20......c9885307","devnet#Devnet":"irys withdraw 1000000000000000 \\\n-h https://devnet.irys.xyz \\\n-t matic \\\n-w bf20......c9885307 \\\n--provider-url https://rpc-mumbai.maticvigil.com\n\nDevnet RPC URLs change often, use a recent one from https://chainlist.org/chain/80001"}},"/developer-docs/downloading":{"title":"Downloading data","data":{"":"Once data is uploaded to Irys, it becomes instantly accessible through gateways, which work hand in hand with our optimistic cache. To download data, use the transaction id to query the relevant gateway.There are multiple gateways, including those running open source software that can be spun up by anyone. Here are examples of how to use the two most common ones.","irys-gateway#Irys gateway":"","url-format#URL format":"https://gateway.irys.xyz/[transaction-id]","example#Example":"https://gateway.irys.xyz/CO9EpX0lekJEfXUOeXncUmMuG8eEp5WJHXl9U9yZUYA","arweave-gateway#Arweave gateway":"","url-format-1#URL format":"https://arweave.net/[transaction-id]","example-1#Example":"https://arweave.net/CO9EpX0lekJEfXUOeXncUmMuG8eEp5WJHXl9U9yZUYA"}},"/developer-docs/cli/installation":{"title":"Installation","data":{"":"Install using npm with the -g global flag. Depending on your setup, you may need to use the sudo command.\nnpm i -g @irys/sdk\nsudo npm i -g @irys/sdk"}},"/developer-docs/irys-sdk/api/fund":{"title":"irys.fund(amount)","data":{"":"Funds the Irys node you connected to with the specified amount of tokens. Fund the node you intend to upload to, funded balances are not shared between nodes.For more information on how funding and withdrawing are handled, see our docs.Parameters\n\n\namount: The amount to fund (in atomic\nunits)\nmultiplier: Fee multiplier (optional)\n\nReturns\n\n\nresponse: A JSON object with the following values\n\n\nresponse = {\nid, // The transaction id of the fund transfer\nquantity, // How much is being transferred\nreward, // The amount taken by the network as a fee\ntarget, // The address the funds were sent to\n};","upfront-funding#Upfront funding":"You can up-front fund a node, where you send over enough funds to cover all of a project’s uploads. When upfront funding, you may want to write a script to monitor your stored balance, topping up when needed.\ntry {\nconst irys = await getIrys();\n\nconst fundTx = await irys.fund(irys.utils.toAtomic(0.05));\nconsole.log(`Successfully funded ${irys.utils.fromAtomic(fundTx.quantity)} ${irys.token}`);\n} catch (e) {\nconsole.log(\"Error funding node \", e);\n}","lazy-funding#Lazy-funding":"You can also lazy-fund a node where you check the cost to upload each file first and then transfer exact funds. This works best with currencies like MATIC, ETH and SOL whose balances post (almost) instantly.\ntry {\nconst irys = await getIrys();\n\nconst pathToFile = \"./llama.png\";\nconst { size } = await fs.promises.stat(pathToFile);\nconst price = await irys.getPrice(size);\nawait irys.fund(price);\n\nconst { id } = await irys.uploadFile(pathToFile);\nconsole.log(`${pathToFile} --> Uploaded to https://gateway.irys.xyz/${id}`);\n} catch (e) {\nconsole.log(\"Error funding node \", e);\n}\n\nNot all calls to irys.fund() will post immediately to your account, some blockchains are faster than others. When funding with AR, it can take upwards of 40 minutes before the balance post. For MATIC, ETH and SOL, balances will usually post in < 10s.","fee-multiplier#Fee multiplier":"The multiplier parameter multiplies the fees we allow the network to take, in effect prioritising the transaction. Normally you can safely ignore this parameter, however if you're experiencing errors when funding, you can try passing a value of 1.2 or more.\ntry {\nconst irys = await getIrys();\n\nconst fundTx = await irys.fund(irys.utils.toAtomic(0.05), 1.2);\nconsole.log(`Successfully funded ${irys.utils.fromAtomic(fundTx.quantity)} ${irys.token}`);\n} catch (e) {\nconsole.log(\"Error funding node \", e);\n}","paid-rpcs#Paid RPCs":"When transferring tokens we use public RPCs. Sometimes these can be slow to confirm transactions. If you're experiencing an error when funding, consider using a paid RPC.\nconst url = \"https://devnet.irys.xyz\";\nconst providerUrl = \"\"; // Paid RPC URL\nconst currency = \"matic\";\nconst privateKey = process.env.PRIVATE_KEY;\n\nconst irys = new Irys({\nurl: url, // URL of the node you want to connect to\ncurrency: currency, // Currency used for payment\nkey: privateKey, // ETH or SOL private key\nconfig: { providerUrl },\n});"}},"/developer-docs/irys-sdk":{"title":"Irys Sdk","data":{"":"","installing#Installing":"Install using npm:\nnpm install @irys/sdk\nor yarn:\nyarn add @irys/sdk\n\nIf you get a warning saying bigint: Failed to load bindings, pure JS will be used (try npm run rebuild?) during\ninstall, it can be safely ignored. For details on how make it go away, see our troubleshooting\nguide.","importing#Importing":"import Irys from \"@irys/sdk\";","connecting-to-a-node#Connecting to a node":"Connect to any of our three nodes, using a serialized JWK file when using an Arweave wallet:\nconst getIrysArweave = async () => {\nconst url = \"https://devnet.irys.xyz\";\nconst token = \"arweave\";\nconst key = JSON.parse(fs.readFileSync(\"arweaveWallet.json\").toString());\n\nconst irys = new Irys({\nurl, // URL of the node you want to connect to\ntoken, // Token used for payment and signing\nkey, // Arweave wallet\n});\nreturn irys;\n};\nOr a private key when using an EVM or Solana wallet:\nconst getIrys = async () => {\nconst url = \"https://devnet.irys.xyz\";\n// Devnet RPC URLs change often, use a recent one from https://chainlist.org/chain/80001\nconst providerUrl = \"\";\nconst token = \"matic\";\n\nconst irys = new Irys({\nurl, // URL of the node you want to connect to\ntoken, // Token used for payment\nkey: process.env.PRIVATE_KEY, // ETH or SOL private key\nconfig: { providerUrl }, // Optional provider URL, only required when using Devnet\n});\nreturn irys;\n};","funding-a-node#Funding a node":"Fund a node using any of our supported tokens:\nconst fundNode = async () => {\nconst irys = await getIrys();\ntry {\nconst fundTx = await irys.fund(irys.utils.toAtomic(0.05));\nconsole.log(`Successfully funded ${irys.utils.fromAtomic(fundTx.quantity)} ${irys.token}`);\n} catch (e) {\nconsole.log(\"Error uploading data \", e);\n}\n};","uploading#Uploading":"Data uploaded to Irys is given a millisecond-accurate timestamp, attributes and authorship details before being passed to Arweave for permanent storage. This information is used to create a signed receipt that can be used to verify the data's provenance at any time.","uploading-data#Uploading data":"const uploadData = async () => {\nconst irys = await getIrys();\nconst dataToUpload = \"GM world.\";\ntry {\nconst receipt = await irys.upload(dataToUpload);\nconsole.log(`Data uploaded ==> https://gateway.irys.xyz/${receipt.id}`);\n} catch (e) {\nconsole.log(\"Error uploading data \", e);\n}\n};","uploading-a-file#Uploading a file":"const uploadFile = async () => {\nconst irys = await getIrys();\n// Your file\nconst fileToUpload = \"./myImage.png\";\n\nconst tags = [{ name: \"application-id\", value: \"MyNFTDrop\" }];\n\ntry {\nconst receipt = await irys.uploadFile(fileToUpload, { tags });\nconsole.log(`File uploaded ==> https://gateway.irys.xyz/${receipt.id}`);\n} catch (e) {\nconsole.log(\"Error uploading file \", e);\n}\n};","uploading-a-folder#Uploading a folder":"You can upload a group of files as a single transaction from both the server and the browser.\nWhen uploading a folder, files can be accessed either directly at\nhttps://gateway.irys.xyz/[transaction-id] or https://gateway.irys.xyz/[manifest-id]/[file-name]","server#Server":"const uploadFolder = async () => {\nconst irys = await getIrys();\n\n// Upload an entire folder\nconst folderToUpload = \"./my-images/\"; // Path to folder\ntry {\nconst receipt = await irys.uploadFolder(\"./\" + folderToUpload, {\nindexFile: \"\", // optional index file (file the user will load when accessing the manifest)\nbatchSize: 50, //number of items to upload at once\nkeepDeleted: false, // whether to keep now deleted items from previous uploads\n}); //returns the manifest ID\n\nconsole.log(`Files uploaded. Manifest ID ${receipt.id}`);\n} catch (e) {\nconsole.log(\"Error uploading file \", e);\n}\n};","browser#Browser":"const webIrys = await getWebIrys();\n\nconst files: File[] = [];\nconst tags: { name: string; value: string }[][] = [];\n\n// Convert Files to TaggedFiles\nconst taggedFiles = files.map((f: TaggedFile, i: number) => {\nf.tags = tags[i];\nreturn f;\n});\n\nconst response = await webIrys.uploadFolder(taggedFiles);","querying#Querying":"In addition to using the query package to search Irys and Arweave, you can also search directly from the Irys SDK. The following shows how to search for all transactions posted to Node 1, paid for with Matic, and uploaded during a three day period.For more details on all search functions, see query package documentation.\nconst result = await irys\n.search(\"irys:transactions\")\n.url(\"https://node1.irys.xyz/graphql\")\n.token(\"matic\")\n.fromTimestamp(new Date(\"2023-07-01\"))\n.toTimestamp(new Date(\"2023-07-03\"));","3rd-party-build-tools#3rd party build tools":"","parcel#Parcel":"If using Parcel, you will need to manually enable package exports by adding the following to the package.json file in your project root directory.\n{\n\"@parcel/resolver-default\": {\n\"packageExports\": true\n}\n}"}},"/developer-docs/irys-sdk/api/getPrice":{"title":"irys.getPrice(numBytes)","data":{"":"Returns the cost to upload the specified number of bytes.Parameters- numBytes: The number of bytes to check the price forReturns\n\n\nprice: Cost to upload numBytes. Token is the token specified when connecting to the node.\nReturn value is in atomic units, to convert to standard units use irys.utils.fromAtomic()\n\nExample\nconst irys = await getIrys();\n\nconst numBytes = 1048576; // Number of bytes to check\nconst priceAtomic = await irys.getPrice(numBytes);\n\n// Convert from atomic units to standard units\nconst priceConverted = irys.utils.fromAtomic(numBytes);\n\nconsole.log(`Uploading ${numBytes} bytes costs ${priceConverted}`);"}},"/developer-docs/irys-sdk/api/getLoadedBalance":{"title":"irys.getLoadedBalance()","data":{"":"Returns the connected wallet's balance on the connected node.Returns- loadedBalance: Wallet balance on the connected node in atomic units. You can convert it\ninto standard units using irys.utils.fromAtomic(atomicUnits).Example\nconst irys = await getIrys();\n\n// Get loaded balance in atomic units\nconst atomicBalance = await irys.getLoadedBalance();\nconsole.log(`Node balance (atomic units) = ${atomicBalance}`);\n\n// Convert balance to standard\nconst convertedBalance = irys.utils.fromAtomic(atomicBalance);\nconsole.log(`Node balance (converted) = ${convertedBalance}`);\n\nBalances are not shared between nodes, each node maintains its own ledger of user\nbalances."}},"/developer-docs/irys-sdk/api/uploadFile":{"title":"irys.uploadFile(fileName, tags)","data":{"":"Permanently uploads a file.Parameters\n\n\nfileName: Name of the file to upload\ntags: Optional metatags\n\nReturns\n\n\nreceipt: A receipt in the form of a JSON object with the following values:\n\n\nresponse = {\nid, // Transaction id (used to download the data)\ntimestamp, // Timestamp (UNIX milliseconds) of when the transaction was created and verified\nversion, // The version of this JSON file, currently 1.0.0\npublic, // Public key of the bundler node used\nsignature, // A signed deep hash of the JSON receipt\ndeadlineHeight, // The block number by which the transaction must be finalized on Arweave\nblock, // Deprecated\nvalidatorSignatures, // Deprecated\nverify, // An async function used to verify the receipt at any time\n}\nExample\nconst irys = await getIrys();\n\n// Your file\nconst fileToUpload = \"./myImage.png\";\n\n// Add a custom tag that tells the gateway how to serve this file to a browser\nconst tags = [{ name: \"Content-Type\", value: \"image/png\" }];\n\ntry {\nconst response = await irys.uploadFile(fileToUpload, tags);\nconsole.log(`File uploaded ==> https://gateway.irys.xyz/${response.id}`);\n} catch (e) {\nconsole.log(\"Error uploading file \", e);\n}\n\nThe transaction id returned as part of the response is used to download the data, simply create a URL with the\nformat https://gateway.irys.xyz/[transaction-id]."}},"/developer-docs/irys-sdk/api/upload":{"title":"irys.upload(data, tags)","data":{"":"Permanently uploads data.Parameters\n\n\ndata: The data to upload\ntags: Optional metatags\n\nReturns- receipt: A receipt in the form of a JSON object with the following values:\nresponse = {\nid, // Transaction id (used to download the data)\ntimestamp, // Timestamp (UNIX milliseconds) of when the transaction was created and verified\nversion, // The version of this JSON file, currently 1.0.0\npublic, // Public key of the bundler node used\nsignature, // A signed deep hash of the JSON receipt\ndeadlineHeight, // The block number by which the transaction must be finalized on Arweave\nblock, // Deprecated\nvalidatorSignatures, // Deprecated\nverify, // An async function used to verify the receipt at any time\n}\nExample\nconst irys = await getIrys();\n\nconst dataToUpload = \"GM world.\";\ntry {\nconst receipt = await irys.upload(dataToUpload);\nconsole.log(`Data uploaded ==> https://gateway.irys.xyz/${receipt.id}`);\n} catch (e) {\nconsole.log(\"Error uploading data \", e);\n}\n\nThe transaction id returned as part of the response is used to download the data, simply create a URL with the\nformat https://gateway.irys.xyz/[transaction-id]."}},"/developer-docs/irys-sdk/api/funder-submitFundTransaction":{"title":"irys.funder.submitFundTransaction(txID)","data":{"":"Tells a node to re-evaluate a funding transaction.Parameters- txID: The ID of the funding transaction to re-evaluate.Returns\n\n\nresponse: A JSON object with the following values\n\n\nresponse = {\nid, // The transaction id of the fund transfer\nquantity, // How much is being transferred\nreward, // The amount taken by the network as a fee\ntarget, // The address the funds were sent to\n};\nExample\nconst irys = await getIrys();\n\ntry {\n// First get a receipt\nconst fundTx = await irys.fund(irys.utils.toAtomic(0.05));\nconst response = await irys.funder.submitFundTransaction(fundTx.id);\n\n} catch (e) {\nconsole.log(\"Error funding \", e);\n}"}},"/developer-docs/irys-sdk/api/uploadFolder":{"title":"uploadFolder()","data":{"":"Permanently uploads a group of files in a single transaction.When using the method on the server (Irys), you provide the path to a folder which is then uploaded. When using the method in the browser (WebIrys), you pass an array of File objects that are then uploaded.\nIrys\nWebIrys","irysuploadfolder#irys.uploadFolder()":"Parameters\n\n\nfolderToUpload: Path to the folder being uploaded\nindexFile: (optional) The name of an\nindex file also included in the folder you upload. If provided, this index file will load when a user requests\nhttps://gateway.irys.xyz/[manifest_id]\nbatchSize: (optional) The number of files to upload at once.\nkeepDeleted: (optional) Whether to keep now deleted items from previous uploads. When you upload a folder, the file names are indexed and saved. If you then re-upload that same folder, Irys will only upload new files added since the previous upload. In the case where you delete files from your source directory, this flag tells Irys whether to keep those deleted files in the index or remove them.\n\nReturns\n\n\nresponse: A JSON object with the following values\n\n\n{\nid, // Transaction id (used to download the data)\ntimestamp, // Timestamp (UNIX milliseconds) of when the transaction was created and verified\nversion, // The version of this JSON file, currently 1.0.0\npublic, // Public key of the bundler node used\nsignature, // A signed deep hash of the JSON receipt\ndeadlineHeight, // The block number by which the transaction must be finalized on Arweave\nblock, // Deprecated\nvalidatorSignatures, // Deprecated\nverify, // An async function used to verify the receipt at any time\n}\nExample\nconst irys = await getIrys();\n\n// Upload an entire folder\nconst folderToUpload = \"./my-images/\"; // Path to folder\ntry {\nconst response = await irys.uploadFolder(\"./\" + folderToUpload, {\nindexFile: \"\", // Optional index file (file the user will load when accessing the manifest)\nbatchSize: 50, // Number of items to upload at once\nkeepDeleted: false, // Whether to keep now deleted items from previous uploads\n});\n\nconsole.log(`Files uploaded. Manifest ID ${response.id}`);\n} catch (e) {\nconsole.log(\"Error uploading file \", e);\n}","webirysuploadfolder#webIrys.uploadFolder()":"Parameters\n\n\nfiles: An array of TaggedFile objects, each containing a File and an array of tags to be added to that file\nindexFileRelPath: (optional) The name of an\nindex file also included in the folder you upload. If provided, this index file will load when a user requests\nhttps://gateway.irys.xyz/[manifest_id]\nthrowawayKey: (optional) Your own throwaway JWK to use for signing (i.e if you want to use the same one for more than one set of uploads).\nseperateManifestTx: (optional) If true, the manifest transaction will be excluded from the bundle making its tags indexable and queryable.\n\nReturns\n\n\nmanifest: A JSON object with the following values\n\n\n{\nid, // Manifest ID\ntimestamp, // Timestamp (UNIX milliseconds) of when the transaction was created and verified\nversion, // The version of this JSON file, currently 1.0.0\npublic, // Public key of the bundler node used\nsignature, // A signed deep hash of the JSON receipt\ndeadlineHeight, // The block number by which the transaction must be finalized on Arweave\nblock, // Deprecated\nvalidatorSignatures, // Deprecated\nverify, // An async function used to verify the receipt at any time\n}\nExample\nconst webIrys = await getWebIrys();\n\nconst files: File[] = [];\nconst tags: { name: string; value: string }[][] = [];\n\n// Set files and tags in your UI\n\n// Convert to TaggedFile objects\nconst taggedFiles = files.map((f: TaggedFile, i: number) => {\nf.tags = tags[i];\nreturn f;\n});\n\n// Optional parameters\nconst uploadOptions = {\nindexFileRelPath: \"./index.html\",\nmanifestTags: myTags,\nthrowawayKey: myKey,\nseperateManifestTx: true,\n};\nconst response = await webIrys.uploadFolder(taggedFiles, uploadOptions);\nReturnsA JSON object containing the following values. A receipt is also generated which can be retrieved using irys.utils.getReceipt(response.id)\n{\nid, // Transaction ID\nmanifestId, // Manifest ID\nmanifest, // The manifest\ntxs, // An array of DataItems, one for each entry in the bundle\ntimestamp, // Timestamp (UNIX milliseconds) of when the transaction was created and verified\nversion, // The version of this JSON file, currently 1.0.0\npublic, // Public key of the bundler node used\nsignature, // A signed deep hash of the JSON receipt\ndeadlineHeight, // The block number by which the transaction must be finalized on Arweave\nblock, // Deprecated\nvalidatorSignatures, // Deprecated\nverify, // An async function used to verify the receipt at any time\n}","downloading#Downloading":"Files uploaded via uploadFolder() can be retrieved in one of two ways.\nCreating a URL with the format https://gateway.irys.xyz/[manifest-id]/[original-file-name].\nCreating a URL using the transaction ID of each individual file uploaded with the format https://gateway.irys.xyz/[transacton-id]\n\nAfter a successful folder upload, two files are written to your local project directory [folder_name].csv and [folder_name].json. The example below highlights a folder called “llama_folder” with a total of 5 files in it. The transaction id for each file can be used to retrieve the uploaded data by forming a URL with the format https://gateway.irys.xyz]/[transaction-id]"}},"/developer-docs/irys-sdk/api/utils-getReceipt":{"title":"irys.utils.getReceipt(trasnactionId)","data":{"":"Returns the receipt associated with the supplied transaction id, or an error if no receipt is found.Parameters\n\n\ntransactionId: The transaction ID associated with the receipt\n\nReturns\n\n\nresponse: A JSON object with the following values\n\n\nresponse = {\nid, // Transaction id (used to download the data)\ntimestamp, // Timestamp (UNIX milliseconds) of when the transaction was created and verified\nversion, // The version of this JSON file, currently 1.0.0\npublic, // Public key of the bundler node used\nsignature, // A signed deep hash of the JSON receipt\ndeadlineHeight, // The block number by which the transaction must be finalized on Arweave\nblock, // Deprecated\nvalidatorSignatures, // Deprecated\nverify, // An async function used to verify the receipt at any time\n}\nExample\nconst irys = await getIrys();\n\ntry {\nconst transactionID = \"i9tgbHsr6c1sxryAQ-SLM2rfQAYRuyap7RmGgH28mI4\"; // Your transaction Id\nconst receipt = await irys.utils.getReceipt(transactionID);\nconsole.log(receipt);\n} catch (e) {\nconsole.log(\"Error getting receipt \", e);\n}"}},"/developer-docs/irys-sdk/api/utils-fromAtomic":{"title":"irys.utils.fromAtomic(value)","data":{"":"Converts from atomic to standard units.Parameters\n\n\nvalue: The value to be converted\n\nReturns\n\n\nstandardValue: The value in standard units\n\nExample\nconst irys = await getIrys();\n\nconst atomicBalance = await irys.getLoadedBalance();\nconst convertedBalance = irys.utils.fromAtomic(atomicBalance).toString();\n\nAtomic units refer to the smallest possible unit of a given cryptocurrency. In Ethereum, atomic units are called\nWei, and they represent the smallest unit of Ether. Similar to how 1 dollar can be broken down into 100 cents, 1\nEther can be broken down into 10^18 Wei. In Solana, atomic units are called Lamports, 1 SOL can be broken down into\n10^9 Lamports."}},"/developer-docs/irys-sdk/api/utils-toAtomic":{"title":"irys.utils.toAtomic(value)","data":{"":"Converts from standard to atomic units.Parameters- value: The value to be convertedReturns\n\n\natomicValue: The value in atomic units\n\nExample\nconst irys = await getIrys();\n\nconst amountAtomic = irys.utils.toAtomic(amountStandard);\n\nAtomic units refer to the smallest possible unit of a given cryptocurrency. In Ethereum, atomic units are called\nWei, and they represent the smallest unit of Ether. Similar to how 1 dollar can be broken down into 100 cents, 1\nEther can be broken down into 10^18 Wei. In Solana, atomic units are called Lamports, 1 SOL can be broken down into\n10^9 Lamports."}},"/developer-docs/irys-sdk/api/utils-verifyReceipt":{"title":"irys.utils.verifyReceipt(receipt)","data":{"":"Returns true or false, indicating if a receipt is valid or not.Parameters- receipt: The receipt as a JSON object in the following format\n{\nid, // Transaction id\npublic, // Public key of the bundler node used\nsignature, // A signed deep hash of the JSON receipt\ndeadlineHeight, // The block number by which the transaction must be finalized on Arweave\ntimestamp, // Timestamp (UNIX milliseconds) of when the transaction was created and verified\nversion, // The version of this JSON file, currently 1.0.0\n}\nReturns\n\n\nisValid: A true or false value indicating if the receipt is valid\n\nExample\nconst irys = await getIrys();\n\ntry {\n// First get a receipt\nconst transactionID = \"i9tgbHsr6c1sxryAQ-SLM2rfQAYRuyap7RmGgH28mI4\"; // Your transaction Id\nconst receipt = await irys.utils.getReceipt(transactionID);\n\n// Then verify it\nconst isReceiptValid = await irys.utils.verifyReceipt(receipt);\nconsole.log(isReceiptValid);\n} catch (e) {\nconsole.log(\"Error getting receipt \", e);\n}"}},"/developer-docs/irys-sdk/chunked-uploader":{"title":"Chunked uploader","data":{"":"The chunked uploader is a fault-tolerant, resumable, stream-based signer and uploader. It allows you to pause and resume uploads, and to do things like create progress bars that show upload progress.The chunked uploader is supported both with Irys / NodeJS on the server and with WebIrys in the browser.\nKey Terminology:\nBatch size - the maximum number of chunks to upload at once. Defaults to 5.\nChunk size - the maximum size of a single chunk. Defaults to 25MB. For those with slower/unstable connections, reducing both should lead to improved reliability. For those with faster connections, increasing both will lead to higher throughput, at the cost of more memory (and CPU).\n\n\nThe default uploder (accessed via irys.upload()) does chunking automatically. You only need to use the Chunked\nUploader to access advanced features like pausing and resuming uploads, changing batch size, and changing chunk\nsize."}},"/developer-docs/irys-sdk/chunked-uploader/connecting-node":{"title":"Connecting to a node","data":{"":"When using the chunking uploader, first connect to a node using the same flow as with our default uploader and then follow that by requesting the chunked uploader using irys.uploader.chunkedUploader.You can use any of our public and Devnet node addresses.\nThe chunkedUploader object reference must be updated before each subsequent upload, it can not be reused.\n\nlet irys = await getIrys();\n\nlet uploader = irys.uploader.chunkedUploader;"}},"/developer-docs/irys-sdk/chunked-uploader/data-mode":{"title":"Data mode","data":{"":"The chunked uploader has two modes of operation, data mode and transaction mode. When using data mode do not create a transaction, this will be done automatically for you.Within data mode, you can either upload using:\nA buffer containing the data you want to upload.\nA readable stream pointing to the data you want to upload.","uploaderuploaddata#uploader.uploadData()":"// The uploader has two modes of operation, data mode and transaction mode.\n// When using data mode, do not create a transaction, this will be done\n// automatically for you.\nconst transactionOptions = { tags: [{ name: \"Content-Type\", value: \"text/plain\" }] };\n// Within data mode you have two options:\n// 1. Using a Buffer containing just the data you want to upload.\nconst dataBuffer = Buffer.from(\"Hello, world!\");\nconst response = await uploader.uploadData(dataBuffer, transactionOptions);\n// The transaction id (used to query the network) is found in response.data.id\nconsole.log(`Data buffer uploaded ==> https://gateway.irys.xyz/${response.data.id}`);\n\n// 2. Using a Readable (stream) pointing to the data\nuploader = irys.uploader.chunkedUploader; // recreate for each transaction\nconst dataStream = fs.createReadStream(\"./data.txt\");\nresponse = await uploader.uploadData(dataStream, transactionOptions);\nconsole.log(`Read Stream uploaded ==> https://gateway.irys.xyz/${response.data.id}`);"}},"/developer-docs/irys-sdk/api/withdrawBalance":{"title":"irys.withdrawBalance(amount)","data":{"":"Withdraws the supplied amount. The parameter value must in atomic units.Parameters- amount: The amount to withdraw. Value must be in atomic units.Returns\n\n\nresponse: Either a 400 or 200 code, combined with the following values:\n\n\n400 - something went wrong\nresponse.data = \"Not enough balance for requested withdrawal\"\n\n200 - Ok\nresponse.data = {\nrequested, // the requested amount,\nfee, // the reward required by the network (network fee)\nfinal, // total cost to your account (requested + fee)\ntx-id, // the ID of the withdrawal transaction\n}\nExample\nconst irys = await getIrys();\n\ntry {\n// 1. Get current balance\nconst curBalance = await irys.getLoadedBalance();\n// 2. Withdraw all\nconst response = await irys.withdrawBalance(curBalance);\nconsole.log(`Successfully withdrew ${irys.utils.fromAtomic(curBalance)} ${irys.token}`);\n} catch (e) {\nconsole.log(\"Error uploading data \", e);\n}"}},"/developer-docs/irys-sdk/chunked-uploader/expired-uploads":{"title":"Expired uploads","data":{"":"Paused uploads will expire after a period of inactivity. If you do need to recover an expired upload, use the following:\nconst resumeData = uploader.getResumeData(); // get the data required to resume the upload with a new instance\nuploader.setResumeData(resumeData); // set resume data\nawait uploader.uploadTransaction(dataItem); // upload as normal"}},"/developer-docs/irys-sdk/chunked-uploader/setting-upload-parameters":{"title":"Setting upload parameters","data":{"":"","setbatchsize-and-uploadersetuploadsize#setBatchSize() and uploader.setUploadSize()":"The default batch size (number of chunks to upload at once) is 5, the default chunk size (maximum chunk size) is 25MB. These values can be changed using the functions uploader.setBatchSize(size) and uploader.setUploadSize(size).\n// Optionally change the batch size (default is 5)\nuploader.setBatchSize(10);\n\n// Optionally change the chunk size (default is 25MB)\n// Value is in bytes\nuploader.setChunkSize(500000);"}},"/developer-docs/irys-sdk/chunked-uploader/transaction-mode":{"title":"Transaction mode","data":{"":"Transaction mode gives you more fine-grained control over the upload workflow. You can create and sign your transaction first, store it, and then upload when it makes the most sense for your application.","uploadtransaction#uploadTransaction()":"uploader = irys.uploader.chunkedUploader; // recreate for each transaction\nconst transaction = irys.createTransaction(\"Hello, world!\");\nawait transaction.sign();\nresponse = await uploader.uploadTransaction(transaction);\nconsole.log(`Transaction mode uploaded ==> https://gateway.irys.xyz/${response.data.id}`);"}},"/developer-docs/irys-sdk/chunked-uploader/upload-events":{"title":"Upload events","data":{"":"The uploader emits three events during each upload. These can be subscribed to for any use case when tracking upload progress is needed.\n`chunkUpload``: Emitted whenever a chunk is uploaded.\n`chunkError``: Emitted whenever a chunk upload fails. Due to internal retry logic, these errors can most likely be ignored as long as the upload doesn't error overall.\n`done``: Emitted when the upload completes.\n\n\nuploader.on(\"chunkUpload\", (chunkInfo) => {\nconsole.log(\n`Uploaded Chunk number ${chunkInfo.id}, offset of ${chunkInfo.offset}, size ${chunkInfo.size} Bytes, with a total of ${chunkInfo.totalUploaded} bytes uploaded.`,\n);\n});\n\nuploader.on(\"chunkError\", (e) => {\nconsole.error(`Error uploading chunk number ${e.id} - ${e.res.statusText}`);\n});\n\nuploader.on(\"done\", (finishRes) => {\nconsole.log(`Upload completed with ID ${finishRes.id}`);\n});"}},"/developer-docs/irys-sdk/chunked-uploader/controlling-the-upload":{"title":"Controlling the upload","data":{"":"Uploads created with the chunked uploader can be paused and resumed at any time using the functions uploader.pause() and uploader.resume(). For these functions to work, the initial call to uploader.uploadData() or uploader.uploadTransaction() must not be preceded with the await keyword.To resume an upload from a new uploader instance, you must use the same:\nToken\nNode\nInput data\nConfigured chunk size","uploaderpause-and-uploaderresume#uploader.pause() and uploader.resume()":"const irys = await getIrys();\n\n// When uploading smaller files, it's common to use the await keyword before\n// uploadData() or uploadTransaction(). This causes execution to pause until the file\n// is fully uploaded. If you omit await, the upload happens in the background\n// and you can use pause and resume as needed.\ntransaction = irys.createTransaction(\"Hello, world!\");\nuploader = irys.uploader.chunkedUploader; // recreate for each transaction\nconst upload = uploader.uploadTransaction(transaction);\nuploader.pause(); // pauses the upload\nconsole.log(\"Upload paused\");\nuploader.resume(); // resumes the upload\nconsole.log(\"Upload resumed\");\nWhile the initial call to uploader.uploadData() or uploader.uploadTransaction() should not use the await keyword, you can use it down the line to ensure the upload has completed.You can call await at ANY TIME to ensure the upload has completed.\nresponse = await upload;"}},"/developer-docs/irys-sdk/api/uploader-uploadBundle":{"title":"upload.uploadBundle(tx)","data":{"":"Permanently uploads an array of transactions as a bundle in a single transaction.This function is provided for users who need to obtain each transaction's ID before uploading. Most users will opt to use irys.uploadFolder(), an abstraction that handles the uploading, signing and bundling in a single function call.Parameters\n\n\ndata: The data to upload\ntags: Optional metatags\n\nReturns- receipt: A receipt in the form of a JSON object with the following values:\nresponse = {\nid, // Transaction id (used to download the data)\ntimestamp, // Timestamp (UNIX milliseconds) of when the transaction was created and verified\nversion, // The version of this JSON file, currently 1.0.0\npublic, // Public key of the bundler node used\nsignature, // A signed deep hash of the JSON receipt\ndeadlineHeight, // The block number by which the transaction must be finalized on Arweave\nblock, // Deprecated\nvalidatorSignatures, // Deprecated\nverify, // An async function used to verify the receipt at any time\n}\nExample\nconst irys = await getIrys();\nconst maxTxs = 5;\nconst txs = [];\n\nfor (let i = 0; i < maxTxs; i++) {\nconst newTx = irys.createTransaction(`GM World! ${i + 1}`, {\ntags: [{ name: \"Content-Type\", value: \"text/plain\" }],\n});\nawait newTx.sign(); // ID is now set\ntxs.push(newTx);\nconsole.log(`Tx created and signed, https://gateway.irys.xyz/${newTx.id}`);\n}\n\ntry {\nconst uploadReceipt = await irys.uploader.uploadBundle(txs);\nconsole.log(`All Txs uploaded.`);\n} catch (e) {\nconsole.log(\"Error uploading bundle \", e);\n}\n\n\nThe transaction id returned as part of the response is used to download the data, simply create a URL with the\nformat https://gateway.irys.xyz/[transaction-id]."}},"/developer-docs/irys-sdk/installing-the-sdk":{"title":"Installing The SDK","data":{"":"The Irys SDK can be installed using npm:\nnpm install @irys/sdk\nor yarn:\nyarn add @irys/sdk\n\nIf you get a warning saying bigint: Failed to load bindings, pure JS will be used (try npm run rebuild?) during\ninstall, it can be safely ignored. For details on how make it go away, see our troubleshooting\nguide."}},"/developer-docs/irys-sdk/manual-transaction":{"title":"Manually creating a transaction","data":{"":"In addition to uploading using the SDK functions irys.upload(),irys.uploadFile(),\nand irys.uploadFolder(), you can also manually create, sign, and upload a transaction in separate steps.","workflow#Workflow":"const tx = irys.createTransaction()\nawait tx.sign()\nawait tx.upload()\n\nAfter calling tx.sign(), you can access the transaction ID via tx.id, this facilitates use cases where you need access to the ID before uploading the full transaction.\nYou must call tx.sign() before using the value of tx.id.","creating-signing-uploading#Creating, signing, uploading":"Basic workflow.\nconst createSignUpload = async () => {\n// Get a reference to a pre-configured Irys object\n// See: https://docs.irys.xyz/developer-docs/irys-sdk#connecting-to-a-node\nconst irys = await getIrys();\n\n// Create the transaction\nconst tx = irys.createTransaction(\"GM World!\", { tags: [{ name: \"Content-Type\", value: \"text/plain\" }] });\n\n// Sign the transaction\nawait tx.sign(); // ID is now set\nconsole.log(`Tx created and signed, ID=${tx.id}`);\n\n// Upload the transaction\nconst receipt = await tx.upload();\nconsole.log(`Tx uploaded. https://gateway.irys.xyz/${receipt.id}`);\n};","serializing-a-transaction#Serializing a transaction":"Serialize a transaction and recreate it later.\nconst serializationUpload = async () => {\n// Get a reference to a pre-configured Irys object\n// See: https://docs.irys.xyz/developer-docs/irys-sdk#connecting-to-a-node\nconst irys = await getIrys();\n\n// Create the transaction\nconst tx1 = irys.createTransaction(\"GM World!\", { tags: [{ name: \"Content-Type\", value: \"text/plain\" }] });\n// Note: You can sign before *or* after serializing\nawait tx1.sign(); // ID is now set\nconsole.log(`Tx created and signed, ID=${tx1.id}`);\n\n// Serialize the transaction\nconst txSerialized = tx1.getRaw();\n\n// Recreate the transaction from the serialized version\nconst tx2 = irys.transaction.fromRaw(txSerialized);\n// ID is the same as before\nconsole.log(`Tx re-created from serialized, ID=${tx2.id}`);\n\n// Upload the tx\nconst receipt = await tx2.upload();\n\nconsole.log(`Tx uploaded. https://gateway.irys.xyz/${receipt.id}`);\n};","deterministic-id#Deterministic ID":"Use a deterministic ID in cases where you need access to a transaction ID before uploading, but can't or don't want to store a reference to the transaction object.First, generate an anchor and use that to create a transaction with your data. Then, sign the transaction and you can access the ID. Finally, you can recreate the transaction using the same anchor and data and your ID will be the same.\nconst deterministicIDUpload = async () => {\n// Get a reference to a pre-configured Irys object\n// See: https://docs.irys.xyz/developer-docs/irys-sdk#connecting-to-a-node\nconst irys = await getIrys();\n\n// Generate 32 bytes through Buffer.from(anchor)\nconst anchor = randomBytes(16).toString(\"hex\");\nconst tx1 = irys.createTransaction(\"GM Irys!\", {\ntags: [{ name: \"content-type\", value: \"text/plain\" }],\nanchor,\n});\nawait tx1.sign();\nconsole.log(`Tx1 ID ${tx1.id}`); // ID is now set\n\nconst tx2 = irys.createTransaction(\"GM Irys!\", {\ntags: [{ name: \"content-type\", value: \"text/plain\" }],\nanchor,\n});\nawait tx2.sign();\nconsole.log(`Tx2 ID ${tx2.id}`); // ID is the same\nconst receipt = await tx2.upload();\nconsole.log(`Tx uploaded. https://gateway.irys.xyz/${receipt.id}`);\n};"}},"/developer-docs/irys-sdk/irys-in-the-browser":{"title":"Irys in the Browser","data":{"":"Working with Irys in the browser is similar to working with our server-side SDK, however\nthere are a few differences which are demonstrated below.In addition to creating your own components using the code below, you can also fork the Irys provenance\ntoolkit and quickly build your project using its rich UI component library and\nhelper functions.\nIf you're using Irys with React and npx create-react-app, you will need to follow some extra setup\nsteps.","installing#Installing":"Install using npm:\nnpm install @irys/sdk\nor yarn:\nyarn add @irys/sdk","importing#Importing":"import { WebIrys } from \"@irys/sdk\";","connecting-to-a-node#Connecting to a node":"When instantiating a WebIrys object pass:\nurl: Irys node address\ntoken: Payment token\nwallet: A wallet object containing the end-user's injected provider and the name of the provider package your project uses\n\n\nconst getWebIrys = async () => {\n// Ethers5 provider\nawait window.ethereum.enable();\nconst provider = new providers.Web3Provider(window.ethereum);\n\nconst url = \"https://node1.irys.xyz\";\nconst token = \"matic\";\n// Devnet RPC URLs change often, use a recent one from https://chainlist.org\nconst rpcURL = \"\";\n\n// Create a wallet object\nconst wallet = { rpcUrl: rpcURL, name: \"ethersv5\", provider: provider };\n// Use the wallet object\nconst webIrys = new WebIrys({ url, token, wallet });\nawait webIrys.ready();\n\nreturn webIrys;\n};\nAfter instantiating the object, call webIrys.ready().","supported-providers#Supported providers":"WebIrys supports the following providers. When instantiating a new WebIrys object, you must pass in the name of the provider you will be using.\nPackage\tParameter value\tEthers 5\tethersv5\tEthers 6\tethersv6\tSolana\tsolana\tViem v2\tviemv2","solana-react-hooks#Solana React Hooks":"When working with the Solana React hooks, start by wrapping your components in the Solana ConnectionProvider WalletProvider and WalletModalProvider providers.\nimport { ConnectionProvider, WalletProvider } from \"@solana/wallet-adapter-react\";\nimport { WalletModalProvider } from \"@solana/wallet-adapter-react-ui\";\nimport { PhantomWalletAdapter } from \"@solana/wallet-adapter-wallets\";\n\n// Devnet or Mainnet\nconst network = WalletAdapterNetwork.Devnet;\nconst endpoint = useMemo(() => clusterApiUrl(network), [network]);\n\nconst wallets = useMemo(() => [new PhantomWalletAdapter()], [network]);\n\n<ConnectionProvider endpoint={endpoint}>\n<WalletProvider wallets={wallets} autoConnect>\n<WalletModalProvider>\n<YourComponents />\n</WalletModalProvider>\n</WalletProvider>\n</ConnectionProvider>;\nThen, in components where you need to access a WebIrys object use the useWallet() hook to get a reference to the user's injected provider, and pass that into WebIrys when instantiating a new object.\nimport { useWallet } from \"@solana/wallet-adapter-react\";\nconst wallet = useWallet();\n\nconst getIrys = async (): Promise<WebIrys> => {\n// Devnet RPC URLs change often, use a recent one from https://chainlist.org\nconst rpcURL = \"\";\n\nconst wallet = { rpcUrl: rpcURL, name: \"solana\", provider: wallet };\nconst webIrys = new WebIrys({ url: \"https://devnet.irys.xyz\", token: \"solana\", wallet });\nawait webIrys.ready();\nreturn webIrys;\n};","additional-providers#Additional providers":"Additionally, the following providers will work with extra setup code.\nPackage\tParameter value\tArconnect\tarconnect\tOthent\tothent\tPrivy\tprivy","arconnect#Arconnect":"const getWebIrys = async () => {\nconst arconnect = window.arweaveWallet;\nawait arconnect.connect([\"ACCESS_ADDRESS\", \"ACCESS_PUBLIC_KEY\", \"SIGN_TRANSACTION\", \"SIGNATURE\"]);\nconst webIrys = new WebIrys({ url: \"https://node1.irys.xyz\", token: \"arweave\", wallet: { provider: arconnect } });\nawait webIrys.ready();\n\nreturn webIrys;\n};","othent#Othent":"export const getWebIrys = async () => {\nconst wallet = { name: \"Othent KMS\", provider: othentKMS };\nconst url = \"https://node1.irys.xyz\";\nconst token = \"arweave\";\nconst webIrys = new WebIrys({ url, token, wallet });\nawait webIrys.ready();\nreturn webIrys;\n};","privy#Privy":"Initialize the Privy provider with your app ID and wrap it around your components. In most NextJS projects, you will place this code in your app.tsx file. In our example, we use the <PrivyIrys /> component as a placeholder for your app's top-level component structure.\nWe also have a demo repository teaching how to build a PWA photo-sharing\napp using Privy and Irys.\n\nimport { PrivyProvider } from \"@privy-io/react-auth\";\n\n<PrivyProvider\nappId=\"YOUR-APP-ID\"\nonSuccess={handlePrivyLogin}\nconfig={{\nloginMethods: [\"email\", \"wallet\"],\nappearance: {\ntheme: \"dark\",\naccentColor: \"#676FFF\",\nlogo: \"https://docs.irys.xyz/img/favicon.svg\",\n},\nembeddedWallets: {\ncreateOnLogin: \"users-without-wallets\",\n},\n}}\n>\n<PrivyIrys />\n</PrivyProvider>;\nThen, write code to login with Privy and create a new WebIrys object.The code to create a WebIrys object differs depending on if you're using an external wallet vs an embedded one. When using external wallets, pass the Ethers provider returned from the Wallet object, when using embedded wallets pass the sendTransaction Privy React hook.The following code uses conditional logic to create the correct WebIrys object based on the wallet type. If your application only supports a single wallet type, feel free to simplify the code.\nimport { User, usePrivy, useWallets } from \"@privy-io/react-auth\";\n\nconst { wallets } = useWallets();\nconst { login } = usePrivy();\nconst { sendTransaction } = usePrivy();\n\n// First login\nlogin();\n\n// The 0th position wallet is the most recently used one\nconst w = wallets.at(0);\n// Or find the embedded wallet\n// const w = wallets.find((wallet) => wallet.walletClientType === 'privy');\n\n// Then create a WebIrys object\nconst getWebIrys = async () => {\nconst url = \"https://node1.irys.xyz\";\nconst token = \"matic\";\n\nconst provider = await w?.getEthersProvider();\nif (!provider) throw new Error(`Cannot find privy wallet`);\nconst irysWallet =\nw?.walletClientType === \"privy\"\n? { name: \"privy-embedded\", provider, sendTransaction }\n: { name: \"privy\", provider };\n\nconst webIrys = new WebIrys({\nurl: url,\ntoken: token,\nwallet: irysWallet,\n});\n\nawait webIrys.ready();\n};","funding-a-node#Funding a node":"Fund a node using any of our supported tokens:\nconst fundNode = async () => {\nconst webIrys = await getWebIrys();\ntry {\nconst fundTx = await webIrys.fund(webIrys.utils.toAtomic(0.05));\nconsole.log(`Successfully funded ${webIrys.utils.fromAtomic(fundTx.quantity)} ${webIrys.token}`);\n} catch (e) {\nconsole.log(\"Error uploading data \", e);\n}\n};","uploading#Uploading":"The provenance toolkit contains an uploader component that can be dropped into any project to instantly enable file uploading.Data uploaded to Irys is given a millisecond-accurate timestamp, attributes and authorship details before being passed to Arweave for permanent storage. This information is used to create a signed receipt that can be used to verify the data's provenance at any time.","uploading-data#Uploading data":"const uploadData = async () => {\nconst webIrys = await getWebIrys();\nconst dataToUpload = \"GM world.\";\ntry {\nconst receipt = await webIrys.upload(dataToUpload);\nconsole.log(`Data uploaded ==> https://gateway.irys.xyz/${receipt.id}`);\n} catch (e) {\nconsole.log(\"Error uploading data \", e);\n}\n};","uploading-a-file#Uploading a file":"Upload a File object.\nconst uploadFile = async (fileToUpload: File) => {\nconst webIrys = await getWebIrys();\n// Your file\nconst tags = [{ name: \"application-id\", value: \"MyNFTDrop\" }];\n\ntry {\nconst receipt = await webIrys.uploadFile(fileToUpload, { tags });\nconsole.log(`File uploaded ==> https://gateway.irys.xyz/${receipt.id}`);\n} catch (e) {\nconsole.log(\"Error uploading file \", e);\n}\n};","uploading-a-folder#Uploading a folder":"Upload an array of File objects.Upon upload, a manifest is automatically created. Your files can be accessed https://gateway.irys.xyz/[manifestId]/[file-name].\nconst uploadFolder = async (files: File[], tags: Tag[]) => {\nconst webIrys = await getIrys();\n\ntry {\nconst receipt = await webIrys.uploadFolder(files, {\ntags,\n}); //returns the manifest ID\n\nconsole.log(`Files uploaded. Manifest Id=${receipt.manifestId} Receipt Id=${receipt.id}`);\n} catch (e) {\nconsole.log(\"Error uploading file \", e);\n}\n};"}},"/developer-docs/irys-sdk/community-sdk":{"title":"Community SDKs (unofficial)","data":{"":"In addition to the official Irys JavaScript / TypeScript SDK, there are also SDKs in other languages built by our community.Looking to implement our SDK in a new language? Reach out to us on Discord for help.","go#Go":"Irys Go SDK Maintained by Javad Rajabzadeh"}},"/developer-docs/irys-sdk/ipfs-cid":{"title":"IPFS Content IDs","data":{"":"In addition to using Irys transaction IDs, you can also use IPFS Content IDs (CIDs) when addressing data on Irys.\nIrys does not currently verify that CIDs match their uploaded data. This will be added in a future release.","content-ids-vs-transaction-ids#Content IDs vs transaction IDs":"IPFS and Irys take a different approach to identifying data, IPFS uses Content Identifiers (CIDs) and Irys uses transaction IDs.\nIPFS Content Identifiers (CIDs) are generated by hashing the content being uploaded. The same data uploaded twice will generate the same CID.\nIrys transaction IDs are generated by hashing the content + metadata being uploaded. All uploads have a unique transaction ID.","uploading-with-a-cid#Uploading with a CID":"To upload data to Irys using a CID, embed it as the value of the IPFS-CID tag when uploading data.\nThis code example generates a CID using the ipfs-only-hash package which uses the SHA-256 algorithm by default.\nIPFS also allows CIDs to be generated using SHA3 and Blake2, all of which are supported when uploading to Irys.\n\nimport IPFS from \"ipfs-only-hash\";\n\nconst generateCID = async (content) => {\nreturn await IPFS.of(content);\n};\n\nconst uploadToIrysWithCID = async () => {\n// See: https://docs.irys.xyz/developer-docs/irys-sdk#connecting-to-a-node\nconst irys = await getIrys();\n\nconst dataToUpload = \"Irys + IPFS Content ID\";\nconst contentID = await generateCID(dataToUpload);\nconsole.log(`ContentID=${contentID}`);\n\nconst tags = [\n{ name: \"Content-Type\", value: \"text/html\" },\n{ name: \"IPFS-CID\", value: contentID },\n];\nconst receipt = await irys.upload(dataToUpload, { tags });\n\n// You can download using either the Irys transaction ID or IPFS Content ID\nconsole.log(`Transaction ID URL https://gateway.irys.xyz/${receipt.id}`);\nconsole.log(`Content ID URL https://gateway.irys.xyz/ipfs/${contentID}`);\n};","downloading-with-a-cid#Downloading with a CID":"To download data tagged with a CID, request it from the Irys gateway using a URL in the format https://gateway.irys.xyz/ipfs/:contentID.\nIf the same CID is assigned to more than one transaction, the Irys gateway will always return the one with the\nearliest timestamp.\n\nconst fetchData = async (ipfsCID) => {\nconst url = `https://gateway.irys.xyz/ipfs/${ipfsCID}`;\nconsole.log(`URL: ${url}`);\n\nconst response = await fetch(url);\nconst data = await response.text();\nconsole.log(`DATA: ${data}`);\n};","migrating-data-from-ipfs-to-irys#Migrating data from IPFS to Irys":"You can migrate data from IPFS to Irys by first downloading the data from an IPFS gateway and then uploading it to an Irys node. Users can choose to tag the uploads with the original IPFS CID and continue to retrieve data using the CID, or switch to using Irys transaction IDs.This code example shows how to:\nDownload data from an IPFS gateway\nDetermine the data's content type (for example: image/png)\nRe-upload the data to Irys while tagging it with the existing content type\n\n\nPrior to uploading, users must fund an Irys node. Most users will choose to up-front\nfund where they pre-fund an Irys node with sufficient tokens to\ncover all data being migrated. Users can also choose to lazy-fund\nthe uploads where you fund each separate upload.\n\nimport fetch from \"node-fetch\";\nimport { fileTypeFromBuffer } from \"file-type\";\nimport Irys from \"@irys/sdk\";\n\nconst uploadToIrysWithCID = async (dataToUpload, contentType, contentID) => {\n// See: https://docs.irys.xyz/developer-docs/irys-sdk#connecting-to-a-node\nconst irys = await getIrys();\n\nconst tags = [\n{ name: \"Content-Type\", value: contentType },\n{ name: \"IPFS-CID\", value: contentID },\n];\nconst receipt = await irys.upload(dataToUpload, { tags });\nconsole.log(`Direct URL: https://gateway.irys.xyz/${receipt.id}`);\nconsole.log(`Content ID URL: https://gateway.irys.xyz/ipfs/${contentID}`);\n};\n\nconst downloadAndDetermineContentType = async (ipfsCID) => {\ntry {\nconst ipfsURL = `https://ipfs.io/ipfs/${ipfsCID}`;\nconst response = await fetch(ipfsURL);\nconst arrayBuffer = await response.arrayBuffer();\nconst buffer = Buffer.from(arrayBuffer);\n\nconst contentType = await fileTypeFromBuffer(buffer);\n\nif (contentType) {\nconsole.log(`Content Type: ${contentType.mime}`);\nawait uploadToIrysWithCID(buffer, contentType.mime, ipfsCID);\n} else {\nconsole.error(\"Unable to determine content type\");\n}\n} catch (error) {\nconsole.error(\"Error:\", error);\n}\n};\n\nconst ipfsCID = \"QmUgL4YbnW9vMWZXLdAFzgxJwxpxJapZRLpjoT2ubU5WmF\";\ndownloadAndDetermineContentType(ipfsCID);"}},"/developer-docs/irys-sdk/migration-guide":{"title":"Migration guide","data":{"":"Migrating your application from the Bundlr SDK to the Irys SDK is a simple process.\nAll existing legacy packages will be maintained until October 2024 and will continue to work until at least October\n2025. All domains will be supported in perpetuity (e.g., https://node1.bundlr.network)","installation#Installation":"Install the Irys SDK using npm:\nnpm install @irys/sdk\nor yarn:\nyarn add @irys/sdk","imports#Imports":"Change your import statements from:\nimport Bundlr from \"@bundlr-network/client\";\nto:\nimport Irys from \"@irys/sdk\";","name-changes#Name Changes":"Apart from rebrand to Irys, certain elements within the SDK have undergone a name change.WebBundlr and (Node)Bundlr have been changed to WebIrys and (Node)Irys respectively.\nAll usage of currency in the SDK has been replaced with token, notably the argument as part of client instantiation (see Constructor)\nas well as internal APIs (such as currencyConfig -> tokenConfig)","constructor#Constructor":"In the Bundlr SDK, parameters are passed directly. In the Irys SDK, parameters are passed inside an options object.Update new Bundlr to new Irys and then wrap your constructor arguments in {}.\nconst url = \"https://devnet.irys.xyz\";\n// Devnet RPC URLs change often, use a recent one from https://chainlist.org/chain/80001\nconst providerUrl = \"\";\nconst token = \"matic\";\n\nconst bundlr = new Bundlr(url, token, process.env.PRIVATE_KEY);\n\nconst irys = new Irys({\nurl, // URL of the node you want to connect to\ntoken, // Token used to pay for uploads\nkey: process.env.PRIVATE_KEY, // ETH or SOL private key\nconfig: { providerUrl }, // Optional provider URL, only required when using Devnet\n});","domain-changes#Domain Changes":"With the release of the Irys SDK our domain has changed from https://bundlr.network to https://irys.xyz. When upgrading your code, you shouldsla change your Node URLs:\nBundlr Node Address\tIrys Node Address\thttps://node1.bundlr.network\thttps://node1.irys.xyz\thttps://node2.bundlr.network\thttps://node2.irys.xyz\thttps://devnet.bundlr.network\thttps://devnet.irys.xyz\nAnd your GraphQL endpoints\nBundlr GraphQL Endpoint\tIrys GraphQL Endpoint\thttps://node1.bundlr.network/graphql\thttps://node1.irys.xyz/graphql\thttps://node2.bundlr.network/graphql\thttps://node2.irys.xyz/graphql\thttps://devnet.bundlr.network/graphql\thttps://devnet.irys.xyz/graphql","changes-to-upload-functions#Changes to upload functions":"In the Bundlr SDK there were separate upload functions depending on whether you wanted a receipt or not. With the Irys SDK, all upload functions return a receipt.The following function is deprecated:\nbundlr.uploadWithReceipt()\n\nThe following functions upload data as before however, the return type has changed to be a receipt.\nirys.upload() To upload any data\nirys.uploadFile() To upload a file\nirys.uploadFolder() To upload a folder","change-to-webbundlr--webirys#Change to WebBundlr / WebIrys":"With the Bundlr SDK, using providers other than Ethers 5 required extra setup code unique to each provider. Now, we natively support multiple different provider types.When connecting to a WebIrys class, you pass both a reference to a provider and the provider type. The following example is for Ethers 5, we also have a full list of supported provider types see Irys in the browser.\nconst getWebIrys = async () => {\n// Ethers5 provider\nawait window.ethereum.enable();\nconst provider = new providers.Web3Provider(window.ethereum);\n\nconst url = \"https://node1.irys.xyz\";\nconst token = \"matic\";\n// Devnet RPC URLs change often, use a recent one from https://chainlist.org/chain/80001\nconst rpcUrl = \"\";\n\n// Create a wallet object\nconst wallet = { rpcUrl: rpcURL, name: \"ethersv5\", provider: provider };\n// Use the wallet object\nconst webIrys = new WebIrys({ url, token, wallet });\nawait webIrys.ready();\n\nreturn webIrys;\n};"}},"/developer-docs/provenance-toolkit":{"title":"Provenance Toolkit","data":{"":"The Irys Provenance Toolkit is a collection of UI components you can use to kickstart your next application. It contains UI components for managing node balances, uploading files, performing gasless uploads, and querying transactions.The toolkit is fully open source, you are welcome to use it any way you want with or without attribution.","demo#Demo":"You can interact with the provenance toolkit at https://provenance-toolkit.irys.xyz","prerequisites#Prerequisites":"The Provenance Toolkit is designed for intermediate to advanced developers and assumes you have a working knowledge of NextJS, TypeScript, and Tailwind. Beginning developers may want to start with our tutorials and quests which are designed for a broader audience.This guide gives an introduction to the entire toolkit, including how to use and customize the components. To learn more about how each component is built, we have separate tutorials for each.","setup#Setup":"Fork or clone https://github.com/Irys-xyz/provenance-toolkit\nRun npm install or yarn from within the project directory\nRename .env.local.example to .env.local and follow the configuration instructions in that file\nRun npm run start from within the project directory\nLaunch the Provenance Toolkit at http://localhost:3000/","project-layout#Project layout":"The project is broken into three main categories:\nComponents: The UI components. These can be added to your project and used as is.\nNavigation routes: NextJS navigation routing. If you’re building your own project on top of the Provenance Toolkit, you can delete these routes and create your own.\nUtils: Utility functions used by the UI components.","components#Components":"Included within the Provenance Toolkit are the following components:\nFund / Withdraw: Manage node balances.\nUploader: Upload single files or groups of files.\nProgress Bar Uploader: Upload large files, and provide feedback with a progress bar.\nUDL Uploader: Upload files and attach a UDL.\nEncrypted Uploader: Encrypt files before uploading.\nGasless Uploader: Pay for user uploads server-side.\nSolana NFT Minter: Upload an image and mint on Solana as an NFT.\nTransaction Feed: Query Irys transactions.","customization#Customization":"The components are designed with a minimal UI that can be easily incorporated into any design. If you need to make significant UI customizations, the docs for each component contain a description of the code.To change colors, modify the values in tailwind.config.js.","utility-functions#Utility Functions":"The following utility functions are used internally by the components. If you're using the components as-is, you can safely ignore the utility functions. For users customizing the components, these functions provide an additional abstraction layer over our SDK.\ntitleCase.ts: Converts a string to title case\ngetRpcUrl.ts: Returns the RPC URL for the chain associated with the specified token.\ngetIrys.ts: Instantiates an Irys object using the parameters in .env.local. Currently designed to work with the Ethers 5 provider. You use a different provider, modify code here.\nfundAndUpload.ts: Determines the upload cost for the specified data, funds the node if needed, and then uploads the file.\ngaslessFundAndUpload.ts: Using the private key supplied in .env.local, determines the upload cost for the specified data, funds the node if needed, and then uploads the file.\nqueryGraphQL.ts: Uses the Irys query package to search based on parameters entered in the UI"}},"/developer-docs/irys-sdk/troubleshooting":{"title":"Troubleshooting","data":{"":"Troubleshooting common errors during installation and use.Errors:\nbigint: Failed to load bindings, pure JS will be used (try npm run rebuild?)\nError: Using devnet.irys.xyz requires a dev/testnet RPC to be configured\nError: Not enough balance for transaction","bigint#bigint":"Error message: bigint: Failed to load bindings, pure JS will be used (try npm run rebuild?)This error can be safely ignored, it will not cause any issues. To make the error go away, you'll need to install updated Python and C++ build tools.MacOSCurrent versions of MacOS come pre-built with Python. To install the C++ build tools:\nFirst install XCode\nOnce XCode is installed, go to Preferences, Downloads, and install the Command Line Tools\n\nWindowsWindows users need to install both Python and C++ build tools. These commands must be run with administrator permissions.\n// First run:\nnpm i -g --add-python-to-path --vs2015 --production windows-build-tools\n\n// Then run:\nnpm i -g node-gyp@latest\nUNIXMost UNIX distributions come with Python installed. To install C++ build tools, the following works for most debian-based systems. For others, use your package manager to install \"GCC build tools\".\nsudo apt-get install build-essential","devnet-rpc#Devnet RPC":"Error message: Error: Using devnet.irys.xyz requires a dev/testnet RPC to be configuredWhen using our Devnet, you must provide the URL to a Denvet RPC for the chain you're using. As this parameter is not required when using Node 1 and 2, users will sometimes get an error if they forget to add in the RPC URL.For example, this will throw an error\nconst getIrys = async () => {\nconst url = \"https://devnet.irys.xyz\";\nconst token = \"matic\";\n\nconst irys = new Irys({\nurl, // URL of the node you want to connect to\ntoken, // Token used for payment\nkey: process.env.PRIVATE_KEY, // EVM private key\n});\nreturn irys;\n};\nBut this will not:\nconst getIrys = async () => {\nconst url = \"https://devnet.irys.xyz\";\nconst token = \"matic\";\nconst providerUrl = \"https://rpc-mumbai.maticvigil.com\";\n\nconst irys = new Irys({\nurl, // URL of the node you want to connect to\ntoken, // Token used for payment\nkey: process.env.EVM_PRIVATE_KEY, // EVM private key\nconfig: { providerUrl }, // Optional provider URL, only required when using Devnet\n});\nreturn irys;\n};\nAs RPC URLs change frequently, users should always choose an up-to-date one from https://chainlist.org/","insufficient-balance#Insufficient balance":"Error message: Error: Not enough balance for transactionThis error occurs when you try to upload to a node without first funding it. This applies to both Nodes 1 and 2 where you can pay using any our supported mainnet tokens and our Devnet node where you can pay using any of our supported Devnet tokens.Devnet tokens can be obtained for free from common faucets like the ones for Solana, Sepolia and Mumbai."}},"/developer-docs/provenance-toolkit/fund-withdraw":{"title":"Fund / withdraw","data":{"":"The Fund Withdraw component is used to manage node balances.","funding-and-withdrawing#Funding and withdrawing":"When uploading data to Irys, first connect to and then fund a node. Balances are not shared between nodes, fund the node you intend to use.","customizing-the-ui#Customizing the UI":"The FundWithdraw component provides a default UI that includes options for the end user to select a node, choose a token, and decide between funding or withdrawing.You can also modify the UI to hardwire the node address, token, or fix the mode (either to \"fund-only\" or \"withdraw-only\") using configuration parameters.\nDescription\tCode\tDefault Behavior\t<FundWithdraw />\tFix the node\t<FundWithdraw node=\"https://node1.irys.xyz\" />\tFix the token\t<FundWithdraw token=\"ethereum\" />\tSet to fund-only mode\t<FundWithdraw fundOnly={ true } />\tSet to withdraw-only mode\t<FundWithdraw withdrawOnly={ true }/>\nIf both fundOnly and withdrawOnly are set to false, the component defaults to fund-only mode.","code#Code":"The component is designed to be used as-is. Users making significant changes to the UI will need to understand the following.","getting-funded-balance#Getting funded balance":"When the component is set to \"withdraw\" mode, the UI will automatically check and display the user's currently funded balance. As balances are both node and token-specific, this balance check is encapsulated within a useEffect() hook that gets triggered when the component mounts and also whenever the user changes either the selected node or token.To get the currently funded balance, first connect to a Irys node using the node and token selected by the user:\nconst irys = await getIrys(selectedNode?.value, selectedToken?.value);\nThen retrieve the loaded balance in atomic units:\nawait irys.getLoadedBalance();\nAnd convert to standard units before setting to a React state variable:\nsetAmount(irys.utils.fromAtomic(loadedBalance));\nHere’s the full code:\nuseEffect(() => {\nsetAmount(0);\nconst getCurBalance = async () => {\ntry {\nconst irys = await getIrys(selectedNode?.value, selectedToken?.value);\nconst loadedBalance = await irys.getLoadedBalance();\n\n// Show currently funded balance iff we're in withdraw mode\nif (!isFunding) setAmount(irys.utils.fromAtomic(loadedBalance));\n} catch (error) {\nconsole.log(\"Error connecting to Irys:\", error);\n}\n};\nif (selectedNode && selectedToken) getCurBalance();\n}, [selectedNode, selectedToken, isFunding]);","funding--withdrawing#Funding & withdrawing":"Funding and withdrawing happen in the function handleFundWithdraw(). This function first validates input, then connects to a Irys node:\nconst irys = await getIrys(selectedNode?.value, selectedToken?.value);\nWhen funding, it converts the value entered by the user to atomic units and then uses that value to fund:\nconst fundTx = await irys.fund(irys.utils.toAtomic(amount));\nWhen withdrawing, it converts the value entered by the user to atomic units and then uses that value to withdraw:\nconst fundTx = await irys.withdrawBalance(irys.utils.toAtomic(amount));","atomic-units#Atomic units":"When funding and withdrawing using the functions irys.fund() or irys.withdrawBalance(), pass a value in atomic units.\nAtomic units refer to the smallest possible unit of a given cryptocurrency. In Ethereum, atomic units are called\nWei, and they represent the smallest unit of Ether. Similar to how 1 dollar can be broken down into 100 cents, 1\nEther can be broken down into 10^18 Wei. In Solana, atomic units are called Lamports, 1 SOL can be broken down into\n10^9 Lamports."}},"/developer-docs/provenance-toolkit/progress-bar-uploader":{"title":"Progress-bar uploader","data":{"":"The Progress Bar Uploader is designed for larger files whose upload will take more than a few seconds. It provides visual feedback of upload progress in the form of a progress bar.","uploading#Uploading":"The component uses a lazy funding approach, it first determines the cost to upload the chosen file, then checks the user's loaded balance, only funding more if needed. Once uploaded, a link to the file is shown in the UI and stored in the fileUrl state variable.","customizing-the-ui#Customizing the UI":"In default mode, the ProgressBarUploader component shows both the image preview and receipt preview buttons. They can be hidden by passing config parameters.\nDescription\tCode\tDefault Behavior\t<ProgressBarUploader />\tHide the image preview\t<ProgressBarUploader showImageView={ false } />\tHide the receipt preview\t<ProgressBarUploader showReceiptView={ false } />","code#Code":"The component is designed to be used as-is. Users making significant changes to the UI will need to understand the following.The progress bar uploader uses our chunked uploader, which gives users fine-grained control over how files are uploaded. You can specify how to break a large file into smaller \"chunks\", how big each should be and how many should be uploaded at once. The uploader also supports event callbacks which update you on the upload's progress.The progress bar is controlled using the progress state variable, as its value is incrementally updated from 0 to 100, the visual representation automatically updates.\nconst [progress, setProgress] = useState<number>(0);","using-the-chunked-uploader#Using the chunked uploader":"When setting up the chunked uploader, configure it by setting the batch size and chunk size. You may need to experiment with these values as you build your application, the ideal configuration will depend on factors including average file size and the quality of your end-user's internet connection.\nconst irys = await getIrys();\n\nconst uploader = irys.uploader.chunkedUploader;\nuploader.setBatchSize(1);\nuploader.setChunkSize(2000000);","event-callbacks#Event callbacks":"Three different event callbacks are supported, use them to have code run during and after your upload. Currently they are used to update the progress bar.chunkUpload: Called after each chunk is uploaded, updates the progress bar.\nuploader.on(\"chunkUpload\", (chunkInfo) => {\nconst chunkNumber = chunkInfo.id + 1;\n// update the progress bar based on how much has been uploaded\nif (chunkNumber >= totalChunks) setProgress(100);\nelse setProgress((chunkNumber / totalChunks.current) * 100);\n});\nerror: Called if an error happens. In most cases, these can be ignored as the uploader automatically retries the upload whenever an error happens.\nuploader.on(\"chunkError\", (e) => {\nconsole.error(`Error uploading chunk number ${e.id} - ${e.res.statusText}`);\n});\ndone: Called when the upload is complete, sets the progress bar to 100%.\nuploader.on(\"done\", (finishRes) => {\nconsole.log(`Upload completed with ID ${finishRes.id}`);\n// Set the progress bar to 100\nsetProgress(100);\n});","uploading-the-file#Uploading the file":"Once the event callbacks are setup, the file is passed to the uploader and the URL to the file is shown in the UI and stored in a state variable.\nawait uploader\n.uploadData(dataStream, {\ntags: [{ name: \"Content-Type\", value: fileType }],\nupload: { getReceiptSignature: true },\n})\n.then((res) => {\nsetFileUrl(`https://gateway.irys.xyz/${res.data.id}`);\nsetMessage(\n`File <a class=\"underline\" target=\"_blank\" href=\"https://gateway.irys.xyz/${res.data.id}\">uploaded</a>`,\n);\n})\n.catch((e) => {\nsetMessage(\"Upload error \" + e.message);\n});"}},"/developer-docs/provenance-toolkit/encrypted-uploader":{"title":"Encrypted Uploader","data":{"":"The Uploader component can optionally be put in encrypt mode where:\nA user selects a single file\nThe file is encrypted using Lit Protocol\nThe file is uploaded to Irys\nThe user can choose to decrypt the file\nThe file is then downloaded and decrypted using Lit Protocol","detailed-reading#Detailed reading":"For more information on how Irys works with Lit Protocol, see:\nEncrypting onchain data\nEncrypting data server-side\nEncrypting data in the browser","uploading#Uploading":"The component uses lazy funding, only funding when the currently funded balance is not sufficient to cover the cost of this upload. Once uploaded, file URLs are stored in the fileUrls state variable.When uploading a single file, the URL generated is in the form https://gateway.irys.xyz/[transaction-id]. When uploading multiple files, they are grouped together and uploaded as a group along with a manifest. The URL generated is in the form https://gateway.irys.xyz/[manifest-id]/[file-name].","access-control-rules#Access control rules":"In its default configuration, the Encrypted Uploader component is configured to allow anyone to decrypt the data. This is done by defining an access control condition that says any wallet with an ETH balance >= 0 can decrypt the data.For more information on access control conditions, see our docs and Lit's."}},"/developer-docs/mutable-references":{"title":"Mutable references","data":{"":"Mutable references enable the creation of a single, static URL that is linked to a sequential series of transactions. You can add a new transaction to the series at any time, and the URL will always resolve to the most recent transaction.\n\nTo create a mutable reference:\nUpload a base transaction to Irys and reference it using a URL in the following format https://gateway.irys.xyz/mutable/:id\n\n\nconst irys = await getIrys();\nconst receiptOne = await irys.upload(\"First TX\");\nconsole.log(`TX 1 uploaded https://gateway.irys.xyz/mutable/${receiptOne.id}`);\n\nUpload an addition to the series as a new transaction, and add a tag named Root-TX with the value of the original transaction ID.\n\n\nconst tags = [{ name: \"Root-TX\", value: receiptOne.id }];\nconst receiptTwo = await irys.upload(\"Second TX\", { tags });\nconsole.log(`TX 2 uploaded https://gateway.irys.xyz/mutable/${receiptOne.id}`);\nThe original URL (https://gateway.irys.xyz/mutable/:id) now resolves to the second transaction in the chain.\nWhen building a transaction chain, additions must be made using the same wallet that created the original\ntransaction. This prevents unauthorized actors from maliciously modifying someone else’s transaction chain.","granularity#Granularity":"Mutable references are based on Irys’ millisecond-accurate timestamps. You can publish multiple sequential updates to a given transaction and be confident the transaction served by the /mutable/ endpoint will always be the most recent chronological one.","versions#Versions":"While the https://gateway.irys.xyz/mutable/:id endpoint will always resolve to the most recent transaction in a chain, it is possible to directly access any transaction in a chain using the transaction’s ID and a URL in the format https://gateway.irys.xyz/:idYou can query a version chain using the Irys query package:\nimport Query from \"@irys/query\";\n\nconst txID = \"WF--VR1ZERvABYy1aNYD3QJ0OAVDSUF8dTlg6zFKveQ\";\nconst fromAddress = \"0x591b5ce7ca10a55a9b5d1516ef89693d5b3586b8\";\n\nconst myQuery = new Query({ url: \"https://node2.irys.xyz/graphql\" });\nconst results = await myQuery\n.search(\"irys:transactions\")\n.tags([{ name: \"Root-TX\", values: [txID] }])\n.from([fromAddress])\n.sort(\"ASC\");\n\nresults.forEach((result, i) => {\nconst formattedTimestamp = new Date(result.timestamp).toLocaleString();\nconsole.log(`Update ${i + 1}: ID: ${result.id}, Timestamp: ${formattedTimestamp}`);\n});\nOr GraphQL:\nquery getChain {\ntransactions(\ntags: [\n{\nname: \"Root-TX\"\nvalues: [\"WF--VR1ZERvABYy1aNYD3QJ0OAVDSUF8dTlg6zFKveQ\"]\n}\n]\nowners: [\"0x591b5ce7ca10a55a9b5d1516ef89693d5b3586b8\"]\norder: ASC\n) {\nedges {\nnode {\nid\ntimestamp\n}\n}\n}\n}","use-cases#Use-cases":"Irys’ mutable references open up new opportunities for builders, including:\nGaming NFTs: Metadata changes based on in-game actions\nDynamic NFTs: Images change based on onchain activity\nSoftware distribution: The latest version is always available via the same link\nContent publishing / social media: Content can be updated at any time and users will always have the most recent version\nWebsite hosting / dApp front-ends: Websites can be updated at any time without changing the main URL"}},"/developer-docs/provenance-toolkit/solana-nft-minter":{"title":"Solana NFT minter","data":{"":"The Solana NFT Minter component:\nUploads an image to Irys\nMints the image as a Solana NFT using the Helius SDK","minting#Minting":"This component uses the Helius SDK to mint the uploaded image as a compressed NFT on Solana.To use this component, you must create a Helius developer account first.\n\nThen, add your Helius API key as the value for the NEXT_PUBLIC_HELIUS_API field in the Provenance Toolkit's .env.local file."}},"/developer-docs/provenance-toolkit/transaction-feed":{"title":"Transaction feed","data":{"":"The Transaction Feed component uses the query package to search transactions based on node, token, content type and timestamp and renders the results in an easy-to-view format.\n\nThe component could be easily forked and used as part of applications like:\nA feed of images for a decentralized image-sharing platform\nA music discovery tool highlighting songs uploaded to Arweave\nA browsing tool as part of a platform for academic research and papers","query-function#Query function":"The actual querying takes place in the function handleQuery() where parameters entered in the UI are used to create a new Query object.When forking this component, you could modify the query construction to do things like limit query results to transactions with your application-id or transactions of a single Content-Type.\nconst handleQuery = async () => {\nsetTxProcessing(true);\nsetQueryResults([]);\n\nsetError(\"\");\nif (selectedNode === null) {\n// Should never happen, but better to check\nsetError(\"Please select a node\");\nreturn;\n}\n\n// Convert the timestamp strings to Date objects\nconst fromDate = fromTimestamp ? new Date(fromTimestamp) : null;\nconst toDate = toTimestamp ? new Date(toTimestamp) : null;\n\ntry {\nconst query = new Query({ url: selectedNode.value });\nconst myQuery = query.search(\"irys:transactions\").limit(42);\n\n// Set query params based on input in NavBar\nif (selectedContentType?.value) {\nconsole.log(\"Adding content type=\", selectedContentType?.value);\nmyQuery.tags([{ name: \"Content-Type\", values: [selectedContentType?.value] }]);\n}\nif (selectedToken?.value) {\nconsole.log(\"Adding token=\", selectedToken?.value);\nmyQuery.token(selectedToken?.value);\n}\nif (fromDate) {\nconsole.log(\"Adding fromDate=\", fromDate);\nmyQuery.fromTimestamp(fromDate);\n}\nif (toDate) {\nconsole.log(\"Adding fromDate=\", toDate);\nmyQuery.toTimestamp(toDate);\n}\n\n// Having configured the query, call await on it to execute\nconst results = await myQuery;\nconsole.log(\"Query results \", results);\nlet convertedResults: QueryResult[] = [];\nfor (const result of results) {\nconst transformedResult: QueryResult = {\ntxID: result.id, // adjust as necessary based on the structure of results\ncreationDate: result.timestamp.toString(),\ntoken: result.token,\ntags: result.tags,\n};\nconvertedResults.push(transformedResult);\n}\n\nsetQueryResults(convertedResults);\n} catch (error) {\nsetError(\"Error executing the GraphQL query\");\n} finally {\nsetTxProcessing(false);\n}\n};"}},"/developer-docs/provenance-toolkit/gasless-uploader":{"title":"Gasless uploader","data":{"":"The Gasless Uploader component is used to upload either single files or groups of files. Uploads are signed and paid for using a wallet linked to the server.","uploading#Uploading":"When uploading a single file, the URL generated is in the form https://gateway.irys.xyz/[transaction-id]. When uploading multiple files, they are grouped together and uploaded as a folder with a manifest. The URL generated is in the form https://gateway.irys.xyz/[manifest-id]/[file-name].","image--receipt-preview#Image & receipt preview":"Once uploaded, the UI updates to include buttons that can be clicked to view the upload and the upload receipt. When previewing uploads, all image types are supported. If your application is working with files other than images, you can remove the upload preview or modify the code to include support for previewing your file type.","customizing-the-ui#Customizing the UI":"In default mode, the GaslessUploader component shows both the image preview and receipt preview buttons, which can be optionally hidden by passing config parameters to the component.\nDescription\tCode\tDefault Behavior\t<GaslessUploader />\tHide the image preview\t<GaslessUploader showImageView={false} />\tHide the receipt preview\t<GaslessUploader showReceiptView={false} />\nIf either parameter is left blank, it defaults to true.","code#Code":"The component is designed to be used as-is. Users making significant changes to the UI can familiarize themselves with the code using this tutorial."}},"/developer-docs/provenance-toolkit/udl-uploader":{"title":"UDL uploader","data":{"":"The UDL Uploader component attaches a Universal Data License to data as it's uploaded.","universal-data-license#Universal Data License":"The Universal Data License (UDL) provides content creators with a straightforward way to define how their content can be used. It is fully parameterized, each data point in the UI is converted to a tag at upload.","tags#Tags":"When using Irys to upload data to Arweave, you can attach up to 20 tags to each transaction. These tags, in the form of name / value pairs, are indexed and are queryable. When adding a UDL to an upload, you use a pre-defined set of tags to describe how you allow your data to be used.The UDL uploader has a UI that covers most UDL parameters, you can manually customize the UI to include additional parameters as needed.When uploading data, UDL parameters are converted to tags and attached to the data at upload.","code#Code":"The UDL uploader does not natively support any customizations, however when forking the code, builders might choose to hide certain parameters from the UI and hardcode them during upload. For example you may want to fix the payment token to only be ETH, or disallow all commercial use.","configuring-the-license#Configuring the license":"All of the processing for UDLUploader happens in the handleUpload() function. After validating input, an array of tags is built. This is where you could hardcode values instead of having them configurable in the UI.\nconst tags: Tag[] = [];\ntags.push({ name: \"Content-Type\", value: fileType });\ntags.push({\nname: \"License\",\nvalue: \"yRj4a5KMctX_uOmKWCFJIjmY8DeJcusVk6-HzLiM_t8\",\n});\nif (licenseFeeType !== \"None\")\ntags.push({\nname: \"License-Fee\",\nvalue: licenseFeeType + \"-\" + licenseFeeUnit,\n});\nif (commercialUse !== \"None\") tags.push({ name: \"Commerical-Use\", value: commercialUse });\ntags.push({ name: \"Currency\", value: currency });\nif (paymentAddress) tags.push({ name: \"Payment-Address\", value: paymentAddress });\nif (derivation) tags.push({ name: \"Derivation\", value: derivation });","uploading-the-file#Uploading the file":"And then the file is paired with tags and is uploaded using our utility function.\nconst txId = await fundAndUpload(selectedFile, tags);"}},"/developer-docs/querying":{"title":"Querying","data":{"":"Querying\n\n\nSearch Irys and Arweave using our query package and GraphQL endpoints.\n\n\n\nQuery package\n\nThe easiest way to search Irys and Arweave is by using the Irys query\npackage, a JavaScript-based abstraction that sits on top of our GraphQL\nendpoints.\n\nGraphQL\n\nIrys also supports querying directly using GraphQL. Users can query Irys directly using the GraphQL\nsandbox, or embed GraphQL queries in any other programming\nlanguage."}},"/developer-docs/querying/api/fields":{"title":"fields({})","data":{"":"Limits the fields returned.Parameters- fields: A JSON object detailing the desired fieldsTo limit the results, set a field's value to false or omit it entirely.The fields available for retrieval depend on the search type, when searching irys:transactions, the following fields are available:\n.fields({\nid: true, // Transaction ID\ntoken: true, // Token used for payment\naddress: true, // Cross-chain address used for signing and payment\nreceipt: {\ndeadlineHeight: true, // The block number by which the transaction must be finalized on Arweave\nsignature: true, // A signed deep hash of the JSON receipt\ntimestamp: true, // Timestamp, millisecond accurate, of the time the uploaded was verified\nversion: true, // The receipt version, currently 1.0.0\n},\ntags: { // An array of tags associated with the upload\nname: true,\nvalue: true,\n},\nsignature: true, // A signed deep hash of the JSON receipt\ntimestamp: true, // Timestamp, millisecond accurate, of the time the uploaded was verified\n})\nWhen searching by arweave:transactions the following fields are available:\n.fields({\nid: true, // Transaction ID\ntags: {\n// Tags associated with the upload\nname: true,\nvalue: true,\n},\nanchor: true,\nblock: {\nheight: true, // Block height\nid: true, // Block ID\nprevious: true, // Todo\ntimestamp: true, // Block timestamp\n},\nbundledIn: {\nid: true,\n},\ndata: {\nsize: true, // Data size\ntype: true, // Date type\n},\nfee: {\nar: true, // Fee paid in AR\nwinston: true, // Fee paid in Winston\n},\nowner: {\naddress: true, // Transation originator\nkey: true, // Public key\n},\nquantity: {\nar: true, // Amount of AR transferred (for token transfers)\nwinston: true, // Amount of AR transferred (for token transfers)\n},\nrecipient: true, // Transfer recipient (for token transfers)\nsignature: true, // Transaction signature\n})\nWhen searching by arweave:blocks the following fields are available:\n.fields({\nheight: true,\nid: true,\nprevious: true,\ntimestamp: true,\n})"}},"/developer-docs/querying/api/from":{"title":"from([addresses])","data":{"":"Queries by the wallet addresses used when signing and paying for the upload.Parameters\n\n\naddresses: An array of IDs passed as strings","search-by-transaction-sender#Search By Transaction Sender":"When querying Irys, accepts addresses from any of Irys' supported chains are accepted.\nconst results = await myQuery\n.search(\"irys:transactions\")\n.from([\"UsWPlOBHRyfWcbrlC5sV3-pNUjOQEI5WmDxLnypc93I\",\n\"0x4adDE0b3C686B4453e007994edE91A7832CF3c99\"]);\nWhen querying Arweave, accepts Arweave addresses only.\nconst results = await myQuery\n.search(\"arweave:transactions\")\n.from([\"TrnCnIGq1tx8TV8NA7L2ejJJmrywtwRfq9Q7yNV6g2A\"]);"}},"/developer-docs/querying/api/fromTimestamp":{"title":"fromTimestamp(timeStamp)","data":{"":"Use the fromTimestamp() and toTimestamp() functions to search for transactions by timestamp. Results returned are >= fromTimestamp and < toTimestamp.\n\nParameters\n\n\ntimeStamp: Timestamp as Date object or UNIX timestamp in milliseconds\n\nYou can search by passing Date objects to the functions:\nconst results = await myQuery\n.search(\"irys:transactions\")\n.fromTimestamp(new Date(\"2023-07-01\"))\n.toTimestamp(new Date(\"2023-07-03\"));\nOr by using UNIX timestamps in millisecond format:\nconst results = await myQuery\n.search(\"irys:transactions\")\n.fromTimestamp(1688144401000)\n.toTimestamp(1688317201000);\n\nIrys timestamps are accurate to the millisecond, so you need to provide a timestamp in millisecond format. You can\nconvert from human-readable time to UNIX timestamp using websites like Epoch101, be\nsure to convert in millisecond format, not second."}},"/developer-docs/querying/api/ids":{"title":"ids([ids])","data":{"":"Queries either by transaction ID or block ID (depending on the value passed to search()).Parameters\n\n\nids: An array of IDs passed as strings","search-by-transaction-id#Search By Transaction ID":"Use the ids() function to by transaction ID. The search employs OR logic, returning transactions tagged with ANY provided value:\nconst results = await myQuery\n.search(\"irys:transactions\")\n.ids([\"xXyv3u9nHHWGiMJl_DMgLwwRdOTlIlQZyqaK_rOkNZw\",\n\"_xE7tG1kl2FgCUDgJ5jNJeVA6R5kuys7A6f1qfh9_Kw\"]);\nYou can also search Arweave by transaction ID.\nconst results = await myQuery\n.search(\"arweave:transactions\")\n.ids([\"xXyv3u9nHHWGiMJl_DMgLwwRdOTlIlQZyqaK_rOkNZw\",\n\"_xE7tG1kl2FgCUDgJ5jNJeVA6R5kuys7A6f1qfh9_Kw\"]);","search-by-block-id#Search By Block ID":"Use the ids() function to search for Arweave blocks with the specified IDs.\nconst results = await myQuery\n.search(\"arweave:blocks\")\n.ids([\"R0ZLe4RvHxLJLzI1Z9ppyYVWFyHW4D1YrxXKuA9PGrwkk2QAuXCnD1xOJe-QOz4l\"])"}},"/developer-docs/querying/api/limit":{"title":"limit(limitNumber)","data":{"":"Limits the maximum number of results returned. This overrides the default value of 1000 results when searching Irys and 100 when searching Arweave directly.Parameters\n\n\nlimitNumber: The number of results desired\n\n\nconst results = await myQuery\n.search(\"irys:transactions\")\n.ids([\"xXyv3u9nHHWGiMJl_DMgLwwRdOTlIlQZyqaK_rOkNZw\",\n\"_xE7tG1kl2FgCUDgJ5jNJeVA6R5kuys7A6f1qfh9_Kw\"])\n.limit(20);"}},"/developer-docs/querying/api/maxHeight":{"title":"maxHeight(height)","data":{"":"Queries Arweave based on block height, returning all blocks at the specified height and earlier. Commonly used with minHeight().\n\nParameters\n\n\nheight: Block height\n\n\nconst results = await myQuery\n.search(\"arweave:blocks\")\n.minHeight(1188272)\n.maxHeight(1188279);"}},"/developer-docs/querying/api/minHeight":{"title":"minHeight(height)","data":{"":"Queries Arweave based on block height, returning all blocks at the specified height and after. Commonly used with maxHeight().\n\nParameters\n\n\nheight: Block height\n\n\nconst results = await myQuery\n.search(\"arweave:blocks\")\n.minHeight(1188272)\n.maxHeight(1188279);"}},"/developer-docs/querying/api/search":{"title":"irys.search(queryName)","data":{"":"Sets the query type / location.Parameters\n\n\nqueryName: The query type / location.","accepted-values#Accepted Values":"irys:transactions: Searches transactions uploaded to Arweave via any of Irys' nodes\narweave:transactions: Searches all transactions posted to Arweave\narweave:blocks: Searches all of Arweave for a specific block\n\n\nconst results = await myQuery\n.search(\"irys:transactions\")\n.tags([{ name: \"Content-Type\", values: [\"image/png\", \"image/jpg\"] }]);"}},"/developer-docs/querying/api/sort":{"title":"sort(\"ASC\" | \"DESC\")","data":{"":"Sorts query results by timestamp either in ascending or descending format.Parameters- sortType: Either \"ASC\" (ascending) or \"DESC\" (descending)\nconst results = await myQuery.search(\"irys:transactions\").token(\"ethereum\").sort(\"ASC\");\n\nconst results = await myQuery\n.search(\"arweave:transactions\")\n.tags([{ name: \"Content-Type\", values: [\"image/png\", \"image/jpg\"] }]);\n.sort(\"DESC\");"}},"/developer-docs/provenance-toolkit/uploader":{"title":"Uploader","data":{"":"The Uploader component is used to upload either single files or groups of files using a single wallet interaction. Uploads are signed and paid for using the user's wallet.","uploading#Uploading":"The component uses lazy funding, only funding when the currently funded balance is not sufficient to cover the cost of this upload. Once uploaded, file URLs are stored in the fileUrls state variable.When uploading a single file, the URL generated is in the form https://gateway.irys.xyz/[transaction-id]. When uploading multiple files, they are grouped together and uploaded as a group along with a manifest. The URL generated is in the form https://gateway.irys.xyz/[manifest-id]/[file-name].","image--receipt-preview#Image & receipt preview":"Once uploaded, the UI updates to include buttons that can be clicked to view the upload and the upload receipt. When previewing uploads, all image types are supported. If your application is working with files other than images, you can remove the upload preview or modify the code to include support for previewing your file type.If you don't choose to show the receipt, you can retrieve it later using the upload transaction id and the function irys.utils.getReceipt().","customizing-the-ui#Customizing the UI":"In default mode, the Uploader component shows both the image preview and receipt preview buttons. They can be hidden by passing config parameters to the component.\nDescription\tCode\tDefault Behavior\t<Uploder />\tHide the image preview\t<Uploder showImageView={ false } />\tHide the receipt preview\t<Uploder showReceiptView={ false } />\nIf either parameter is left blank, it defaults to true.","code#Code":"The component is designed to be used as-is. Users making significant changes to the UI will need to understand the following.","gateway#Gateway":"To download data uploded to Arweave, use a gateway. The Uploader component is currently configured to use the Arweave gateway, to change this modify this variable.\nconst GATEWAY_BASE = \"https://gateway.irys.xyz/\";","filewrapper#FileWrapper":"The Uploader component wraps the base File object with a FileWrapper instance used to track the file's progress as it gets uploaded.\ninterface FileWrapper {\nfile: File;\nisUploaded: boolean;\nid: string;\npreviewUrl: string;\nloadingReceipt: boolean;\n}","single-file-uploads#Single file uploads":"File uploads happen in the function handleUpload().For single file uploads, first a Content-Type tag is created to assist the browser in rendering the file, then the file is upload and the FileWrapper object is updated.\n// This occurs when exactly one file is selected\ntry {\nfor (const file of files) {\nconst tags: Tag[] = [{ name: \"Content-Type\", value: file.file.type }];\nconst uploadedTx = await fundAndUpload(file.file, tags);\nfile.id = uploadedTx;\nfile.isUploaded = true;\nfile.previewUrl = GATEWAY_BASE + uploadedTx;\n}\n} catch (e) {\nconsole.log(\"Error on upload: \", e);\n}","multiple-file-uploads#Multiple file uploads":"When uploading multiple files at once, they are grouped together as a nested bundle and uploaded with a manifest.\ntry {\n// Remove the File objects from the FileWrapper objects\nconst filesToUpload: File[] = files.map((file) => file.file);\nconsole.log(\"Multi-file upload\");\nconst manifestId = await fundAndUpload(filesToUpload);\n\n// Now that the upload is done, update the FileWrapper objects with the preview URL\nconst updatedFiles = files.map((file) => ({\n...file,\nisUploaded: true,\npreviewUrl: GATEWAY_BASE + manifestId + \"/\" + file.file.name,\n}));\nsetFiles(updatedFiles);\n} catch (e) {\nconsole.log(\"Error on upload: \", e);\n}","showing-receipts#Showing receipts":"When showing a receipt, it is first retrieved using irys.utils.getReceipt() and then set to the receipt state variable.The receipt is formatted in the class ReceiptJSONView, which can be modified if you desire custom formatting.\nconst showReceipt = async (id: string) => {\nsetReceiptQueryProcessing(true);\ntry {\nconst irys = await getIrys();\nconst receipt = await irys.utils.getReceipt(id);\nconsole.log(receipt);\nsetReceipt(receipt);\nsetPreviewURL(\"\"); // Only show one or the other\n} catch (e) {\nconsole.log(\"Error fetching receipt: \" + e);\n}\nsetReceiptQueryProcessing(false);\n};"}},"/developer-docs/querying/api/stream":{"title":"stream()","data":{"":"Returns an iterable stream that continuously yields results as long as your query keeps producing them.\n// Create the stream\nconst stream = await myQuery\n.search(\"irys:transactions\")\n.token(\"solana\")\n.stream();\n\n// Iterate over the results\nfor await (const result of stream) {\nconsole.log(result);\n}"}},"/developer-docs/querying/api/tags":{"title":"tags([{ name, value }])","data":{"":"Queries using metadata tags attached to transactions during upload.\n\nParameters\n\n\n[{ name, value }]: An array of tag name / value pairs\n\nSearch for a single tag name / value pair:\nconst results = await myQuery\n.search(\"irys:transactions\")\n.tags([{ name: \"Content-Type\", values: [\"image/png\"] }]);\nSearch for a single tag name with a list of possible values. The search uses OR logic and returns transactions tagged with ANY provided value:\nconst results = await myQuery\n.search(\"irys:transactions\")\n.tags([{ name: \"Content-Type\", values: [\"image/png\", \"image/jpg\"] }]);\nSearch for multiple tags. The search uses AND logic and returns transactions tagged with ALL provided values:\nconst results = await myQuery.search(\"irys:transactions\")\n.tags([{ name: \"Content-Type\", values: [\"image/png\"] },\n{ name: \"Application-ID\", values: [\"myApp\"] }]);\nYou can also search Arweave by tags:\nconst results = await myQuery\n.search(\"arweave:transactions\")\n.tags([{ name: \"Content-Type\", values: [\"image/png\", \"image/jpg\"] }]);"}},"/developer-docs/querying/api/to":{"title":"to([addresses])","data":{"":"Queries by the wallet addresses used when signing and paying for the upload.Parameters\n\n\naddresses: An array of IDs passed as strings","search-by-transaction-sender#Search By Transaction Sender":"When querying Irys, accepts addresses from any of Irys' supported chains are accepted.\nconst results = await myQuery\n.search(\"irys:transactions\")\n.from([\"UsWPlOBHRyfWcbrlC5sV3-pNUjOQEI5WmDxLnypc93I\",\n\"0x4adDE0b3C686B4453e007994edE91A7832CF3c99\"]);\nWhen querying Arweave, accepts Arweave addresses only.\nconst results = await myQuery\n.search(\"arweave:transactions\")\n.from([\"TrnCnIGq1tx8TV8NA7L2ejJJmrywtwRfq9Q7yNV6g2A\"]);"}},"/developer-docs/querying/api/toTimestamp":{"title":"toTimestamp(timeStamp)","data":{"":"Use the fromTimestamp() and toTimestamp() functions to search for transactions by timestamp. Results returned are >= fromTimestamp and < toTimestamp.\n\nParameters\n\n\ntimeStamp: Timestamp as Date object or UNIX timestamp in milliseconds\n\nYou can search by passing Date objects to the functions:\nconst results = await myQuery\n.search(\"irys:transactions\")\n.fromTimestamp(new Date(\"2023-07-01\"))\n.toTimestamp(new Date(\"2023-07-03\"));\nOr by using UNIX timestamps in millisecond format:\nconst results = await myQuery\n.search(\"irys:transactions\")\n.fromTimestamp(1688144401000)\n.toTimestamp(1688317201000);\n\nIrys timestamps are accurate to the millisecond, so you need to provide a timestamp in millisecond format. You can\nconvert from human-readable time to UNIX timestamp using websites like Epoch101, be\nsure to convert in millisecond format, not second."}},"/developer-docs/querying/api/token":{"title":"token(tokenName)","data":{"":"Queries by token used for payment. Accepts any token supported by Irys.\n\nParameters\n\n\ntokenName: The name of the token\n\n\nconst results = await myQuery\n.search(\"irys:transactions\")\n.token(\"solana\");"}},"/developer-docs/querying/graphql":{"title":"Querying With GraphQL","data":{"":"In addition to the query library, you can also query Irys transactions directly using GraphQL.","irys-vs-arweave-graphql#Irys vs Arweave GraphQL":"This document covers how to query Irys directly, Arweave also has docs on their query schema.","graphql-clients#GraphQL clients":"You can query using an HTTP library like fetch or axios. You can also use specialized clients like Apollo Client or urql.","anatomy-of-a-query#Anatomy of a query":"A GraphQL query is made up of:\nQuery Arguments: Arguments that specify search parameters, limit the number of results returned, or enable pagination.\nResults Fields: Fields that define the data you want to retrieve.","query-arguments#Query arguments":"Any of the following query arguments can be used as search parameters:\nField\tDescription\tids\tAn array of transaction IDs passed as strings. Values are ORed together, matching results will include transactions that have any of the supplied IDs.\towner\tThe address used when posting the transaction. Can be a native address from any of the chains supported by Irys. Note in results fields, this is referred to as address.\ttoken\tThe token used to pay for the transaction.\ttags\tAn array of tag name / value pairs passed as JSON objects.","results-fields#Results fields":"When building a query, any of the following values be included in your results:\nField\tDescription\tid\tThe transaction ID.\taddress\tThe address used when posting the transaction. Can be a native address from any of the chains supported by Irys. Note in query arguements, this is referred to as owner.\ttoken\tThe token used to pay for the transaction.\treceipt {   deadlineHeight   signature    version }\tAn optional receipt, only exists if a user requested one at upload. deadlineHeight: The block number by which the transaction must be finalized on Arweave. signature: A signed deep hash of the JSON receipt.\ttags {      name       value}\tAn array of tags supplied as name / value pairs. Exists if the user added them at upload.\ttimestamp\tThe timestamp, accurate to the millisecond of when the transaction was posted. This value is the same as the receipt timestamp.","endpoints#Endpoints":"Connect to the GraphQL endpoint associated with the node you uploaded your transaction to.\nNode\tEndpoint\tNode 1\thttps://node1.irys.xyz/graphql\tNode 2\thttps://node2.irys.xyz/graphql\tDevnet\thttps://devnet.irys.xyz/graphql","graphql-sandbox#GraphQL sandbox":"Clicking on any of the endpoint URLs above will direct you to the GraphQL Sandbox used for building and testing queries. Press Control+Space at any time to see an interactive popup window of either query arguments or results fields.","sample-queries#Sample queries":"Queries return transaction metadata. To then retrieve data, use the returned transaction ID and download the data from a gateway using a URL formed as follows https://gateway.irys.xyz/[transaction-id].","transaction-ids#Transaction ids":"Search by transaction IDs.\nquery getByIds {\ntransactions(ids: [\"--52WQHJIJod_rni8pkl1Vxt9MFGoXZAm8SC7ex6C1o\", \"--52THRWpX_RJzGcNXmtQ2DSP37d1e1VQ4YmvbY5ZXo\"]) {\nedges {\nnode {\nid\ntags {\nname\nvalue\n}\n}\n}\n}\n}","timestamps#Timestamps":"Search by timestamps:\nquery getByTimestamp {\ntransactions(timestamp: { from: 1688144401000, to: 1688317201000 }) {\nedges {\nnode {\nid\n}\n}\n}\n}\n\nIrys timestamps are accurate to the millisecond, so you need to provide a timestamp in millisecond format. You can\nconvert from human-readable time to UNIX timestamp using websites like Epoch101, be\nsure to convert in millisecond format, not second.","owners#Owners":"Search for transactions matching the wallet address used when posting the transaction:\nquery getByOwner {\ntransactions(owners: [\"0xBcb812C6e26F4F0F78Bd7B6222461FF24F2942AE\", \"0xaC568a981B1370B2e1bAA8cE30BD5AC9E28C572D\"]) {\nedges {\nnode {\nid\naddress\n}\n}\n}\n}","tags#Tags":"Search for transactions matching tag name / value pairs:\nquery getAllPNGs {\ntransactions(tags: [{ name: \"Content-Type\", values: [\"image/png\"] }]) {\nedges {\nnode {\nid\naddress\n}\n}\n}\n}\nSearch for transactions matching the tag with name Content-Type and the values of image/png OR image/jpg:\nquery getTagsWithOR {\ntransactions(tags: [{ name: \"Content-Type\", values: [\"image/png\", \"image/jpg\"] }]) {\nedges {\nnode {\ntags {\nname\nvalue\n}\n}\n}\n}\n}\nSearch for transactions matching the tag with name Content-Type and the values of image/png AND image/jpg:\nquery getTagsWithAnd {\ntransactions(\ntags: [{ name: \"Content-Type\", values: [\"image/jpg\"] }, { name: \"Content-Type\", values: [\"image/png\"] }]\n) {\nedges {\nnode {\ntags {\nname\nvalue\n}\n}\n}\n}\n}","limiting-results#Limiting results":"Limit the number of results returned by including the limit parameter:\nquery getAllPNGs {\ntransactions(limit: 10, tags: [{ name: \"Content-Type\", values: [\"image/png\"] }]) {\nedges {\nnode {\nid\naddress\n}\n}\n}\n}","pagination#Pagination":"You can request a maximum of 100 results returned from each query, to obtain additional results use pagination.When using pagination you:\nRetrieve the cursor field, this acts like a bookmark in the search results you can then return to.\nUse saved cursor value to obtain subsequent search results.\n\nThe following query returns 10 transactions tagged image/png occurring after the cursor with value: LS02d1NsM3R6aUprd3dKUzVjN1FXaWg5aUxsbXh5dVJJbGlydHJtNlpPbw. To then obtain the next 10 transactions, use the final cursor value returned from this query as the value of the after parameter in the following query.\nquery getPNGs {\ntransactions(\nlimit: 10\ntags: [{ name: \"Content-Type\", values: [\"image/png\"] }]\nafter: \"LS02d1NsM3R6aUprd3dKUzVjN1FXaWg5aUxsbXh5dVJJbGlydHJtNlpPbw\"\n) {\nedges {\nnode {\nid\n}\ncursor\n}\n}\n}","sorting#Sorting":"You can sort results by timestamp in either ascending or descending order using the order field.\nquery getAllByOwnerAsc {\ntransactions(owners: [\"0xBcb812C6e26F4F0F78Bd7B6222461FF24F2942AE\"], order: ASC) {\nedges {\nnode {\nid\naddress\n}\n}\n}\n}\n\nquery getAllByOwnerDesc {\ntransactions(owners: [\"0xBcb812C6e26F4F0F78Bd7B6222461FF24F2942AE\"], order: DESC) {\nedges {\nnode {\nid\naddress\n}\n}\n}\n}"}},"/developer-docs/tags":{"title":"Metadata Tagging","data":{"":"Irys supports attaching metadata tags to each transaction.Tags can be used to:\nCategorize transactions, making it easier to search for and retrieve relevant information\nBuild mutable references\nInform web browsers how to render files","querying#Querying":"Tags are indexed by gateways and are queryable using the Irys query package and GraphQL.","content-type#Content-Type":"The Irys CLI automatically infers and sets the appropriate Content-Type tag based on the file extension when uploading files and folders.If your use case necessitates manual Content-Type tag setting, you can specify it during the upload process. Doing so will override the default behavior and apply the Content-Type you provided.\n// Your file\nconst fileToUpload = \"./myImage.png\";\n\n// Add a custom Content-Type tag\nconst tags = [{ name: \"Content-Type\", value: \"image/png\" }];\n\ntry {\nconst response = await irys.uploadFile(fileToUpload, { tags });\nconsole.log(`File uploaded ==> https://gateway.irys.xyz/${response.id}`);\n} catch (e) {\nconsole.log(\"Error uploading file \", e);\n}\nYou can also add tags via the CLI's -t option, followed by a series of name / value pairs\nirys upload myImage.png -t tagName1 tagValue1 tagName2 tagValue2 -h https://node1.irys.xyz -t matic -w bf20......c9885307","additional-uses#Additional Uses":"There are no limits on the number of tags you can append to your files or folders. You're free to add as many tags as you wish, enabling the construction of semi-relational models within your data.A popular practice involves creating an application-id tag, this tag helps segregate your uploads from others.\n// Your file\nconst fileToUpload = \"./myNFT.png\";\n\nconst tags = [{ name: \"application-id\", value: \"NFTs To The Moon\" }];\n\ntry {\nconst response = await irys.uploadFile(fileToUpload, { tags });\nconsole.log(`File uploaded ==> https://gateway.irys.xyz/${response.id}`);\n} catch (e) {\nconsole.log(\"Error uploading file \", e);\n}"}},"/developer-docs/using-devnet":{"title":"Using Devnet","data":{"":"Uploads to Irys' Devnet are paid for using free faucet tokens and are kept for approximately 60 days. Devnet is for developers who are building projects or learning how to use our SDK.To connect to Devnet, supply the address of our Devnet node when instantiating either an Irys or WebIrys object.","rpc--provider-url#RPC / Provider URL":"When using Devnet with the Irys class and with our CLI, you must specify an RPC address. When using the WebIrys class, the RPC address is only required when using non-EVM chains.\nIf you encounter this message when using our SDK or CLI, make sure you are supplying the correct RPC URL for the chain you're using.Using devnet.irys.xyz requires a dev/testnet RPC to be configured!","irys-class-server-side#Irys Class (Server-side)":"","evm-chains#EVM Chains":"const getIrys = async () => {\nconst url = \"https://devnet.irys.xyz\";\nconst token = \"matic\";\n// Devnet RPC URLs change often, use a recent one from https://chainlist.org/chain/80001\nconst providerUrl = \"\";\n\nconst irys = new Irys({\nurl, // URL of the node you want to connect to\ntoken, // Token used for payment\nkey: process.env.EVM_PRIVATE_KEY, // EVM private key\nconfig: { providerUrl }, // Optional provider URL, only required when using Devnet\n});\nreturn irys;\n};","solana#Solana":"const getIrys = async () => {\nconst url = \"https://devnet.irys.xyz\";\nconst token = \"solana\";\nconst providerUrl = \"https://api.devnet.solana.com\";\n\nconst irys = new Irys({\nurl, // URL of the node you want to connect to\ntoken, // Token used for payment\nkey: process.env.SOL_PRIVATE_KEY, // SOL private key\nconfig: { providerUrl }, // Optional provider URL, only required when using Devnet\n});\nreturn irys;\n};","webirys-class-browser#WebIrys class (Browser)":"","evm-chains-1#EVM Chains":"const getWebIrys = async () => {\n// Ethers5 provider\nawait window.ethereum.enable();\nconst provider = new providers.Web3Provider(window.ethereum);\n\nconst url = \"https://devnet.irys.xyz\";\nconst token = \"matic\";\n// Devnet RPC URLs change often, use a recent one from https://chainlist.org\nconst rpcURL = \"\"; // Required\n\n// Create a wallet object\nconst wallet = { rpcUrl: rpcURL, name: \"ethersv5\", provider: provider };\n// Use the wallet object\nconst webIrys = new WebIrys({ url, token, wallet });\nawait webIrys.ready();\n\nreturn webIrys;\n};","solana-1#Solana":"const getWebIrys = async () => {\nawait window.solana.connect();\nconst provider = new PhantomWalletAdapter();\nawait provider.connect();\n\nconst url = \"https://devnet.irys.xyz\";\nconst token = \"solana\";\nconst rpcURL = \"https://api.devnet.solana.com\"; // Required\n\n// Create a wallet object\nconst wallet = { rpcUrl: rpcURL, name: \"ethersv5\", provider: provider };\n// Use the wallet object\nconst webIrys = new WebIrys({ url, token, wallet });\nawait webIrys.ready();\n\nreturn webIrys;\n};","cli#CLI":"See CLI documentation for examples of how to use each command with our Devnet.\nirys upload myImage.png \\\n-h https://devnet.irys.xyz \\\n-t matic \\\n-w bf20......c9885307 \\\n--tags tagName1 tagValue1 tagName2 tagValue2 \\\n--provider-url https://rpc-mumbai.maticvigil.com\n\nDevnet RPC URLs change often, use a recent one from https://chainlist.org/chain/80001"}},"/developer-docs/querying/query-package":{"title":"Query Package","data":{"":"The query package enables users to search Irys and Arweave through an intuitive JavaScript package. It is easily implemented in a few lines of code.\nThe query package is for searching transaction metadata on Irys and Arweave, and also Arweave block information. Once you've found transactions, use the transaction ID to download the associated data.","installation#Installation":"Install via npm:\nnpm install @irys/query\nand yarn:\nyarn add @irys/query","imports#Imports":"Import with:\nimport Query from \"@irys/query\";","creating-a-query-object#Creating a Query object":"Start by instantiating a new Query object, this is a shared instance you can reuse each time you want to execute a new query.\nconst myQuery = new Query();\nThen execute a query by chaining together a series of functions that collaboratively narrow down the results returned.To retrieve the 20 latest transactions with the tag Content-Type set to image/png on Irys:\nconst results = await myQuery\n.search(\"irys:transactions\")\n.tags([{ name: \"Content-Type\", values: [\"image/png\"] }])\n.sort(\"ASC\")\n.limit(20);","endpoints#Endpoints":"The Query class links to a GraphQL endpoint for query execution, defaulting to https://node1.irys.xyz/graphql for Irys and https://gateway.irys.xyz/graphql for Arweave.When querying Irys, you must query the same node you uploaded to. To change the endpoint, pass any of the following to the Query object constructor:\nhttps://node1.irys.xyz/graphql (Default)\nhttps://node2.irys.xyz/graphql\nhttps://devnet.irys.xyz/graphql\n\nWhen querying Arweave, any of these may be used:\nhttps://arweave.net/graphql (Default)\nhttps://arweave.dev/graphql\nhttps://arweave-search.goldsky.com/graphql\n\n\nconst myQuery = new Query({ url: \"https://devnet.irys.xyz/graphql\" });","query-type#Query type":"Using the Query class users can search any of:\nIrys transactions\nArweave transactions\nArweave blocks\n\nThe search location is specified by passing a parameter to the search() function.\nconst results = await myQuery.search(\"irys:transactions\");\nThe selected search type influences the returned fields and the availability of specific query functions.\nFunction\tirys:transactions\tarweave:transactions\tarweave:blocks\tsearch()\tYes\tYes\tYes\ttags()\tYes\tYes\tNo\tids()\tYes\tYes\tYes\tfrom()\tYes\tYes\tNo\tto()\tNo\tYes\tNo\ttoken()\tYes\tNo\tNo\tfromTimestamp()\tYes\tNo\tYes\ttoTimestamp()\tYes\tNo\tYes\tminHeight()\tNo\tNo\tYes\tmaxHeight()\tNo\tNo\tYes\tsort()\tYes\tYes\tYes\tlimit()\tYes\tYes\tYes\tstream()\tYes\tYes\tYes\tfields()\tYes\tYes\tYes","timestamp#Timestamp":"Use the fromTimestamp() and toTimestamp() functions to search for transactions by timestamp. Results returned are >= fromTimestamp and < toTimestamp.You can search by passing Date objects to the functions:\nconst results = await myQuery\n.search(\"irys:transactions\")\n.fromTimestamp(new Date(\"2023-07-01\"))\n.toTimestamp(new Date(\"2023-07-03\"));\nOr by using UNIX timestamps in millisecond format:\nconst results = await myQuery\n.search(\"irys:transactions\")\n.fromTimestamp(1688144401000)\n.toTimestamp(1688317201000);\n\nIrys timestamps are accurate to the millisecond, so you need to provide a timestamp in millisecond format. You can\nconvert from human-readable time to UNIX timestamp using websites like Epoch101, be\nsure to convert in millisecond format, not second.","tags#Tags":"Use the tags() function to search metadata tags attached to transactions during upload.Search for a single tag name / value pair:\nconst results = await myQuery\n.search(\"irys:transactions\")\n.tags([{ name: \"Content-Type\", values: [\"image/png\"] }]);\nSearch for a single tag name with a list of possible values. The search uses OR logic and returns transactions tagged with ANY provided value.\nconst results = await myQuery\n.search(\"irys:transactions\")\n.tags([{ name: \"Content-Type\", values: [\"image/png\", \"image/jpg\"] }]);\nSearch for multiple tags. The search uses AND logic and returns transactions tagged with ALL provided values.\nconst results = await myQuery.search(\"irys:transactions\").tags([\n{ name: \"Content-Type\", values: [\"image/png\"] },\n{ name: \"Application-ID\", values: [\"myApp\"] },\n]);\nYou can also search Arweave by tags:\nconst results = await myQuery\n.search(\"arweave:transactions\")\n.tags([{ name: \"Content-Type\", values: [\"image/png\", \"image/jpg\"] }]);","transaction-id#Transaction id":"Use the ids() function to by transaction ID. The search uses OR logic and returns transactions tagged with ANY provided value:\nconst results = await myQuery\n.search(\"irys:transactions\")\n.ids([\"xXyv3u9nHHWGiMJl_DMgLwwRdOTlIlQZyqaK_rOkNZw\", \"_xE7tG1kl2FgCUDgJ5jNJeVA6R5kuys7A6f1qfh9_Kw\"]);\nYou can also search Arweave by transaction ID.\nconst results = await myQuery\n.search(\"arweave:transactions\")\n.ids([\"xXyv3u9nHHWGiMJl_DMgLwwRdOTlIlQZyqaK_rOkNZw\", \"_xE7tG1kl2FgCUDgJ5jNJeVA6R5kuys7A6f1qfh9_Kw\"]);","transaction-sender#Transaction sender":"Use the from() function to search by wallet addresses used when signing and paying for the upload. Addresses from any of Irys' supported chains are accepted.The search employs OR logic, returning transactions tagged with ANY provided value:\nconst results = await myQuery\n.search(\"irys:transactions\")\n.from([\"UsWPlOBHRyfWcbrlC5sV3-pNUjOQEI5WmDxLnypc93I\", \"0x4adDE0b3C686B4453e007994edE91A7832CF3c99\"]);\nWhen searching Arweave by transaction sender, only Arweave addresses are accepted:\nconst results = await myQuery\n.search(\"arweave:transactions\")\n.from([\"TrnCnIGq1tx8TV8NA7L2ejJJmrywtwRfq9Q7yNV6g2A\"]);","transaction-recipient#Transaction recipient":"Use the to() function to search for the wallet address of the transaction recipient. This works on Arweave only and is used when there's a fund transfer.\nconst results = await myQuery\n.search(\"arweave:transactions\")\n.to(\"TrnCnIGq1tx8TV8NA7L2ejJJmrywtwRfq9Q7yNV6g2A\");","token#Token":"Use the token() function to search based on the token name used to pay for the upload. Any of these values are acceptable.\nconst results = await myQuery\n.search(\"irys:transactions\")\n.token(\"solana\");","block-id#Block id":"Use the ids() function to search for Arweave blocks with the specified IDs.\nconst results = await myQuery\n.search(\"arweave:blocks\")\n.ids([\"R0ZLe4RvHxLJLzI1Z9ppyYVWFyHW4D1YrxXKuA9PGrwkk2QAuXCnD1xOJe-QOz4l\"]);","block-height#Block height":"Use the mixHeight() and maxHeight() functions to search for blocks within the specified block height range. Results are >= minHeight and < maxHeight.\nconst results = await myQuery\n.search(\"arweave:blocks\")\n.minHeight(1188272)\n.maxHeight(1188279);\nOr for transactions within the specified block height range. Results are >= minHeight and < maxHeight.\nconst results = await myQuery\n.search(\"arweave:transactions\")\n.minHeight(1188272)\n.maxHeight(1188279);","sorting#Sorting":"Use the sort() function to sort results by timestamp in ascending order:\nconst results = await myQuery\n.search(\"irys:transactions\")\n.token(\"ethereum\")\n.sort(\"ASC\");\nor descending order:\nconst results = await myQuery\n.search(\"irys:transactions\")\n.token(\"matic\")\n.sort(\"DESC\");","first-result#First result":"Use the first() function to return only the first result:\nconst results = await myQuery\n.search(\"irys:transactions\")\n.tags([{ name: \"Content-Type\", values: [\"image/png\"] }])\n.first();","limiting-search-results#Limiting search results":"Use the limit() function to limit the maximum number of results returned. This overrides the default value of 1000 results when searching Irys and 100 when searching Arweave directly.\nconst results = await myQuery\n.search(\"irys:transactions\")\n.ids([\"xXyv3u9nHHWGiMJl_DMgLwwRdOTlIlQZyqaK_rOkNZw\", \"_xE7tG1kl2FgCUDgJ5jNJeVA6R5kuys7A6f1qfh9_Kw\"])\n.limit(20);","pagination--streaming#Pagination / streaming":"Use the stream() function to manage large results sets. This function returns an iterable stream that continuously yields results as long as your query keeps producing them.\n// Create the stream\nconst stream = await myQuery\n.search(\"irys:transactions\")\n.token(\"solana\")\n.stream();\n\n// Iterate over the results\nfor await (const result of stream) {\nconsole.log(result);\n}","limiting-fields-returned#Limiting fields returned":"Use the fields() function to limit the fields returned. To limit the results, set a field's value to false or omit it entirely.The fields available for retrieval depend on the search type, when searching irys:transactions, the following fields are available:\n.fields({\nid: true, // Transaction ID\ntoken: true, // Token used for payment\naddress: true, // Cross-chain address used for signing and payment\nreceipt: {\ndeadlineHeight: true, // The block number by which the transaction must be finalized on Arweave\nsignature: true, // A signed deep hash of the JSON receipt\ntimestamp: true, // Timestamp, millisecond accurate, of the time the uploaded was verified\nversion: true, // The receipt version, currently 1.0.0\n},\ntags: { // An array of tags associated with the upload\nname: true,\nvalue: true,\n},\nsignature: true, // A signed deep hash of the JSON receipt\ntimestamp: true, // Timestamp, millisecond accurate, of the time the uploaded was verified\n})\nWhen searching by arweave:transactions the following fields are available:\n.fields({\nid: true, // Transaction ID\ntags: {\n// Tags associated with the upload\nname: true,\nvalue: true,\n},\nanchor: true,\nblock: {\nheight: true, // Block height\nid: true, // Block ID\nprevious: true, // Todo\ntimestamp: true, // Block timestamp\n},\nbundledIn: {\nid: true,\n},\ndata: {\nsize: true, // Data size\ntype: true, // Date type\n},\nfee: {\nar: true, // Fee paid in AR\nwinston: true, // Fee paid in Winston\n},\nowner: {\naddress: true, // Transation originator\nkey: true, // Public key\n},\nquantity: {\nar: true, // Amount of AR transferred (for token transfers)\nwinston: true, // Amount of AR transferred (for token transfers)\n},\nrecipient: true, // Transfer recipient (for token transfers)\nsignature: true, // Transaction signature\n})\nWhen searching by arweave:blocks the following fields are available:\n.fields({\nheight: true,\nid: true,\nprevious: true,\ntimestamp: true,\n})"}},"/faqs/general-faq":{"title":"General FAQ","data":{"":"","𝗪𝗵𝗮𝘁-𝗶𝘀-irys#𝗪𝗵𝗮𝘁 𝗶𝘀 Irys?":"Irys is the only provenance layer. It enables users to scale permanent data and precisely attribute its origin. By tracing and verifying where data comes from, Irys paves the way to incorporate accountability into all information.","what-is-a-provenance-layer#What is a provenance layer?":"A provenance layer acts as a ledger of record for digital information, tracking the origins and modifications of data. Data on a provenance layer must be permanent, precise, and unconstrained.","why-bundlr-has-been-renamed-to-irys#Why Bundlr has been renamed to Irys?":"Bundlr has evolved into Irys, symbolizing our commitment to being a strong provenance layer and a witness for humanity. Learn more about our mission, vision, and network principles in this .","is-there-a-terminology-page-for-irys#Is there a terminology page for Irys?":"Yes.","what-is-arweave#What is Arweave?":"Arweave enables permanent onchain data, which is a core component of strong provenance. Arweave offers a sustainable and perpetual endowment, allowing users and developers to store data for at least 200 years. With Arweave, valuable information, apps, and history are preserved indefinitely, preventing any rewriting of the past.","how-does-irys-work#How does Irys work?":"When you upload data to Irys, it is stamped with a millisecond-accurate timestamp, attribution, and authorship details before being passed to Arweave where it is stored permanently. For more details, see our docs.","where-should-i-subscribe-to-receive-the-latest-news#Where should I subscribe to receive the latest news?":"Please follow us on Discord and X (Twitter) to keep up with the latest updates and news.","is-there-a-public-sale-airdrop-etc#Is there a public sale, airdrop, etc?":"We do not have a token. Anyone claiming a presale, token airdrop, etc is presenting inaccurate information. Please follow Irys announcements on Discord and X (Twitter).","what-tokens-does-irys-support#What tokens does Irys support?":"We support 14 different tokens, covering all of the most popular ones."}},"/hands-on/quests":{"title":"Quests","data":{"":"Developer quests\n\n\nJoin a global community of over 40,000 developers building on Irys.\n\nEarn unique NFTs for each quest you complete!\n\n\n\nSeason 1 quests are currently closed to new submissions.\n\nSeason 2 is launching soon. Stay tuned!"}},"/hands-on/tutorials":{"title":"Tutorials","data":{"":"Guides & Tutorials\n\n\n\n\n\n\n\nUse Irys with npx create-react-app\nUse Irys with React + Vite\nLearn the Irys SDK\nMonitor node balance with a script\nUpload a website to the permaweb\nUse Livepeer to transcode video\nBuild a transaction explorer\nPerform gasless uploads\n\n\n\n\n\n\nPermanently upload NFT assets\nBuild a Solana NFT Marketplace With Metaplex\nBuild a dynamic NFT\n\n\n\n\n\n\nDefine NFT licensing with UDL\nCreate an ERC20 token to manage UDL ownership\n\n\n\n\n\n\nUpload Lens metadata\n\n\n\n\n\n\nEncrypting onchain data overview\nEncrypting data server-side\nEncrypting data in the browser"}},"/faqs/dev-faq":{"title":"Developer FAQ","data":{"":"","what-is-the-difference-between-node-1-and-2#What is the difference between Node 1 and 2?":"Node 2 is ideal for early-stage projects, while larger projects typically prefer Node 1 as it can scale to a higher TPS. Uploads of less than 100 KiB are currently free on Node 2.Nodes maintain separate balances; fund the node you intend to upload to.","does-irys-offer-free-uploads#Does Irys offer free uploads?":"Yes. Uploads below 100KiB are free on Node 2 only. This is a public good for users to be encouraged to try Irys.","how-do-i-set-up-a-devnet-wallet-and-fund-it-with-free-faucet-tokens#How do I set up a Devnet wallet and fund it with free faucet tokens?":"Our Devnet is free to use, however to mirror the DX of working on our main nodes, you'll need to fund it with free faucet tokens. You can use any EVM or Solana wallet, however, beginners will likely want to use either Metamask for EVM chains and Phantom for both Solana and EVM chains.Devnet tokens can be obtained for free from common faucets like the ones for Solana, Sepolia and Mumbai.","what-is-the-difference-between-irys-and-webirys-classes#What is the difference between Irys and WebIrys classes?":"The Irys class is used for server-side apps and WebIrys is used when building with Irys in the browser.","how-do-i-use-webirys-in-a-create-react-app-project#How do I use WebIrys in a `create-react-app`` project?":"Follow this tutorial.","can-i-host-a-website-using-irys#Can I host a website using Irys?":"Yes. You can host static websites. We have a tutorial on how to do it here.","is-it-possible-to-assign-an-api-key-to-a-funded-irys-account-so-that-i-can-pay-for-my-clients-uploads#Is it possible to assign an API key to a funded Irys account so that I can pay for my client's uploads?":"No, but we do support gasless uploads.","which-ethereum-testnet-is-supported-on-devnet#Which Ethereum Testnet is supported on Devnet?":"Sepolia.","are-irys-nodes-rate-limited#Are Irys nodes rate-limited?":"There are no rate-limits on paid-for uploads.Uploads below 100 KiB are free on Node 2, these uploads are rate-limited. If you upload more than 600 transactions within a minute and have a funded balance on Node 2 that balance will be used to pay for the transaction. If you don't have a balance, then you'll get a 402 - Free transaction limit exceeded, funds required error.","is-it-possible-to-know-an-uploads-id-before-uploading#Is it possible to know an upload’s ID before uploading?":"Yes. You can create/sign/upload transactions in multiple steps.","what-is-the-format-of-the-transaction-id#What is the format of the transaction ID?":"It is 32 bytes base64url encoded.","is-there-an-expected-maxmin-length-of-a-transaction-id#Is there an expected max/min length of a transaction ID?":"43 bytes.","is-there-a-max-size-limit-for-an-upload#Is there a max size limit for an upload?":"No","how-soon-after-i-upload-data-is-it-available-for-download#How soon after I upload data is it available for download?":"Our optimistic cache makes it available instantly.","where-can-i-see-my-data-before-it-gets-seeded-onto-arweave#Where can I see my data before it gets seeded onto Arweave?":"As soon as your upload is complete, the data can be requested from a gateway.","how-does-the-arweave-endowment-help-ensure-data-permanence#How does the Arweave endowment help ensure data permanence?":"For data to be permanent, it must be fault-tolerant, tamper-proof, and paid-for. When you upload data to Irys, you pay a single up-front fee that covers paying for storage today and far into the future.Arweave estimates storage costs using the Kryder+ rate, the exponential rate at which digital storage capacities increase over time. Data from past years shows the rate is 38%, meaning the physical cost to store 1 Gig of data has decreased by 38% yearly. Arweave charges a base fee that covers storing 20 replicas of your data for 200 years (assuming a very conservative 0.5% yearly decrease in storage costs). This base fee is then multiplied by 1.05, the additional 5% is paid to the miner who includes your transaction in a winning block, and the remainder is reserved for funding future storage via the Arweave endowment.Arweave's models demonstrate the endowment's longevity under various projections of decreasing storage costs with the main scenario indicating adequate funds for approximately 10,000 years of storage.","what-happens-to-storage-costs-if-the-price-of-ar-moons#What happens to storage costs if the price of AR moons?":"Storage costs are denominated in AR and may rise temporarily with an increase in the token's price. However, this uptick in cost is offset as higher block rewards lead to more competition among miners. In response, miners expand their storage capacity, which, in turn, brings down the cost of data storage.Short-term price fluctuations are also accounted for as down-side token volatility is offset by up-side token volatility. As people purchase storage, contributions to the endowment made when the token price is lower are offset by contributions made when the price is higher."}},"/hands-on/tutorials/gasless-uploading":{"title":"Gasless Uploading With Server-Side Signing","data":{"":"Server-side signing is a method to allow you to sign (and pay) for your users' data securely (without exposing your private key). It is a form of gasless transactions.Server-side signing works in 4 main steps:\nThe client requests the required information from the server (mainly public key).\nThe client transfers the minimum amount of data required for signing (known as the signature info) to a server (which has access to the private key).\nThe server then signs this data and returns the resulting signature to the client.\nThe client then inserts this signature into their data, resulting in a signed transaction identical to if the client had access to the private key.","supported-currencies#Supported Currencies":"Currently, server-side signing is supported for the following:\nEthereum\nMatic\nBNB\nFantom\nAvalanche\nBoba-Eth\nArbitrum\nChainlink\nBoba\nSolana","getting-started#Getting Started":"The quickest way to get started is to clone our example repository which supports gasless uploads from both EVM and Solana chains.We also have an online demo available as part of the Provenance Toolkit.","api-routes#API Routes":"The example app exposes three API routes, you can pick and choose which to use based on your own app design.","publickeyts#publicKey.ts":"The route publicKey.ts returns the public key for the server's wallet. This is the first route called by the client.","solana-based-wallets#Solana-Based Wallets":"import { TypedEthereumSigner } from \"arbundles\";\nimport { NextResponse } from \"next/server\";\nimport Irys from \"@irys/sdk\";\n\n/**\n* @returns The server's public key.\n*/\nasync function serverInit(): Promise<Buffer> {\nconst key = process.env.PRIVATE_KEY_SOL;\nconst token = \"solana\";\nconst url = process.env.NEXT_PUBLIC_NODE || \"\";\n// Change if deploying on mainnet\nconst providerUrl = \"https://api.devnet.solana.com\";\nconst serverIrys = new Irys({\nurl, // URL of the node you want to connect to\ntoken, // Token used for payment and signing\nkey: key,\nconfig: { providerUrl }, // Only required when using Devnet\n});\nconst publicKey = serverIrys.tokenConfig.getSigner().publicKey;\nreturn publicKey;\n}\n\nexport async function GET(req: Request) {\nreturn NextResponse.json({ pubKey: (await serverInit()).toString(\"hex\") });\n}","evm-based#EVM-Based":"import { TypedEthereumSigner } from \"arbundles\";\nimport { NextResponse } from \"next/server\";\n\n/**\n* @returns The server's public key.\n*/\nasync function serverInit(): Promise<Buffer> {\nconst key = process.env.PRIVATE_KEY_EVM; // your private key;\nif (!key) throw new Error(\"Private key is undefined!\");\nconst signer = new TypedEthereumSigner(key);\nreturn signer.publicKey;\n}\n\nexport async function GET(req: Request) {\nreturn NextResponse.json({ pubKey: (await serverInit()).toString(\"hex\") });\n}","signdatats#signData.ts":"The route signData.ts signs the data provided using the server's private key. This is the second route called by the client.","solana-based-wallets-1#Solana-Based Wallets":"import type { NextApiRequest, NextApiResponse } from \"next\";\nimport { TypedEthereumSigner } from \"arbundles\";\nimport { NextResponse } from \"next/server\";\nimport Irys from \"@irys/sdk\";\nimport HexInjectedSolanaSigner from \"arbundles/build/web/esm/src/signing/chains/HexInjectedSolanaSigner\";\n\n/**\n*\n* @returns A signed version of the data, signatureData, as sent by the client.\n*/\nasync function signDataOnServer(signatureData: Buffer): Promise<Buffer> {\nconst key = process.env.PRIVATE_KEY_SOL;\nconst token = \"solana\";\nconst url = process.env.NEXT_PUBLIC_NODE || \"\";\n// Change if deploying on mainnet\nconst providerUrl = \"https://api.devnet.solana.com\";\n\nconst serverIrys = new Irys({\nurl, // URL of the node you want to connect to\ntoken, // Token used for payment and signing\nkey: key,\nconfig: { providerUrl }, // Only required when using Devnet\n});\n\nconst encodedMessage = Buffer.from(signatureData);\n\nconst signature = await serverIrys.tokenConfig.sign(encodedMessage);\n\nconst isValid = await HexInjectedSolanaSigner.verify(\nserverIrys.tokenConfig.getPublicKey() as Buffer,\nsignatureData,\nsignature,\n);\n\nreturn Buffer.from(signature);\n}\n\nasync function readFromStream(stream: ReadableStream): Promise<string> {\nconst reader = stream.getReader();\nlet result = \"\";\n\nwhile (true) {\nconst { done, value } = await reader.read();\nif (done) break;\nresult += new TextDecoder().decode(value);\n}\n\nreturn result;\n}\n\nexport async function POST(req: Request) {\n//@ts-ignore\nconst rawData = await readFromStream(req.body);\nconst body = JSON.parse(rawData);\n\nconst signatureData = Buffer.from(body.signatureData, \"hex\");\nconst signature = await signDataOnServer(signatureData);\n\nreturn NextResponse.json({ signature: signature.toString(\"hex\") });\n}","evm-based-1#EVM-Based":"import type { NextApiRequest, NextApiResponse } from \"next\";\nimport { TypedEthereumSigner } from \"arbundles\";\nimport { NextResponse } from \"next/server\";\n\n/**\n*\n* @returns A signed version of the data, signatureData, as sent by the client.\n*/\nasync function signDataOnServer(signatureData: Buffer): Promise<Buffer> {\nconst key = process.env.PRIVATE_KEY_EVM;\nif (!key) throw new Error(\"Private key is undefined!\");\nconst signer = new TypedEthereumSigner(key);\nreturn Buffer.from(await signer.sign(signatureData));\n}\n\nasync function readFromStream(stream: ReadableStream): Promise<string> {\nconst reader = stream.getReader();\nlet result = \"\";\n\nwhile (true) {\nconst { done, value } = await reader.read();\nif (done) break;\nresult += new TextDecoder().decode(value);\n}\n\nreturn result;\n}\n\nexport async function POST(req: Request) {\n//@ts-ignore\nconst rawData = await readFromStream(req.body);\nconst body = JSON.parse(rawData);\n\nconst signatureData = Buffer.from(body.signatureData, \"hex\");\nconst signature = await signDataOnServer(signatureData);\n\nreturn NextResponse.json({ signature: signature.toString(\"hex\") });\n}","lazyfundts#lazyFund.ts":"The route lazyFund.ts is an optional route used for lazy-funding uploads. Some projects using server-side signing prefer to do upfront funding where they transfer over a budget of tokens first and then slowly use those to pay for uploads. If you're using upfront funding, you can omit this step.To perform lazy-funding of uploads, pass the exact number of bytes you want to fund to this route. The route will compute the current cost to upload those bytes and fund it using the server's private key.","solana-based-wallets-2#Solana-Based Wallets":"import Irys from \"@irys/sdk\";\nimport getRpcUrl from \"@/app/utils/getRpcUrl\";\nimport { NextResponse } from \"next/server\";\nimport { ReadableStream } from \"stream/web\";\n\n/**\n* Given a file of the specified size, get the cost to upload, then fund a node that amount\n* @param filesize The size of a file to fund for\n* @returns\n*/\nasync function lazyFund(filesize: string): Promise<string> {\nconsole.log(\"lazyFund SOL\");\n\nconst key = process.env.PRIVATE_KEY_SOL;\nconst token = \"solana\";\nconst url = process.env.NEXT_PUBLIC_NODE || \"\";\n// Change if deploying on Mainnet\nconst providerUrl = \"https://api.devnet.solana.com\";\n\nconst serverIrys = new Irys({\nurl, // URL of the node you want to connect to\ntoken, // Token used for payment and signing\nkey: key,\nconfig: { providerUrl }, // Only required when using Devnet\n});\n\nconst price = await serverIrys.getPrice(parseInt(filesize));\nconsole.log(\"lazyFund SOL price=\", price);\n\nconst balance = await serverIrys.getLoadedBalance();\nconsole.log(\"lazyFund SOL balance=\", balance);\n\nlet fundTx;\nif (price.isGreaterThanOrEqualTo(balance)) {\nconsole.log(\"Funding node.\");\nfundTx = await serverIrys.fund(price);\nconsole.log(\"Successfully funded fundTx=\", fundTx);\n} else {\nconsole.log(\"Funding not needed, balance sufficient.\");\n}\n\n// return the transaction id\nreturn fundTx?.id || \"\";\n}\n\nasync function readFromStream(stream: ReadableStream<Uint8Array> | null): Promise<string> {\nif (!stream) return \"\";\nconst reader = stream.getReader();\nlet result = \"\";\n\nwhile (true) {\nconst { done, value } = await reader.read();\nif (done) break;\nresult += new TextDecoder().decode(value);\n}\n\nreturn result;\n}\n\nexport async function POST(req: Request) {\n//@ts-ignore\nconst rawData = await readFromStream(req.body as ReadableStream<Uint8Array> | null);\n\nconst body = JSON.parse(rawData);\nconst fundTx = await lazyFund(body);\n\nreturn NextResponse.json({ txResult: fundTx });\n}","evm-based-2#EVM-Based":"import Irys from \"@irys/sdk\";\nimport getRpcUrl from \"@/app/utils/getRpcUrl\";\nimport { NextResponse } from \"next/server\";\nimport { ReadableStream } from \"stream/web\";\n\n/**\n* Given a file of the specified size, get the cost to upload, then fund a node that amount\n* @param filesize The size of a file to fund for\n* @returns\n*/\nasync function lazyFund(filesize: string): Promise<string> {\nconst key = process.env.PRIVATE_KEY_EVM;\nconst token = process.env.NEXT_PUBLIC_TOKEN || \"\";\nconst url = process.env.NEXT_PUBLIC_NODE || \"\";\nconst providerUrl = getRpcUrl(token || \"\");\n\nconst serverIrys = new Irys({\nurl, // URL of the node you want to connect to\ntoken, // Token used for payment and signing\nkey: key,\nconfig: { providerUrl }, // Only required when using Devnet\n});\nconsole.log(\n\"serverIrysPubKey\",\n//@ts-ignore\nserverIrys.tokenConfigConfig.getPublicKey().toJSON(),\n);\n\nconst price = await serverIrys.getPrice(parseInt(filesize));\nconst balance = await serverIrys.getLoadedBalance();\n\nlet fundTx;\nif (price.isGreaterThanOrEqualTo(balance)) {\nconsole.log(\"Funding node.\");\nfundTx = await serverIrys.fund(price);\nconsole.log(\"Successfully funded fundTx=\", fundTx);\n} else {\nconsole.log(\"Funding not needed, balance sufficient.\");\n}\n\n// return the transaction id\nreturn fundTx?.id || \"\";\n}\n\nasync function readFromStream(stream: ReadableStream<Uint8Array> | null): Promise<string> {\nif (!stream) return \"\";\nconst reader = stream.getReader();\nlet result = \"\";\n\nwhile (true) {\nconst { done, value } = await reader.read();\nif (done) break;\nresult += new TextDecoder().decode(value);\n}\n\nreturn result;\n}\n\nexport async function POST(req: Request) {\n//@ts-ignore\nconst rawData = await readFromStream(req.body as ReadableStream<Uint8Array> | null);\n\nconst body = JSON.parse(rawData);\nconst fundTx = await lazyFund(body);\n\nreturn NextResponse.json({ txResult: fundTx });\n}","client-side#Client-side":"On the client-side there is a single utility function that calls either the EVM or SOL routes.\nimport { WebIrys } from \"@irys/sdk\";\nimport getIrys from \"../utils/getIrys\";\n\ntype Tag = {\nname: string;\nvalue: string;\n};\n\nconst gaslessFundAndUploadEVM = async (selectedFile: File, tags: Tag[]): Promise<string> => {\n// obtain the server's public key\nconst pubKeyRes = (await (await fetch(\"/api/publicKeyEVM\")).json()) as unknown as {\npubKey: string;\n};\nconst pubKey = Buffer.from(pubKeyRes.pubKey, \"hex\");\n// Create a provider - this mimics the behaviour of the injected provider, i.e metamask\nconst provider = {\n// For EVM wallets\ngetPublicKey: async () => {\nreturn pubKey;\n},\ngetSigner: () => {\nreturn {\ngetAddress: () => pubKey.toString(), // pubkey is address for TypedEthereumSigner\n_signTypedData: async (\n_domain: never,\n_types: never,\nmessage: { address: string; \"Transaction hash\": Uint8Array },\n) => {\nconst convertedMsg = Buffer.from(message[\"Transaction hash\"]).toString(\"hex\");\nconsole.log(\"convertedMsg: \", convertedMsg);\nconst res = await fetch(\"/api/signDataEVM\", {\nmethod: \"POST\",\nbody: JSON.stringify({ signatureData: convertedMsg }),\n});\nconst { signature } = await res.json();\nconst bSig = Buffer.from(signature, \"hex\");\n// Pad & convert so it's in the format the signer expects to have to convert from.\nconst pad = Buffer.concat([Buffer.from([0]), Buffer.from(bSig)]).toString(\"hex\");\nreturn pad;\n},\n};\n},\n\n_ready: () => {},\n};\nconsole.log(\"Got provider=\", provider);\n// You can delete the lazyFund route if you're prefunding all uploads\n// 2. then pass the size to the lazyFund API route\nconst fundTx = await fetch(\"/api/lazyFundEVM\", {\nmethod: \"POST\",\nbody: selectedFile.size.toString(),\n});\n\n// Create a new WebIrys object using the provider created with server info.\nconst url = process.env.NEXT_PUBLIC_NODE || \"\";\nconst token = process.env.NEXT_PUBLIC_TOKEN || \"\";\n\nconst wallet = { name: \"ethersv5\", provider: provider };\nconst irys = new WebIrys({ url, token, wallet });\n\nconst w3signer = await provider.getSigner();\nconst address = (await w3signer.getAddress()).toLowerCase();\nawait irys.ready();\n\nconsole.log(\"Uploading...\");\nconst tx = await irys.uploadFile(selectedFile, {\ntags,\n});\nconsole.log(`Uploaded successfully. https://gateway.irys.xyz/${tx.id}`);\n\nreturn tx.id;\n};\n\nconst gaslessFundAndUploadSOL = async (selectedFile: File, tags: Tag[]): Promise<string> => {\n// Obtain the server's public key\nconst pubKeyRes = (await (await fetch(\"/api/publicKeySOL\")).json()) as unknown as {\npubKey: string;\n};\nconst pubKey = Buffer.from(pubKeyRes.pubKey, \"hex\");\nconsole.log(\"got pubKey=\", pubKey);\n// Create a provider\nconst provider = {\npublicKey: {\ntoBuffer: () => pubKey,\nbyteLength: 32,\n},\nsignMessage: async (message: Uint8Array) => {\nlet convertedMsg = Buffer.from(message).toString(\"hex\");\nconst res = await fetch(\"/api/signDataSOL\", {\nmethod: \"POST\",\nbody: JSON.stringify({\nsignatureData: convertedMsg,\n}),\n});\nconst { signature } = await res.json();\nconst bSig = Buffer.from(signature, \"hex\");\nreturn bSig;\n},\n};\n\n// You can delete the lazyFund route if you're prefunding all uploads\nconst fundTx = await fetch(\"/api/lazyFundSOL\", {\nmethod: \"POST\",\nbody: selectedFile.size.toString(),\n});\n\n// Create a new WebIrys object using the provider created with server info.\nconst url = process.env.NEXT_PUBLIC_NODE || \"\";\nconst wallet = { rpcURL: \"https://api.devnet.solana.com\", name: \"solana\", provider: provider };\nconst irys = new WebIrys({ url, token: \"solana\", wallet });\n\nawait irys.ready();\nconsole.log(\"WebIrys=\", irys);\n\nconsole.log(\"Uploading...\");\nconst tx = await irys.uploadFile(selectedFile, {\ntags,\n});\nconsole.log(`Uploaded successfully. https://gateway.irys.xyz/${tx.id}`);\n\nreturn tx.id;\n};\n\n/**\n* Uploads the selected file and tags after funding if necessary.\n*\n* @param {File} selectedFile - The file to be uploaded.\n* @param {Tag[]} tags - An array of tags associated with the file.\n* @returns {Promise<string>} - The transaction ID of the upload.\n*/\nconst gaslessFundAndUpload = async (selectedFile: File, tags: Tag[], blockchain: \"EVM\" | \"SOL\"): Promise<string> => {\nlet txId = \"\";\nswitch (blockchain) {\ncase \"EVM\":\ntxId = await gaslessFundAndUploadEVM(selectedFile, tags);\nbreak;\ncase \"SOL\":\ntxId = await gaslessFundAndUploadSOL(selectedFile, tags);\nbreak;\ndefault:\nthrow new Error(\"Unsupported blockchain\");\n}\nreturn txId;\n};\n\nexport default gaslessFundAndUpload;"}},"/hands-on/tutorials/dynamic-nft":{"title":"Create a dynamic NFT","data":{"":"In this tutorial, you will create a dynamic NFT using Irys' mutable references.","about#About":"Dynamic NFTs are NFTs whose metadata evolves over time. They are commonly used in:\nGaming projects where in-game assets evolve as players progress.\nLoyalty programs where NFTs evolve as users accumulate points.\n\n\n\nThis tutorial focuses on creating a SuperMon NFT that could evolve during gameplay. The NFT starts with a basic appearance and can be \"upgraded\" twice. We will use the Irys CLI to update the metadata, simulating the automatic changes that would occur through player interactions in an actual game.","mutable-references#Mutable references":"Mutable references are a way to simulate \"mutability\".\nYou start by creating a single static URL that is tied to a chain of transactions:\n\n\nconst irys = await getIrys();\nconst receiptOne = await irys.upload(\"First TX\");\nconsole.log(`TX 1 uploaded https://gateway.irys.xyz/mutable/${receiptOne.id}`);\n\nThe chain can be updated at any time, and the original URL will always resolve to the most recent one:\n\n\nconst tags = [{ name: \"Root-TX\", value: receiptOne.id }];\nconst receiptTwo = await irys.upload(\"Second TX\", { tags });\nconsole.log(`TX 2 uploaded https://gateway.irys.xyz/mutable/${receiptOne.id}`);","setup#Setup":"In this tutorial, we will build on the Base L2. Before starting, make sure you add Base Sepolia to your EVM wallet, pre-load some Base Sepolia tokens, and export your private key.\nWhile we focus on Base Sepolia, the principles outlined can be adapted for deployment on any blockchain.","smart-contract#Smart contract":"We're building an NFT, which means we need a smart contract. Here's a simple one you can use to mint the NFT we'll create.\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Import OpenZeppelin's ERC721 and ERC721URIStorage contracts\n// These URLs are compatible with Remix IDE\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract SuperMon is ERC721URIStorage {\nuint256 private _tokenIdCounter;\n\n// No arguments in the constructor, the owner will be the contract deployer\nconstructor() ERC721(\"SuperMon\", \"SMON\") {\n_tokenIdCounter = 0;\n}\n\n// Mint function to create a new NFT\nfunction mint(address to, string memory uri) public {\nuint256 tokenId = _tokenIdCounter;\n_tokenIdCounter += 1;\n_safeMint(to, tokenId);\n_setTokenURI(tokenId, uri);\n}\n}\n\nTo deploy the smart contract using Remix IDE:\nOpen Remix IDE.\nCreate a new solidity file\n\n\nIn the File Explorers pane, click on the Create New File icon.\nName your file SuperMon.sol, and paste the smart contract in.\n\n\nCompile the contract\n\n\nClick on the Solidity Compiler icon in the sidebar.\nSelect the compiler version that matches your contract's pragma (^0.8.0).\nClick Compile SuperMon.sol.\n\n\nDeploy the Contract\n\n\nClick on the Deploy & Run Transactions icon in the sidebar.\nIn the ENVIRONMENT dropdown, select Injected Web3.\nMetaMask will prompt you to connect. Confirm the connection to your Remix session.\nEnsure SuperMon is selected in the CONTRACT dropdown.\nClick Deploy. MetaMask will ask for confirmation to proceed with the transaction.","uploading-the-images#Uploading the images":"Rght-click on each of the above images and save them on your local drive.Next, fund the Irys Devnet node with 0.1 Sepolia ETH to pay for your uploads.\nIn all of these CLI examples, make sure to replace the value of the -w parameter with your own private key.\n\nirys fund 100000000000000000 \\\n-h https://devnet.irys.xyz \\\n-t base-eth \\\n-w 6dd5e....54a120201cb6a \\\n--provider-url https://sepolia.base.org\n\nThe fund command accepts a value in atomic units, 0.1 ETH is equal to 100000000000000000 in atomic units.\nNext, use the Irys CLI to upload each of the images to the Irys Devnet.\nirys upload image-level-1.png \\\n-h https://devnet.irys.xyz \\\n-t base-eth \\\n-w 6dd5e....54a120201cb6a \\\n--tags Content-Type image/png \\\n--provider-url https://sepolia.base.org\n\nirys upload image-level-2.png \\\n-h https://devnet.irys.xyz \\\n-t base-eth \\\n-w 6dd5e....54a120201cb6a \\\n--tags Content-Type image/png \\\n--provider-url https://sepolia.base.org\n\nirys upload image-level-3.png \\\n-h https://devnet.irys.xyz \\\n-t base-eth \\\n-w 6dd5e....54a120201cb6a \\\n--tags Content-Type image/png \\\n--provider-url https://sepolia.base.org","uploading-the-metadata#Uploading the metadata":"Create three metadata files similar to the ones below. Make sure to change the value of the image field to match the URLs generated in the previous step.\n{\n\"name\": \"SuperMon\",\n\"symbol\": \"SMON\",\n\"image\": \"https://gateway.irys.xyz/QH3rksVhbFg5L9vvjGzb4POUibCEG-TGPInmofp-O-o\",\n\"description\": \"Super dooper, changing shapes, changing power\",\n\"attributes\": [\n{\n\"trait_type\": \"supermon-level\",\n\"value\": \"1\"\n}\n]\n}\n\n{\n\"name\": \"SuperMon\",\n\"symbol\": \"SMON\",\n\"image\": \"https://gateway.irys.xyz/QH3rksVhbFg5L9vvjGzb4POUibCEG-TGPInmofp-O-o\",\n\"description\": \"Super dooper, changing shapes, changing power\",\n\"attributes\": [\n{\n\"trait_type\": \"supermon-level\",\n\"value\": \"2\"\n}\n]\n\n}\n\n{\n\"name\": \"SuperMon\",\n\"symbol\": \"SMON\",\n\"image\": \"https://gateway.irys.xyz/QH3rksVhbFg5L9vvjGzb4POUibCEG-TGPInmofp-O-o\",\n\"description\": \"Super dooper, changing shapes, changing power\",\n\"attributes\": [\n{\n\"trait_type\": \"supermon-level\",\n\"value\": \"3\"\n}\n]\n\n}\nAnd upload just the first file using the Irys CLI.\nirys upload metadata-level-1.json \\\n-h https://devnet.irys.xyz \\\n-t base-eth \\\n-w 6dd5e....54a120201cb6a \\\n--tags Content-Type application/json \\\n--provider-url https://sepolia.base.org\nThe CLI will return a URL similar to https://gateway.irys.xyz/NDtKvjlmZL2iXUPmX6P-BuvtnvAEFkUiQWG8ToyK5FM. To convert that to a mutable references URL, interpolate it by adding /mutable/ after the domain and before the transaction ID.Your final URL will be similar to https://gateway.irys.xyz/mutable/NDtKvjlmZL2iXUPmX6P-BuvtnvAEFkUiQWG8ToyK5FM.","mint-the-nft#Mint the NFT":"To mint your NFT in Remix:\nReturn to Remix.\nUnder \"Deployed Contracts\", locate your contract and expand it to see its functions.\nUnder the Mint function, enter the wallet address you want to mint the NFT to and the metadata URL (e.g. https://gateway.irys.xyz/mutable/NDtKvjlmZL2iXUPmX6P-BuvtnvAEFkUiQWG8ToyK5FM) from the previous step.\nClick Transact.\n\n\n\nYou can now view the NFT on the Opensea Testnet.","mutating-the-metadata#Mutating the metadata":"To now \"mutate\" the NFT, upload a new version of the metadata tagging it as having a Root-TX equal to the transaction ID of your first transaction. In my example, I pass the value of NDtKvjlmZL2iXUPmX6P-BuvtnvAEFkUiQWG8ToyK5FM, however make sure to change this to match your unique transaction ID.\nirys upload metadata-level-2.json \\\n-h https://devnet.irys.xyz \\\n-t base-eth \\\n-w 6dd5e....54a120201cb6a \\\n--tags Content-Type application/json Root-TX NDtKvjlmZL2iXUPmX6P-BuvtnvAEFkUiQWG8ToyK5FM \\\n--provider-url https://sepolia.base.org\nReturn to Opensea and request that it refresh your metadata.\n\nGive it a few minutes and your updated NFT should be visible.","free-metadata-uploads#Free metadata uploads":"This tutorial uses the Irys Devnet where uploads are kept for ~60 days and are paid for with free faucet currencies. When deploying production projects, you'll want to use either Node 1 or 2 where uploads are permanent.On Irys' Node 2 uploads of less than 100 KiB are free, which is more than enough for most metadata files. This means projects can let users \"evolve\" their NFTs without having to pay gas fees.","caching#Caching":"Wallets and NFT platforms typically cache metadata to optimize performance, this can affect the visibility of updates to dynamic NFTs. While OpenSea offers a feature for users to manually request metadata refreshes, not all platforms provide this level of control. When building dynamic NFT projects, make sure to thoroughly test and understand the implications of caching on your platform.","getting-help#Getting help":"Any questions? Reach out to us in Discord."}},"/hands-on/tutorials/irys-explorer":{"title":"Build a transaction explorer for Irys","data":{"":"In this tutorial you will:\nLearn how to query Irys and Arweave transactions based on content type, payment token and timestamp\nBuild a powerful tool that gives you insights into how Irys is used\nLearn how to incorporate specialized query functionality in your applications\n\nAs you build the project, you'll be introduced to the Irys Query package, which greatly simplifies querying Irys and Arweave. Instead of having to use GraphQL, you can now search transactions through a single JavaScript class, you interact with it as you would with any other JavaScript code.","prerequisites#Prerequisites":"For this tutorial, ensure you have Node installed and have a foundational knowledge of TypeScript and Tailwind.You don't need to be an expert, but you should be comfortable with basic data types, project creation, component structure, and implementing styling in a project.","project-setup#Project setup":"Navigate to an empty directory and create a new NextJS project with the following:\nnpx create-next-app tutorial-query-package\nWhen prompted, choose all of the default options, including TypeScript and Tailwind.","installing-the-query-package#Installing the Query package":"CD into the directory you just created:\ncd tutorial-query-package\nand install the Irys Query package using npm:\nnpm install @irys/query\nor yarn:\nyarn add @irys/query","ui#UI":"We'll structure our UI beginning with the page.tsx file which then incorporates three additional components:\nNavbar\nSearchResults\nSearchResultsItem\n\nThe page.tsx file acts as a parent component, hosting these child components and managing shared state. All state is set up in page.tsx and then passed to child components when instantiated.When a user triggers a search, Navbar state gets transferred down to page.tsx, which then uses the Query package to search for transactions. The resulting data is processed, and each item is rendered in the UI as a distinct SearchResultsItem.In this tutorial, first, we’ll build out the complete UI, then go back and add in the query functionality. If you’re only interested in how to integrate the Query class, feel free to skip ahead to “Query Functionality”.","pagetsx#page.tsx":"Start by modeling the application data using TypeScript interfaces. The SearchData interface models the parameters required for each search operation, these parameters include:\nIrys node\nContent-Type metatag\npayment token\na date range\n\nThe SearchResult interface models the structure of an individual search result. It includes the transaction ID, creation date, token, and an array of associated tags.\n// Models data points used when searching (represented in our NavBar)\ninterface SearchData {\nirysNode: string;\ncontentType: string;\npaymentToken: string;\nfromTimestamp: Date | null;\ntoTimestamp: Date | null;\n}\n\n// Models the result of a single search\ninterface SearchResult {\ntxID: string;\ncreationDate: string;\ntoken: string;\ntags: any[];\n}\nWith the interfaces defined, we’ll set up the basic page layout, including a Navbar at the top and the SearchResults at the bottom.Replace the contents of your page.tsx file with the following.\n\"use client\";\n\nimport React, { useState } from \"react\";\n\nimport LoadingSpinner from \"./LoadingSpinner\";\nimport Navbar from \"./Navbar\";\nimport Query from \"@irys/query\";\nimport SearchResults from \"./SearchResults\";\n\n// Models data points used when searching (represented in our NavBar)\ninterface SearchData {\nirysNode: string;\ncontentType: string;\npaymentToken: string;\nfromTimestamp: Date | null;\ntoTimestamp: Date | null;\n}\n\n// Models the result of a single search\ninterface SearchResult {\ntxID: string;\ncreationDate: string;\ntoken: string;\ntags: any[];\n}\n\nconst useHome = () => {\n// If true a search is happening and we should show the spinner\nconst [isLoading, setIsLoading] = useState(false);\n// If false we have yet to execute a search\nconst [firstSearchRun, setFirstSearchRun] = useState(false);\n\n// State variables for our search params.\n// Set the variables here, and pass them to the Navbar\nconst [irysNode, setIrysNode] = useState<string>(\"https://node1.irys.xyz\");\nconst [contentType, setContentType] = useState<string>(\"None\");\nconst [paymentToken, setPaymentToken] = useState<string>(\"None\");\nconst [fromTimestamp, setFromTimestamp] = useState<Date | null>(null);\nconst [toTimestamp, setToTimestamp] = useState<Date | null>(null);\n\n// Stores the results of the search\nconst [searchResults, setSearchResults] = useState<SearchResult[]>([]);\n\n// Called when a user clicks \"Search\" in the UI\nconst handleSearch = async () => {};\n\nreturn {\nisLoading,\nfirstSearchRun,\nirysNode,\nsetIrysNode,\ncontentType,\nsetContentType,\npaymentToken,\nsetPaymentToken,\nfromTimestamp,\nsetFromTimestamp,\ntoTimestamp,\nsetToTimestamp,\nsearchResults,\nhandleSearch,\n};\n};\n\nconst Home: React.FC = () => {\nconst { isLoading, searchResults, firstSearchRun, handleSearch, ...navProps } = useHome();\n\nreturn (\n<div className=\"min-h-screen bg-background text-text\">\n<Navbar onSearch={handleSearch} {...navProps} />\n{isLoading ? (\n<LoadingSpinner />\n) : searchResults.length > 0 ? (\n<div className=\"pt-5\">\n<SearchResults results={searchResults} />\n</div>\n) : firstSearchRun ? (\n<div className=\"flex justify-center items-center h-screen\">\n<p className=\"text-4xl text-black\">No results found</p>\n</div>\n) : null}\n</div>\n);\n};\n\nexport default Home;","loadingspinner#LoadingSpinner":"Depending on search criteria and number of results returned, searches may take upwards of a few seconds to execute. While a query is running, we’ll show a simple Loading … spinner in the UI. This component is selectively displayed in page.tsx, and has a simple design with no interactivity or state to manage.Create a new file called LoadingSpinner.tsx and paste in the following.\nimport React from \"react\";\n\n// UI component, shows a \"Loading ...\" spinner when active\nconst LoadingSpinner: React.FC = () => {\nreturn (\n<div className=\"flex justify-center items-center h-screen\">\n<div className=\"relative w-32 h-32 -mt-60\">\n<div className=\"absolute animate-ping w-full h-full rounded-full bg-primary opacity-75\"></div>\n<div className=\"absolute w-full h-full rounded-full bg-primary flex justify-center items-center\">\n<p className=\"text-black\">Searching ...</p>\n</div>\n</div>\n</div>\n);\n};\n\nexport default LoadingSpinner;","navbar#NavBar":"The Navbar component is where the user will configure search parameters before passing them down to page.tsx.\n\nStart by defining the properties of the Navbar component using the NavbarProps interface. This includes:\nNode to search\nContent type\nPayment toke\nTo and from timestamps\n\nAn onSearch() function is also included, which is triggered when a search operation is initiated by the user clicking Search.All of these values are passed to Navbar from page.tsx, ensuring state is shared between all components.\ninterface NavbarProps {\nirysNode: string;\nsetIrysNode: React.Dispatch<React.SetStateAction<string>>;\ncontentType: string;\nsetContentType: React.Dispatch<React.SetStateAction<string>>;\npaymentToken: string;\nsetPaymentToken: React.Dispatch<React.SetStateAction<string>>;\nfromTimestamp: Date | null;\nsetFromTimestamp: React.Dispatch<React.SetStateAction<Date | null>>;\ntoTimestamp: Date | null;\nsetToTimestamp: React.Dispatch<React.SetStateAction<Date | null>>;\nonSearch: () => void;\n}\nNext, build a custom React hook called useNavbar() that handles all the state setting for the component.\ncconst useNavbar = ({ props }: { props: NavbarProps }) => {\nconst handleIrysNodeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\nprops.setIrysNode(e.target.value);\n};\n\n\nconst handleContentTypeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\nprops.setContentType(e.target.value);\n};\n\n\nconst handlePaymentTokenChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\nprops.setPaymentToken(e.target.value);\n};\n\n\nconst handleFromTimestampChange = (e: React.ChangeEvent<HTMLInputElement>) => {\nprops.setFromTimestamp(e.target.value ? new Date(e.target.value) : null);\n};\n\n\nconst handleToTimestampChange = (e: React.ChangeEvent<HTMLInputElement>) => {\nprops.setToTimestamp(e.target.value ? new Date(e.target.value) : null);\n};\n\n\nreturn {\nhandleIrysNodeChange,\nhandleContentTypeChange,\nhandlePaymentTokenChange,\nhandleFromTimestampChange,\nhandleToTimestampChange,\n};\n};\nNow, combine the state management logic with some basic HTML, and you’ve got your Navbar UI. Create a new file called Navbar.tsx and paste in the following.\nimport Image from \"next/image\";\nimport React from \"react\";\n\ninterface NavbarProps {\nirysNode: string;\nsetIrysNode: React.Dispatch<React.SetStateAction<string>>;\ncontentType: string;\nsetContentType: React.Dispatch<React.SetStateAction<string>>;\npaymentToken: string;\nsetPaymentToken: React.Dispatch<React.SetStateAction<string>>;\nfromTimestamp: Date | null;\nsetFromTimestamp: React.Dispatch<React.SetStateAction<Date | null>>;\ntoTimestamp: Date | null;\nsetToTimestamp: React.Dispatch<React.SetStateAction<Date | null>>;\nonSearch: () => void;\n}\n\nconst useNavbar = ({ props }: { props: NavbarProps }) => {\nconst handleIrysNodeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\nprops.setIrysNode(e.target.value);\n};\n\nconst handleContentTypeChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\nprops.setContentType(e.target.value);\n};\n\nconst handlePaymentTokenChange = (e: React.ChangeEvent<HTMLSelectElement>) => {\nprops.setPaymentToken(e.target.value);\n};\n\nconst handleFromTimestampChange = (e: React.ChangeEvent<HTMLInputElement>) => {\nprops.setFromTimestamp(e.target.value ? new Date(e.target.value) : null);\n};\n\nconst handleToTimestampChange = (e: React.ChangeEvent<HTMLInputElement>) => {\nprops.setToTimestamp(e.target.value ? new Date(e.target.value) : null);\n};\n\nreturn {\nhandleIrysNodeChange,\nhandleContentTypeChange,\nhandlePaymentTokenChange,\nhandleFromTimestampChange,\nhandleToTimestampChange,\n};\n};\n\nconst Navbar: React.FC<NavbarProps> = (props) => {\nconst {\nhandleIrysNodeChange,\nhandleContentTypeChange,\nhandlePaymentTokenChange,\nhandleFromTimestampChange,\nhandleToTimestampChange,\n} = useNavbar({ props });\n\nreturn (\n<div className=\"w-full p-4 bg-primary sticky top-0 z-50\">\n<div className=\"flex flex-row gap-5 justify-center justify-items-start\">\n<div className=\"flex flex-col\">\n<label className=\"text-text text-xs ml-2\">Irys Node</label>\n<select\nvalue={props.irysNode}\nonChange={handleIrysNodeChange}\nclassName=\"rounded-xl px-2 shadow-xl\"\n>\n<option value=\"https://node1.irys.xyz\">https://node1.irys.xyz</option>\n<option value=\"https://node2.irys.xyz\">https://node2.irys.xyz</option>\n<option value=\"https://devnet.irys.xyz\">https://devnet.irys.xyz</option>\n</select>\n</div>\n\n<div className=\"flex flex-col\">\n<label className=\"text-text text-xs ml-2\">Content-Type</label>\n<select\nvalue={props.contentType}\nonChange={handleContentTypeChange}\nclassName=\"rounded-xl px-2 shadow-xl\"\n>\n<option value=\"None\">None</option>\n<option value=\"image/jpg\">image/jpg</option>\n<option value=\"image/png\">image/png</option>\n<option value=\"image/gif\">image/gif</option>\n</select>\n</div>\n\n<div className=\"flex flex-col\">\n<label className=\"text-text text-xs ml-2\">Payment Token</label>\n<select\nvalue={props.paymentToken}\nonChange={handlePaymentTokenChange}\nclassName=\"rounded-xl px-2 shadow-xl\"\n>\n<option value=\"None\">None</option>\n<option value=\"Solana\">Solana</option>\n<option value=\"Matic\">Matic</option>\n<option value=\"Ethereum\">Ethereum</option>\n<option value=\"Arweave\">Arweave</option>\n</select>\n</div>\n\n<div className=\"flex flex-col\">\n<label className=\"text-text text-xs ml-2\">From Timestamp</label>\n<input\ntype=\"date\"\nvalue={props.fromTimestamp ? props.fromTimestamp.toISOString().substring(0, 10) : \"\"}\nonChange={handleFromTimestampChange}\nclassName=\"rounded-xl px-2 shadow-xl\"\n/>\n</div>\n<div className=\"flex flex-col\">\n<label className=\"text-text text-xs ml-2\">To Timestamp</label>\n<input\ntype=\"date\"\nvalue={props.toTimestamp ? props.toTimestamp.toISOString().substring(0, 10) : \"\"}\nonChange={handleToTimestampChange}\nclassName=\"rounded-xl px-2 shadow-xl\"\n/>\n</div>\n\n<div className=\"self-center\">\n<button\nclassName=\"shadow-xl px-5 mt-4 bg-white hover:bg-primary text-text rounded-xl border-1 decoration-black\"\nonClick={props.onSearch}\n>\nSearch\n</button>\n</div>\n</div>\n</div>\n);\n};\n\nexport default Navbar;","searchresults#SearchResults":"The SearchResults component is a simple container that fills the bottom part of the search. It first defines two interfaces that model the results of a search.\n// Defines the shape of a search result\ninterface SearchResult {\ntxID: string;\ncreationDate: string;\ntoken: string;\ntags: any[];\n}\n\n// Defines the properties of the SearchResults component\ninterface SearchResultsProps {\nresults: SearchResult[]; // array of search results\n}\nIt then iterates over these values, and uses them to dynamically build an array of SearchResultsItems components.Create a new file titled SearchResults.tsx and paste in the following.\nimport React from \"react\";\nimport SearchResultsItem, { Tag } from \"./SearchResultsItem\";\n\n// Defines the shape of a search result\ninterface SearchResult {\ntxID: string;\ncreationDate: string;\ntoken: string;\ntags: any[];\n}\n\n// Defines the properties of the SearchResults component\ninterface SearchResultsProps {\nresults: SearchResult[]; // array of search results\n}\n\n// Functional component that receives an array of SearchResult items\nconst SearchResults: React.FC<SearchResultsProps> = ({ results }) => {\nreturn (\n<div className=\"flex flex-wrap justify-center\">\n{\n// For each result, render a SearchResultsItem component\nresults &&\nresults.map((result) => (\n<SearchResultsItem\nkey={result.txID} // Unique key\ntxID={result.txID} // Transaction ID\ntoken={result.token} // Token used for payment\ncreationDate={result.creationDate} // Creation date\t\t\t\t\t\t\ttags={result.tags} // Any associated tags\n/>\n))\n}\n</div>\n);\n};\n\nexport default SearchResults;","searchresultsitem#SearchResultsItem":"The SearchResultsItem component models a single search result, you’ll instantiate a new one for each result found.Start by modeling the data that will be shown in the component.\n// Describes the structure of a metadata tag\nexport interface Tag {\nname: string;\nvalue: string;\n}\n\n// Defines the properties of the SearchResultsItem component\ninterface SearchResultsItemProps {\ntxID: string; // Transaction ID\ncreationDate: string; // Date of transaction creation\ntoken: string; // Token used for payment\ntags: Tag[]; // Array of Tags\n}\nAnd then combine it with some basic styling to complete the component.\nimport React from \"react\";\nimport toTitleCase from \"./utils/titleCase\";\n\n// Describes the structure of a metadata tag\nexport interface Tag {\nname: string;\nvalue: string;\n}\n\n// Defines the properties of the SearchResultsItem component\ninterface SearchResultsItemProps {\ntxID: string; // Transaction ID\ncreationDate: string; // Date of transaction creation\ntoken: string; // Token used for payment\ntags: Tag[]; // Array of Tags\n}\n\n// Functional component that displays information for an individual search result\nconst SearchResultsItem: React.FC<SearchResultsItemProps> = ({ txID, creationDate, token, tags }) => {\nreturn (\n<div className=\"flex flex-col bg-secondary shadow-2xl m-2 p-4 rounded-lg w-60\">\n{/* Display thumbnail image */}\n<img className=\"rounded-xl\" src={`https://gateway.irys.xyz/${txID}`} alt=\"Thumbnail\" />\n\n{/* Display truncated Transaction ID */}\n<p className=\"text-text text-xs mt-5\">\n<span className=\"font-bold\">Tx ID:</span> {txID.slice(0, 5).concat(\".....\", txID.slice(-5))}\n</p>\n{/* Display creation date */}\n<p className=\"text-text text-xs \">\n<span className=\"font-bold\">Creation Date:</span> {creationDate}\n</p>\n{/* Display token info */}\n<p className=\"text-text text-xs \">\n<span className=\"font-bold\">Token:</span> {toTitleCase(token)}\n</p>\n\n{/* List all associated tags */}\n<ul className=\"mt-3 text-xs\">\n{tags.map((tag: Tag, i: number) => (\n<li key={i}>\n{tag.name}: {tag.value.length > 10 ? tag.value.substring(0, 10) + \"...\" : tag.value}\n</li>\n))}\n</ul>\n</div>\n);\n};\n\nexport default SearchResultsItem;","utils#utils":"Ok, you are almost done, let’s create one quick utility function.Create a new folder called utils and in it a file called titleCase.tsx. Paste in the following code we’ll use to properly format text in SearchResultsItem. This function accepts any string and returns it properly formatted using title case, the first letter is capitalized while the others are in lowercase.\nconst toTitleCase = (str: string): string => {\nreturn str.replace(/\\w\\S*/g, (txt: string): string => {\nreturn txt.charAt(0).toLocaleUpperCase() + txt.substr(1).toLocaleLowerCase();\n});\n};\n\nexport default toTitleCase;","query-functionality#Query Functionality":"Having assembled the application's UI, running npm run dev in your CLI now displays a functional UI with a Navbar and a designated area for search results. However, the \"Search\" button doesn’t do anything as we have yet to build out the handleSearch() function.Let’s jump back to page.tsx and finish coding the handleSearch() function.Irys has two main Nodes and one Devnet node. When instantiating a new Query object, you must connect to the node-specific endpoint where you posted your transaction. The endpoint is defined by passing it as an argument to the Query constructor. In the absence of an argument, the class defaults to connecting to Node 1.\n// Create a new Query object pointing to the node selected by the user\nconst query = new Query({ url: irysNode + \"/graphql\" });\nMoving forward, the Query object is configured to exclusively search Irys' transactions and limit the results to 42. The location of the search is determined by the value passed to search(), if you’re modifying this tutorial to search Arweave instead, you would change this value.Although this tutorial limits results to 42 for simplicity, implementing streaming would enable a continuously expanding page of results triggered by user scroll.\nconst myQuery = query.search(\"irys:transactions\").limit(42);\nNext up is where the meat of the query happens. Using the tags(), currency(), fromTimestamp() and toTimestamp() functions, we programmatically set query parameters.\n// Set query params based on input in NavBar\nif (contentType !== \"None\") myQuery.tags([{ name: \"Content-Type\", values: [contentType] }]);\nif (paymentToken !== \"None\") myQuery.currency(paymentToken.toLowerCase());\nif (fromTimestamp) myQuery.fromTimestamp(fromTimestamp);\nif (toTimestamp) myQuery.toTimestamp(toTimestamp);\nAnd finally, we execute the query by calling it with the await keyword.\n// Having configured the query, call await on it to execute\nconst results = await myQuery;\nHere’s the full handleSearch() function, go back to your page.tsx file and paste this function on top of the existing empty function signature.\n// Called when a user clicks \"Search\" in the UI\nconst handleSearch = async () => {\n// Show the LoadingSpinner\nsetIsLoading(true);\nsetFirstSearchRun(true);\n\n// Clear the previous search results (if exists)\nsetSearchResults([]);\n\n// Create a new Query object pointing to the node selected by the user\nconst query = new Query({ url: irysNode + \"/graphql\" });\n\n// Create a new query pointing to Irys, limit results to 42\n// for purposes of this tutorial, but feel free to change.\nconst myQuery = query.search(\"irys:transactions\").limit(42);\n\n// Set query params based on input in NavBar\nif (contentType !== \"None\") myQuery.tags([{ name: \"Content-Type\", values: [contentType] }]);\nif (paymentToken !== \"None\") myQuery.currency(paymentToken.toLowerCase());\nif (fromTimestamp) myQuery.fromTimestamp(fromTimestamp);\nif (toTimestamp) myQuery.toTimestamp(toTimestamp);\n\n// Having configured the query, call await on it to execute\nconst results = await myQuery;\n\n// Iterate over the search results, adding each to an array of SearchResult\nconst resultsBuilder: SearchResult[] = [];\nfor (const result of results) {\nconst newEntry: SearchResult = {\ntxID: result.id,\ncreationDate: new Date(result.timestamp).toLocaleString(),\ntoken: result.currency,\ntags: result.tags,\n};\nresultsBuilder.push(newEntry);\n}\n// Store SearchResult array in state\nsetSearchResults(resultsBuilder);\n\n// Turn of the LoadingSpinner\nsetIsLoading(false);\n};","whats-next#What’s Next?":"Excellent job! In under an hour, you've constructed an explorer that showcases content uploaded to Irys in real time. The flexibility of the Query pacakge opens a world of opportunities for creative Web3 development.\nYou could expand on this tutorial to allow more advanced tag searching or even repurpose it to query Arweave directly instead.\nWhen uploading to Irys, you have complete freedom over which tags you add to each transaction. Using custom tags you can build semi-relational models within your data and then use these models to construct complex queries, analyze data patterns, or create personalized user experiences.\n\nWhat are you going to build?LFB!"}},"/hands-on/tutorials/browser-based-encryption":{"title":"Encrypting onchain data (browser-based)","data":{"":"This guide teaches you how to:\nEncrypt a File uploaded from the browser using Lit Protocol\nEstablish a set of rules determining who can decrypt the File\nStore the encrypted File on Arweave using Irys\nDecrypt the File using Lit Protocol\nDisplay the decrypted File in the browser\n\nBefore diving into this guide, begin with \"Encrypting onchain data\".\nThe Irys Provenance Toolkit features an encrypted uploader\ncomponent that allows for file uploads directly from the\nbrowser, handles its encryption and decryption, and displays the decrypted file. When building your project,\nconsider cloning the Toolkit repository to use as a foundation.","dependencies#Dependencies":"Install using npm:\nnpm install @irys/sdk @lit-protocol/lit-node-client@^3 ethers@^5\nor yarn:\nyarn add @irys/sdk @lit-protocol/lit-node-client@^3 ethers@^5","imports#Imports":"import * as LitJsSdk from \"@lit-protocol/lit-node-client\";\nimport { WebIrys } from \"@irys/sdk\";","encrypting-a-file#Encrypting a File":"","file-uploader#File uploader":"Add a form to an HTML page that accepts a file as input:\n<form id=\"uploadForm\">\n<input type=\"file\" name=\"fileToUpload\" id=\"fileToUpload\" accept=\"*/*\" required />\n<input type=\"button\" value=\"Upload File\" onclick=\"handleUpload()\" />\n</form>","wallet-signature#Wallet signature":"Use the Lit SDK function checkAndSignAuthMessage() to prompt the user to sign a basic transaction, confirming wallet ownership. Authentication details are then saved in the browser's local storage, future calls to checkAndSignAuthMessage() will use the stored version if present.\nconst authSig = await checkAndSignAuthMessage({\nchain: process.env.NEXT_PUBLIC_LIT_CHAIN || \"polygon\",\n});","lit-node#Lit node":"Connect to a Lit node:\nconst litNodeClient = new LitJsSdk.LitNodeClient({\nlitNetwork: \"cayenne\",\n});\nawait litNodeClient.connect();","access-control-conditions#Access control conditions":"Define rules for who to decrypt your data, limiting it to anyone with >= 0 ETH:\n// This defines who can decrypt the data\nfunction getAccessControlConditions() {\nconst accessControlConditions = [\n{\ncontractAddress: \"\",\nstandardContractType: \"\",\nchain: \"ethereum\",\nmethod: \"eth_getBalance\",\nparameters: [\":userAddress\", \"latest\"],\nreturnValueTest: {\ncomparator: \">=\",\nvalue: \"0\", // 0 ETH, so anyone can open\n},\n},\n];\n\nreturn accessControlConditions;\n}\nTo the wallet 0x50e2dac5e78B5905CB09495547452cEE64426db2\nconst accessControlConditions = [\n{\ncontractAddress: \"\",\nstandardContractType: \"\",\nchain,\nmethod: \"\",\nparameters: [\":userAddress\"],\nreturnValueTest: {\ncomparator: \"=\",\nvalue: \"0x50e2dac5e78B5905CB09495547452cEE64426db2\",\n},\n},\n];\nOr by people who hold a given ERC721:\nconst accessControlConditions = [\n{\ncontractAddress: \"0xA80617371A5f511Bf4c1dDf822E6040acaa63e71\",\nstandardContractType: \"ERC721\",\nchain,\nmethod: \"balanceOf\",\nparameters: [\":userAddress\"],\nreturnValueTest: {\ncomparator: \">\",\nvalue: \"0\",\n},\n},\n];","encrypting#Encrypting":"Finally, encrypt the File using Lit's encryptFileAndZipWithMetadata() function.This function takes the File object, encrypts it and stores it in a single zip file with all metadata.\n// Create a zip blob containing the encrypted file and associated metadata\nconst zipBlob = await LitJsSdk.encryptFileAndZipWithMetadata({\nchain: process.env.NEXT_PUBLIC_LIT_CHAIN || \"polygon\",\nauthSig,\naccessControlConditions,\nfile,\nlitNodeClient,\nreadme: \"This file was encrypted using LitProtocol and the Irys Provenance Toolkit.\",\n});","storing-on-arweave-via-irys#Storing on Arweave via Irys":"Once encrypted, use webIrys.uploadFile() to upload the zip blob. In this case, we tag the upload with a tag indicating the content type of the underlying file, and another tag letting us know it's encrypted.\n// Tag the upload marking it as\n// - Binary file\n// - Containing a file of type file.type (used when displaying)\n// - Encrypted (used by our display code)\nconst tags: Tag[] = [\n{\nname: \"Content-Type\",\nvalue: \"application/octet-stream\",\n},\n{\nname: \"Encrypted-File-Content-Type\",\nvalue: file.type,\n},\n{\nname: \"Irys-Encrypted\",\nvalue: \"true\",\n},\n];\n\nconst receipt = await irys.uploadFile(file, {\ntags,\n});","combined-file#Combined file":"Then, combine everything in a single file:\nasync function encryptFile(file: File) {\n// 1. Connect to a Lit node\nconst litNodeClient = new LitJsSdk.LitNodeClient({\nlitNetwork: \"cayenne\",\n});\nawait litNodeClient.connect();\n\n// 2. Ensure we have a wallet signature\nconst authSig = await LitJsSdk.checkAndSignAuthMessage({\nchain: process.env.NEXT_PUBLIC_LIT_CHAIN || \"polygon\",\n});\n\n// 3. Define access control conditions.\n// This defines who can decrypt, current settings allow for\n// anyone with a ETH balance >= 0 to decrypt, which\n// means that anyone can. This is for demo purposes.\nconst accessControlConditions = [\n{\ncontractAddress: \"\",\nstandardContractType: \"\",\nchain: \"ethereum\",\nmethod: \"eth_getBalance\",\nparameters: [\":userAddress\", \"latest\"],\nreturnValueTest: {\ncomparator: \">=\",\nvalue: \"0\",\n},\n},\n];\n\n// 4. Create a zip blob containing the encrypted file and associated metadata\nconst zipBlob = await LitJsSdk.encryptFileAndZipWithMetadata({\nchain: process.env.NEXT_PUBLIC_LIT_CHAIN || \"polygon\",\nauthSig,\naccessControlConditions,\nfile,\nlitNodeClient,\nreadme: \"This file was encrypted using LitProtocol and the Irys Provenance Toolkit.\",\n});\n\nreturn zipBlob;\n}\n\n// Uploads the encrypted File (with metadata) to Irys\nasync function uploadFile(file: File): Promise<string> {\nconst irys = await getIrys();\n\ntry {\nconst price = await irys.getPrice(file?.size);\nconst balance = await irys.getLoadedBalance();\n\nif (price.isGreaterThanOrEqualTo(balance)) {\nconsole.log(\"Funding node.\");\nawait irys.fund(price);\n} else {\nconsole.log(\"Funding not needed, balance sufficient.\");\n}\n\n// Tag the upload marking it as\n// - Binary file\n// - Containing a file of type file.type (used when displaying)\n// - Encrypted (used by our display code)\nconst tags: Tag[] = [\n{\nname: \"Content-Type\",\nvalue: \"application/octet-stream\",\n},\n{\nname: \"Encrypted-File-Content-Type\",\nvalue: file.type,\n},\n{\nname: \"Irys-Encrypted\",\nvalue: \"true\",\n},\n];\n\nconst receipt = await irys.uploadFile(file, {\ntags,\n});\nconsole.log(`Uploaded successfully. ${GATEWAY_BASE}${receipt.id}`);\n\nreturn receipt.id;\n} catch (e) {\nconsole.log(\"Error uploading single file \", e);\n}\nreturn \"\";\n}\n\n// Encrypts and then uploads a File\nasync function encryptAndUploadFile(file: File): Promise<string> {\nconst encryptedData = await encryptFile(file);\nreturn await uploadFile(encryptedData);\n}\nAnd call it from your HTML form:\n<form id=\"uploadForm\">\n<input type=\"file\" name=\"fileToUpload\" id=\"fileToUpload\" accept=\"*/*\" required />\n<input type=\"button\" value=\"Upload File\" onclick=\"handleUpload()\" />\n</form>\n\n<script>\ndocument.getElementById(\"uploadForm\").addEventListener(\"submit\", function (event) {\nevent.preventDefault();\nhandleUpload();\n});\n\nasync function handleUpload() {\nconst fileInput = document.getElementById(\"fileToUpload\");\nconst file = fileInput.files[0];\nif (file) {\nconst result = await encryptAndUploadFile(file);\n} else {\nalert(\"Please select a file to upload.\");\n}\n}\n</script>","decrypting-a-file#Decrypting a File":"To decrypt and display the image:\nLoad the data from the Irys gateway\nExtract the zip blob\nDecrypt it\n\n\nasync function decryptFile(id: string, encryptedFileType: string): Promise<string> {\ntry {\n// 1. Retrieve the file from https://gateway.irys.xyz/${id}\nconst response = await fetch(`${GATEWAY_BASE}${id}`);\nif (!response.ok) {\nthrow new Error(`Failed to fetch encrypted file from gateway with ID: ${id}`);\n}\n\n// 2. Extract the zipBlob\nconst zipBlob = await response.blob();\n\n// 3. Connect to a Lit node\nconst litNodeClient = new LitJsSdk.LitNodeClient({\nlitNetwork: \"cayenne\",\n});\nawait litNodeClient.connect();\n\n// 3.5 Get a reference to an AuthSig (if in local storage that will be used instead of prompting the user to sign)\nconst authSig = await LitJsSdk.checkAndSignAuthMessage({\nchain: process.env.NEXT_PUBLIC_LIT_CHAIN || \"polygon\",\n});\n\n// 4. Decrypt the zipBlob\nconst result = await LitJsSdk.decryptZipFileWithMetadata({\nfile: zipBlob,\nlitNodeClient: litNodeClient,\nauthSig: authSig, // Include this only if necessary\n});\nconst decryptedFile = result.decryptedFile;\n// 5. Convert to a blob\nconst blob = arrayBufferToBlob(decryptedFile, encryptedFileType);\n// 6. Build a dynamic URL\nconst dataUrl = await blobToDataURL(blob);\n\nreturn dataUrl;\n} catch (e) {\nconsole.error(\"Error decrypting file:\", e);\n}\nreturn \"\";\n}","displaying-encrypted-file-in-the-browser#Displaying encrypted File in the browser":"After decrypting the image file, you need to convert the data blob to a URL with the format data:image/png;base64,[base64-encoded-data] before setting it as the src attribute of an <img> element.These functions assist in converting the data blob to a URL.\n// Helper functions for use in showing decrypted images\nfunction arrayBufferToBlob(buffer: ArrayBuffer, type: string): Blob {\nreturn new Blob([buffer], { type: type });\n}\n\nfunction blobToDataURL(blob: Blob): Promise<string> {\nreturn new Promise((resolve, reject) => {\nconst reader = new FileReader();\nreader.onload = (event) => {\nif (event.target?.result) {\nresolve(event.target.result as string);\n} else {\nreject(new Error(\"Failed to read blob as Data URL\"));\n}\n};\nreader.readAsDataURL(blob);\n});\n}","full-code#Full code":"All of this code is contained in a single file as part of the Provenance Toolkit.","server-side-example#Server-side example":"Server-side encryption","demo#Demo":"Irys Provenance Toolkit"}},"/hands-on/tutorials/lens":{"title":"Storing Lens metadata on Irys","data":{"":"In this tutorial, you will learn how to use Irys with the Lens React hooks to upload post metadata.Lens Protocol is a composable and decentralized social graph; it allows you to quickly create social applications without having to build your own backend services.","react-hooks#React hooks":"The React hooks for Lens make client-side development easier as they streamline much of the development, including generating correct metadata for you to upload.","upload-pattern#upload() pattern":"When working with hooks like useUpdateProfileDetails() and useCreatePost(), Lens works using a pattern where you define a function called upload() that matches the following signature.\nexport const upload = (data: unknown): Promise<string> => {\nconst serialized = JSON.stringify(data);\n\nconst url = // upload serialized to a public location\n\nreturn url;\n}\nThe upload() function is passed to the hooks on initialization, the hooks then prepare the required metadata and pass it to upload() in the data parameter. When implementing the function, it's up to you to serialize the metadata (JSON object), store it on Irys and then return the URL from the function. The hook then takes the URL to the uploaded metadata and continues using it to update profile details or create a new post.A full ready-to-use implementation of the upload() function is as follows:\nimport { WebIrys } from \"@irys/sdk\";\nimport { providers } from \"ethers\";\n\nconst getIrys = async () => {\nawait window.ethereum.enable();\nconst provider = new providers.Web3Provider(window.ethereum);\nconst wallet = { name: \"ethersv5\", provider: provider };\nconst url = \"https://node1.irys.xyz\";\nconst token = \"matic\";\nconst webIrys = new WebIrys({ url, token, wallet });\nawait webIrys.ready();\nreturn webIrys;\n};\n\nexport const upload = async (data) => {\ntry {\nconst irys = await getIrys();\nconst serialized = JSON.stringify(data);\n\n// fund (if needed)\nconst price = await irys.getPrice(new Blob([serialized]).size);\nawait irys.fund(price);\n\nconst tx = await irys.upload(serialized, {\ntags: [{ name: \"Content-Type\", value: \"application/json\" }],\n});\n\nconsole.log(`Upload success content URL= https://gateway.irys.xyz/${tx.id}`);\n\nreturn `https://gateway.irys.xyz/${tx.id}`;\n} catch (e) {\nconsole.log(\"error on upload \", e);\n}\nreturn \"\";\n};\n\nIf you incorrectly set the Content-Type attribute, Lens will not read your data."}},"/hands-on/tutorials/metaplex":{"title":"Build a Solana NFT marketplace with Metaplex","data":{"":"In this tutorial, you will learn everything you need to know to launch your own NFT collection on Solana using Metaplex. You will use Metaplex’s tools to upload your NFTs to Irys before setting them up to mint on Solana, finally, you will build a full website your community can use to mint your creations.\n\nWe'll be using NextJS, TypeScript, and Tailwind for this tutorial. A basic understanding of each is essential, but you don't need to be an expert. If you're familiar with JavaScript but new to TypeScript, don’t worry, you’ll be fine. Also, you should have a basic knowledge of Github, enough to handle tasks like cloning a repository.","prerequisites#Prerequisites":"To complete this tutorial you will need:\nA recent version of Node\nA code editor (I use VSCode, but use whatever you prefer)\nA Solana wallet (I use Phantom, but others are fine)\nSome Devnet (not Testnet) Solana tokens, available for free from a faucet","metaplex#Metaplex":"Metaplex offers a full suite of tools that simplify creating and minting NFTs on Solana.In this tutorial you will work with:\nSugar: A CLI for uploading NFT images and metadata\nUmi: A modular framework for building and using JavaScript that interacts with Solana\nCandy Machine: A minting and distribution program for NFT collections on Solana","setup#Setup":"","tutorial-repository#Tutorial repository":"To help you get going quickly and let you focus on learning how to use Metaplex with Irys, I created a Github repository with some artwork you can use for your NFTs. Additionally, I created a framework UI for the minting website.Start by cloning this repository.At the top-level are two folders, one called NFTs that contains 20 PNGs we'll turn into NFTs, and a second one called mint-storefront that contains the NextJS project representing the UI for the minting website.","solana-cli#Solana CLI":"Start by installing the Solana CLI. Follow these instructions and then return to this tutorial.If you are not sure if you have already installed the CLI, you can try running:\nsolana --version\nAs new versions of the CLI are constantly being released, it’s recommended you update before continuing:\nsolana-install update\nNext setup a Solana Devnet wallet:\nsolana-keygen new --outfile ~/.config/solana/devnet.json\nThe results of that command will look something like this:\nWrote new keypair to /Users/luke/.config/solana/devnet.json\n==============================================================================\npubkey: 69Z4dXS8aAvDhP4QDRs5C2LePnpYApZX8rvnZ69r6ic1\n==============================================================================\nSave this seed phrase and your BIP39 passphrase to recover your new keypair:\ntrend own mixture your spike keys elite run coins not lyrics fade\n==============================================================================\n\nWithin the results is a 12-word keyphrase that can be used to access your wallet, if you share this information with\nanyone they can access your funds. I decided to show mine to make this tutorial easy to follow, however, I only used\nthe wallet while writing this tutorial.\nNow switch to the Solana Devnet:\nsolana config set -u devnet\nAnd fund your wallet with free Devnet faucet tokens:\nsolana airdrop 2\n\nThe airdrop command is sometimes unreliable. If you have trouble funding your wallet, you may need to use the\nSolana Faucet. Be sure to request Devnet tokens and not Testnet tokens. You can find your\nwallet address using the command solana address.\nYou can test that you have a balance using:\nsolana balance","sugar#Sugar":"You’ll use Metaplex’s Sugar to upload your NFT assets. Start by installing the Sugar CLI with the following command, when prompted, choose the latest version.\nbash <(curl -sSf https://sugar.metaplex.com/install.sh)\nYou may need to restart your CLI, after which you can confirm that Sugar was successfully installed by running\nsugar -V","preparing-your-nfts-for-upload#Preparing your NFTS for upload":"An NFT is a digital asset that combines both visual and descriptive elements. The visual part is typically represented by images or animations. The descriptive elements are in the form of a metadata file, which also contains things like the NFT’s name, symbol, and description.When uploading assets using Sugar, you must provide them in pairs, one visual asset file paired with one metadata file.Here’s a sample metadata file:\n{\n\"name\": \"Space Llamas #1\",\n\"symbol\": \"SPL\",\n\"description\": \"These llamas are going to the moon\",\n\"image\": \"0.png\",\n\"properties\": {\n\"files\": [\n{\n\"uri\": \"0.png\",\n\"type\": \"image/png\"\n}\n]\n}\n}\nWhen setting up visual assets for Metaplex, there are specific naming conventions you must adhere to. Images must be named in a sequential, zero-indexed manner; your first image should be named 0.png, and the twentieth should be 19.png. Additionally, your collection must have a cover image that represents the entire collection, named collection.png.For this tutorial, you have two choices for visual content. You can either use the images I've created (using Stable Difussion), which are available in the \"NFTs\" directory of the Github repository or create your own.To make things easier for you, I wrote a simple shell script that takes a batch of images, renames them, and creates a metadata file for each one.The script is available in the GitHub repository and is named NFTs/prepareImages.sh.Before you run the script, you may need to grant it execute permission:\nchmod +x prepareImages.sh\nTo use the script, navigate to the NFTs directory and run the script, supplying the necessary arguments:\n./prepareImages.sh <folder_path> <file_extension> <name> <symbol> <description> [resize]\nHere's a breakdown of each command line argument:\nfolder_path: The path to the directory where your images are stored.\nfile_extension: This should be either \"png\" or \"jpg\", depending on the format of the images you're working with.\nname: The base name for your NFTs. For images not named \"collection\", a number will be appended (e.g., \"Space Llamas #1\").\nsymbol: A short representation of your NFT's name, such as \"SPL\".\ndescription: A brief description of your NFT collection.\n[resize]: If you provide \"resize\" as the sixth argument, the script will resize each image to 800x800 pixels. If you don’t have the open-source ImageMagick library installed, you will be prompted to install it. (optional)\n\nAfter running the script, your images and corresponding JSON metadata files will be properly organized and prepared for uploading with Sugar. The original files are copied to an originals subfolder, which can be deleted if you no longer want them.Name your collection anything you want, I named my collection Space Llamas and preapred them using this command:\n./prepare-imges.sh assets png \"Space Llamas\" \"SPL\" \"These llamas are going to the moon\" resize","uploading-with-sugar#Uploading with Sugar":"Now that your images are ready to go, you’ll use Metaplex’s Sugar CLI to upload them to Irys. Again, make sure you’re in the NFTs directory, and start by creating a sugar config file:\nsugar config create\nYou’ll be prompted with a series of questions. In the first one, if Sugar reports finding the correct number of files, press y. If you’re working with my sample images you should have 20 file pairs:\nFound 20 file pairs in \"assets\". Is this how many NFTs you will have in your candy machine?\nNext, you’ll need to confirm the symbol used for your collection, press y to confirm:\nFound symbol \"SPL\" in your metadata file. Is this value correct?\nNext, you’ll need to confirm the royalty you want to charge on secondary sales. The number is supplied in basis points, which are percentage times 100. To charge a 5% royalty, enter 500:\nWhat is the seller fee basis points?\nNext, decide how you want to manage index generation. Candy Machine supports sequential and random mint indexes. In most cases, you will want to choose n here so that the random mint index makes it harder for botters to snipe specific NFTs:\nDo you want to use a sequential mint index generation? We recommend you choose no.\nEach NFT collection can have a max of 4 creator wallets that payments are automatically split between, for this tutorial just choose 1:\nHow many creator wallets do you have? (max limit of 4) ›\nEnter your wallet address (you can find the wallet address you created earlier by entering solana address from a new command prompt):\nEnter creator wallet address #1 ›\nFinally, assign 100% of revenue to that wallet:\nEnter royalty percentage share for creator #1 (e.g., 70). Total shares must add to 100. ›\nWhen prompted to add extra features, just press the enter to skip:\nWhich extra features do you want to use? (use [SPACEBAR] to select options you want and hit [ENTER] when done) ›\nMetaplex uses a Solana program (equivalent of a smart contract on Ethereum) to track ownership of NFTs and gives users options about where to store the NFT assets.For your NFT to be permanent, it must be fault-tolerant, tamperproof, and paid-for:\nFault-tolerant:\nThis means that the data is stored so that it can survive unexpected events, including data corruption and loss.\nTamperproof:\nThe stored data is immutable so it can’t be maliciously changed.\nPaid-for:\nThis means that the cost of storing the data permanently is covered up-front, and there is a mechanism for paying miners on an acceptable cadence. This provides strong incentives for storing the data forever.\n\nArweave is all of these things, and by using Irys to upload your NFTs to Arweave, you’re guaranteed they will be available forever. Not all of the upload options supported by Sugar offer these same guarantees of permanence, which is why we recommend always choosing Irys to upload.\nIrys was previously named Bundlr. At the time this tutorial was\nreleased, the Metaplex tools still refer to us by our old name. When uploading with sugar, you can choose either\nBundlr or Irys, your NFTs will still be uploaded and permanently stored on Arweave.\n\n? What upload method do you want to use? ›\n❯ Bundlr\nAWS\nNFT Storage\nSHDW\nPinata\nSelect y again to make your NFTs mutable:\nDo you want your NFTs to remain mutable? We HIGHLY recommend you choose yes.\nAfter the process completes, you'll see two new files in your local directory.\ncache.json: Lists each NFT, including links to where your images and metadata are stored on Arweave.\nconfig.json: Contains information describing your project setup. You will need to manually modify this file to set the mint price for each NFT.\n\nNow find this section:\n\"guards\": null,\nAnd replace it with the following. Make sure to change the value for the destination field to the wallet address you created earlier. If you forget the value, just enter solana address from the command line.\n\"guards\": {\n\"default\": {\n\"solPayment\": {\n\"value\": 0.1,\n\"destination\": \"69Z4dXS8aAvDhP4QDRs5C2LePnpYApZX8rvnZ69r6ic1\"\n}\n}\n},\nI've used a price of 0.1 SOL, but you can change as you want. Just be careful, don't make the price too high, you'll use Devnet SOL in your wallet to test minting. If the mint price is too high, you'll need to go back to the faucet often to get more funds.After modifying the file, run this command to update your configuration:\nsugar guard add\nAnd finalize your upload:\nsugar upload\n\nIrys supports payment with 14 different tokens, when using the Metaplex tools the\nwallet you previously set up will be automatically debited with SOL to cover the costs. You should already have\nDevnet SOL, which is all you’ll need now. If you decide to launch your collection on Mainnet later, ensure your\nwallet has sufficient Mainnet SOL first.\nCreate and deploy a candy machine:\nsugar deploy\nAnd verify successful deployment:\nsugar verify","building-the-marketplace#Building the marketplace":"Your NFTs are now uploaded to Irys and prepared to be minted on Solana. The last Metaplex tool we’ll use is Candy Machine, which handles the minting and distribution of your NFTs. If you again look at the cache.json file that was generated by Sugar when uploading, you’ll notice this section at the top.\n\"program\": {\n\"candyMachine\": \"CUSxUaAHZrNcuqpt1vTcpSkyAJaqHptrSLiiBAKmLFsz\",\n\"candyGuard\": \"Bjwk3LvE4FHbrV5wtkAn5Au1umBAxmVFwp8Rd6aTrtgW\",\n\"candyMachineCreator\": \"8GfTtubZ8K1q4UJBp1L5ZeahazQQSpdMjB8Gco6Xixvd\",\n\"collectionMint\": \"7K3zV7mS3XMGi7vQhwQzXnuvQDF4r56mqx7PVupntmUV\"\n},\nThis indicates that a Candy Machine instance has already been set up for your project. Note the value of the candyMachine property, you’ll need that soon.","folder-structure#Folder structure":"Within the GitHub repository you downloaded, there is a subdirectory called mint-storefront. cd into this directory and take a look at the folder structure. As this tutorial focuses on building with Metaplex, I created a UI framework so we don’t have to spend time covering the basics of how to use NextJS and Tailwind. The NextJS project has been set up for you and the UI framework is there.Return to your terminal and from the mint-storefront directory run:\nnpm install\nAnd then\nnpm run dev\nIf you open up http://localhost:3000/ in your browser, you’ll see the beginning of the UI. The top nav is there, but the buttons don’t work yet, and the bottom preview area is empty.\n\nTake a moment to look through the code, both the UI components in the components folder and the utility functions in the utils folder. Focus specifically on the components highlighted in the image below, that’s where you’re going to be all of your building.","envlocal#.env.local":"Inside the mint-storefront directory, look for a file called .env.local.example and rename it to .env.local.The file contains two fields:\nNEXT_PUBLIC_RPC_URL: is where you can put a custom Solana RPC, like the fast ones from Helius. This parameter is optional, if left blank, the code will revert to using the free shared endpoints.\nNEXT_PUBLIC_CANDY_MACHINE: is where you should put the value of the candyMachine field from the cache.json file generated by Sugar earlier.\n\nAfter renaming this file and configuring the file, restart your NextJS server for them to take effect.\nNEXT_PUBLIC_RPC_URL=\nNEXT_PUBLIC_CANDY_MACHINE=\nThere are two features we need to implement in for our NFT Marketplace to be complete.\nPreviewing NFTs\nMinting NFTs","previewing-nfts-utilsloadnftsts--componentsnfts#Previewing NFTs: utils/loadNFTs.ts & components/NFTs":"Previewing NFTs is managed by a utility function called utils/loadNFTs.ts, and a UI component called components/NFTs. The NFTs component covers the whole bottom part of the screen, and then inside that, we’ll render each individual NFT using the NFT component.Start with the file utils/loadNFTs.ts, inside it you’ll notice an empty function called loadNFTs().\nimport { createUmi } from \"@metaplex-foundation/umi-bundle-defaults\";\nimport { fetchCandyMachine } from \"@metaplex-foundation/mpl-candy-machine\";\nimport { PublicKey, Pda } from \"@metaplex-foundation/umi\";\n\n/**\n* Loads preview images of all NFTs in the collection\n*/\nexport const loadNFTs = async (): Promise<string[]> => {};\nThe purpose of this function is to load preview images of all NFTs in our collection. To complete the function, type in the following lines between the main curly braces of the function.\nconst umi = createUmi(process.env.NEXT_PUBLIC_RPC_URL || \"https://api.devnet.solana.com\");\nconst candyMachine = await fetchCandyMachine(umi, process.env.NEXT_PUBLIC_CANDY_MACHINE || \"\");\nconst arrayBuilder: string[] = [];\nfor (let i = 0; i < candyMachine.items.length; i++) {\narrayBuilder.push(candyMachine.items[i].uri);\n}\nreturn arrayBuilder;\nIn this code, we start by getting an instance to an UMI object. Since the UMI object is the conduit we use to communicate with the Solana blockchain, we need to pass it an RPC address. In my case, I’ve checked if a custom address was provided in the .env file, and either used that or a default address.Next, we get an instance to a Candy Machine object by passing in the UMI object and the address of our Candy Machine. Finally, we extract the URI of each NFT’s metadata file and return them in an array.With the utility function complete, swap on over to components/NFTs where we’ll call our loadNFTs() function.At the top of the file, you’ll notice this section:\nuseEffect(() => {}, []);\n\nconst doLoadNFTs = async () => {};\nIn Next / React projects, the useEffect() function is called when a component loads. Add a single line to this function calling doLoadNFTs(), and then inside doLoadNFTs() add one line of code where you call our loadNFTs() utility function. Take the results of this and set it as React state variable called nftMetadata. Your completed code should look like this.\nuseEffect(() => {\ndoLoadNFTs();\n}, []);\n\nconst doLoadNFTs = async () => {\nsetNftMetadata(await loadNFTs());\n};\nReturn to http://localhost:3000/ and you should see all 20 of your NFTs previewed.","minting-nfts-utilsdomintts--componentsmintbutton#Minting NFTs: utils/doMint.ts & components/MintButton":"The final step before launching our NFT Marketplace is finalizing the mint function. With Candy Machine, the minting process has an element of surprise. Users can't select a specific NFT; they receive them in sequence. Often, NFT creators make some pieces rarer than others. Since users can't choose which one they’re minting, some may mint multiple times, hoping for a rarer NFT with a higher resale value.Again starting with `utils/doMint.ts, you’ll notice an empty function.\n/**\n* Mints a random NFT from the collection owned by the\n*/\nexport const doMint = async (wallet: WalletAdapter) => {};\nReplace it with this. You’ll notice it starts out similar to loadNFTs() in that it gets a reference to UMI and CandyMachine objects, but this time it goes further and executes a transaction instead of simply reading data.\nexport const doMint = async (wallet: WalletAdapter) => {\n// Get a reference to the UMI object, our conduit to the Solana blockchain\nconst umi = createUmi(process.env.NEXT_PUBLIC_RPC_URL || \"https://api.devnet.solana.com\").use(mplCandyMachine());\numi.use(walletAdapterIdentity(wallet));\n\n// Get a reference to our collection's unique Candy Machine\nconst candyMachinePublicKey = publicKey(process.env.NEXT_PUBLIC_CANDY_MACHINE || \"\");\n\n// Get a reference to the transaction signer\nconst collectionUpdateAuthority = generateSigner(umi);\nconst candyMachine = await fetchCandyMachine(umi, candyMachinePublicKey);\nconst nftMint = generateSigner(umi);\n\n// Get a reference to the collection's metadata\nconst nftMetadata = await fetchMetadataFromSeeds(umi, { mint: candyMachine.collectionMint });\n\n// Build and execute the mint function\nawait transactionBuilder()\n.add(setComputeUnitLimit(umi, { units: 800_000 }))\n.add(\nmintV2(umi, {\ncandyMachine: candyMachine.publicKey,\ncandyGuard: candyMachine.mintAuthority,\nnftMint,\ncollectionMint: candyMachine.collectionMint,\ncollectionUpdateAuthority: nftMetadata.updateAuthority,\ntokenStandard: candyMachine.tokenStandard,\nmintArgs: {\nsolPayment: { destination: candyMachine.authority },\n},\n}),\n)\n.sendAndConfirm(umi);\n};\nJust one last piece and you’re done. Open up components/MintButton and look for this empty function.\nconst mintNFT = async () => {};\nAnd then type in this. The function does very little other than set a few state variables and call our doMint() function.\nconst mintNFT = async () => {\n// Set isLoading state variable to true\n// We use this to disable the button and show a spinner instead\nsetIsLoading(true);\ntry {\n// Execute our doMint function passing in the user's wallet (for signing)\nawait doMint(wallet);\n\n// Set a state variable used to show confetti\nsetShowConfetti(true);\n\n// Show a confirmation message\nsetMessage(\"NFT minted, check your wallet!\");\n} catch (e) {\nsetMessage(\"Error minting NFT: \" + e);\n}\n// Set isLoading state variable back to false to re-enable\n// the mint button and hide the spinner\nsetIsLoading(false);\n};","testing-the-app#Testing The App":"If you did everything correctly, your NFT Marketplace should now be fully functional. Make sure you’ve installed the Phantom wallet and funded it with Devnet Solana. Then, return to your browser, click Select Wallet button to connect your wallet, and the Mint Random NFT button to mint an NFT.\n\nOnce the confetti rains down and you see a success message, reach up and check your Phantom wallet. If everything worked properly you should see the NFTs in your wallet. It will look something like this.","troubleshooting#Troubleshooting":"If things didn’t work, again return to your code and make sure you typed everything in correctly. If you’re still stuck though, jump on over to the Irys Discord and someone will help you debug it.","extending-candy-machine-with-guards#Extending Candy Machine with Guards":"The purpose of this tutorial was to introduce the fundamentals of creating a Solana NFT marketplace using Metaplex and Irys. While this guide offers a foundational understanding, it doesn't cover all of Metaplex's features. For example, instead of using the Sugar CLI, you can instead set up your collection using their JS SDK.One feature you will likely want to take advantage of to customize your collection is guards, a modular piece of code that can restrict access to the mint of a Candy Machine and add new features to it. With a variety of guards available, each can be tailored and activated as desired. While I didn’t call it out at the time, when you added a mint price of 0.1 SOL to your collection, you were configuring a guard.For a deeper dive into guards, refer to the official documentation. Some noteworthy guards include:\nStart Date/End Date guards: Limits minting within a specific timeframe.\nToken Gate/NFT Gate guards: Allows minting only for select token or NFT holders.\nAllow List guard: Limits minting to a specified wallet list.","thank-you#Thank you!":"When you’re done, make sure to share some screenshots on X (Twitter) and tag us at @irys_xyz and the team at @metaplex.LFB frens!"}},"/hands-on/tutorials/irys-sdk":{"title":"Irys Sdk","data":{"":"In this tutorial you will learn how to use Irys with NodeJS to permanently store data with strong provenance using a few lines of code.","prerequisites#Prerequisites":"To use this tutorial, you will need:\nA crypto wallet with a small amount of Devnet tokens\nA recent version of NodeJS\nA code editor (VSCode or others)","installing#Installing":"First make sure you have Node installed:\nnode -v\nIf you get a version number like \"v16.14.0\" back, you’re good to go. Otherwise, install Node.Next, create a new directory and cd into it.\nmkdir irys-basics\ncd irys-basics\nAnd then install the SDK\nusing npm:\nnpm install @irys/sdk\nor using yarn:\nyarn add @irys/sdk\nWhen you use npm or yarn to install the SDK, it will create a file titled package.json in your root directory. Open up that file and add \"type\" : \"module\" to the beginning, allowing you to use ES6 module imports.Finally, run the following in your command prompt to create a new JavaScript file, then fire up your code editor of choice.\ntouch irys-basics.js","dotenv#dotenv":"Install the free dotenv package. We will store our private key in a .env file and access it using the dotenv package.\nnpm install dotenv\nNow create a file called .env in your main directory:\ntouch .env\nAnd edit it to contain the private key of a wallet file that has been funded with free MUMBAI MATIC.\nETH_PRIVATE_KEY=________","connecting-to-a-node#Connecting to a node":"Connect to a node by supplying a Node address and the name of a the token you'll use to pay for uploads. In this example we connect to the Irys devnet, which also requires you to pass an RPC URL. When connecting to Nodes 1 and 2, you don't need to supply an RPC address.\nconst getIrys = async () => {\nconst url = \"https://devnet.irys.xyz\";\n// Devnet RPC URLs change often, use a recent one from https://chainlist.org/chain/80001\nconst providerUrl = \"\";\nconst token = \"matic\";\n\nconst irys = new Irys({\nurl, // URL of the node you want to connect to\ntoken, // Token used for payment\nkey: process.env.ETH_PRIVATE_KEY, // Private key\nconfig: { providerUrl }, // Optional provider URL, only required when using Devnet\n});\nreturn irys;\nconsole.log(`wallet address = ${irys.address}`);\n};\nawait getIrys();\nPaste the above code into the irys-basics.js file you created and then run it by typing:\nnode irys-basics.js\nfrom your CLI, if it successfully prints your wallet address, you’re good to go.","funding-a-node#Funding a node":"To fund a node, pass the amount you want to fund in atomic units. Assuming you setup Irys to use Mumbai Matic, the following will fund 0.5 MATIC:\nconst fundNode = async () => {\nconst irys = await getIrys();\ntry {\nconst fundTx = await irys.fund(irys.utils.toAtomic(0.5));\nconsole.log(`Successfully funded ${irys.utils.fromAtomic(fundTx.quantity)} ${irys.token}`);\n} catch (e) {\nconsole.log(\"Error uploading data \", e);\n}\n};\nawait fundNode();\nPaste the above code into irys-basics.js and run as you did before.","checking-upload-price#Checking upload price":"You can check the cost to upload data by passing a number of bytes to the function irys.getPrice(). This code checks the cost to upload 1 Megabyte (1048576 bytes).\nconst checkPrice = async () => {\nconst irys = await getIrys();\n\nconst numBytes = 1048576; // Number of bytes to check\nconst priceAtomic = await irys.getPrice(numBytes);\n\n// Convert from atomic units to standard units\nconst priceConverted = irys.utils.fromAtomic(numBytes);\n\nconsole.log(`Uploading ${numBytes} bytes costs ${priceConverted}`);\n};\nawait checkPrice();","uploading-data#Uploading data":"If it can be reduced to 1s and 0s, it can be uploaded to Arweave via Irys using the function irys.upload(), as with this example that uploads the string \"GM world.\"\nconst uploadData = async () => {\nconst irys = await getIrys();\nconst dataToUpload = \"GM world.\";\ntry {\nconst receipt = await irys.upload(dataToUpload);\nconsole.log(`Data uploaded ==> https://gateway.irys.xyz/${receipt.id}`);\n} catch (e) {\nconsole.log(\"Error uploading data \", e);\n}\n};\nawait uploadData();","uploading-a-file#Uploading a file":"You can upload a file by passing its name to the function irys.uploadFile(). To run this code, find a PNG file on your local drive, rename it to myImage.png and place it in the same directory as the irys-basics.js file.\nconst uploadFile = async () => {\nconst irys = await getIrys();\n// Your file\nconst fileToUpload = \"./myImage.png\";\n\nconst tags = [{ name: \"application-id\", value: \"MyNFTDrop\" }];\n\ntry {\nconst receipt = await irys.uploadFile(fileToUpload, { tags });\nconsole.log(`File uploaded ==> https://gateway.irys.xyz/${receipt.id}`);\n} catch (e) {\nconsole.log(\"Error uploading file \", e);\n}\n};\n\nawait uploadFile();","uploading-a-folder#Uploading a folder":"You can also upload an entire folder of images with a single line of code. To run this example, create a directory in the same folder as irys-basics.js and fill it with image files.\nconst uploadFolder = async () => {\nconst irys = await getIrys();\n\n// Upload an entire folder\nconst folderToUpload = \"./my-images/\"; // Path to folder\ntry {\nconst receipt = await irys.uploadFolder(\"./\" + folderToUpload, {\nindexFile: \"\", // optional index file (file the user will load when accessing the manifest)\nbatchSize: 50, //number of items to upload at once\nkeepDeleted: false, // whether to keep now deleted items from previous uploads\n}); //returns the manifest ID\n\nconsole.log(`Files uploaded. Manifest Id ${receipt.id}`);\n} catch (e) {\nconsole.log(\"Error uploading file \", e);\n}\n};\nawait uploadFolder();\nFiles uploaded via irys.uploadFolder(folderToUpload) can be retrieved in one of two ways.\nCreating a URL with the format https://gateway.irys.xyz/[manifest-id]/[original-file-name].\nCreating a URL using the transaction ID of each individual file uploaded with the format https://gateway.irys.xyz/[transacton-id]\n\nAfter a successful folder upload, two files are written to your local project directory [folder-name].csv and [folder-name].json. The example below highlights a folder called “llama_folder” with a total of 5 files in it. The transaction id for each file can be used to retrieve the uploaded data by forming a URL with the format https://gateway.irys.xyz]/[transaction-id]","uploading-a-static-website#Uploading a static website":"You can also use the SDK to uplaod an entire static website to the permaweb.","getting-help#Getting help":"If you get stuck or need help, reach out in our Discord and someone will get back to you quickly.And, most importantly pleaase let us know how you're using Irys and what you're building. Let us know how we can best support you!"}},"/hands-on/tutorials/monitor-node-balance":{"title":"Monitor Node Balance With A Script","data":{"":"Irys' upfront funding simplifies the uploading process by allowing you to pre-fund your uploads. This eliminates the need for individual funding calls for each upload as the loaded balance is automatically deducted from with each upload. To keep track of your loaded balance, users commonly create scripts that periodically check their balance and provide notifications when it approaches zero.This tutorial offers examples of how to monitor your balance using JavaScript, our Command Line Interface (CLI), and cURL. These techniques are all equally effective options for balance monitoring, choose the method that aligns with your unique architecture and requirements.","javascript#JavaScript":"import Irys from \"@irys/sdk\";\nimport dotenv from \"dotenv\";\ndotenv.config();\n\nconst getIrys = async () => {\nconst url = \"https://devnet.irys.xyz\";\n// Devnet RPC URLs change often, use a recent one from https://chainlist.org/chain/80001\nconst providerUrl = \"\";\nconst token = \"matic\";\nconst privateKey = process.env.PRIVATE_KEY;\n\nconst irys = new Irys({\nurl: url, // URL of the node you want to connect to\ntoken: token, // Token used for payment\nkey: privateKey, // ETH or SOL private key\nconfig: { providerUrl: providerUrl }, // Optional provider URL, only required when using Devnet\n});\nreturn irys;\n};\n\nconst checkBalance = async () => {\nconst irys = await getIrys();\n\n// Get loaded balance in atomic units\nconst atomicBalance = await irys.getLoadedBalance();\n// Convert balance to standard units\nconst convertedBalance = irys.utils.fromAtomic(atomicBalance);\nreturn convertedBalance;\n};\n\nconst checkAndPrintBalance = async () => {\nconst balance = await checkBalance();\nconst threshold = 0.1; // 10% threshold\n\nif (Math.abs(balance) <= threshold) {\nconsole.log(`Balance ${balance} is within 10% of 0, please fund.`);\n} else {\nconsole.log(`Balance ${balance} funding not yet needed.`);\n}\n};\n\n// Call the function immediately\ncheckAndPrintBalance();\n\n// Then repeat every 30 minutes\nsetInterval(checkAndPrintBalance, 30 * 60 * 1000);","cli#CLI":"You can achieve the same thing using our CLI and a bash script. The advantage to doing it this way is you’re not connecting to an Irys node, which means you don’t need to provide your private key. Using your wallet’s public address, the script calls our CLI’s irys balance command, parses the output and tests if it’s close to 0.\n#!/bin/bash\n\n# Define your variables\naddress=\"0xaC568a981B1370B2e1bAA8cE30BD5AC9E28C572D\" # Public wallet address\n# Devnet RPC URLs change often, use a recent one from https://chainlist.org/chain/80001\nprovider_url=\"https://rpc-mumbai.maticvigil.com\"\nnode_address=\"https://devnet.irys.xyz\"\ntoken=\"matic\"\nbalance_output=\"\";\n\n# Check if node_address contains \"devnet\"\n# When using devnet, you must also include a provider-url\nif [[ $node_address == *\"devnet\"* ]]; then\nbalance_output=$(irys balance $address --provider-url $provider_url -h $node_address -c $token)\nelse\nbalance_output=$(irys balance $address -h $node_address -t $token)\nfi\n\n# Use regex to parse the output and assign the parsed value to a variable\nparsed_balance=$(echo $balance_output | awk -F'[()]' '{split($2,a,\" \"); print a[1]}')\n# Define your threshold\nthreshold=0.1\n\n# Check if parsed_balance is within threshold of 0\nis_close_to_zero=$(echo \"$parsed_balance < $threshold\" | bc -l)\n\nif [ $is_close_to_zero -eq 1 ]; then\necho \"Balance ${parsed_balance} is within $(echo \"$threshold*100\" | bc -l)% of 0, please fund.\"\nelse\necho \"Balance ${parsed_balance} funding not yet needed\"\nfi\nTo run a bash script periodically, use cron. Assuming you saved the above script as a file checkBalance.sh, open up your crontab file using crontab -e and then add an entry to call the script periodically. To call it every 30 minutes, you’d add the following:*/30 * * * * /path/to/your/script/checkBalance.sh","curl#cURL":"A third option is to make cURL request using a URL with the following format https://<node-address>/account/balance/<token>?address=<address>. For example to check the Devnet MATIC balance of the wallet with address 0xaC568a981B1370B2e1bAA8cE30BD5AC9E28C572D, you would use the command\nhttps://devnet.irys.xyz/account/balance/matic?address=0xaC568a981B1370B2e1bAA8cE30BD5AC9E28C572DJust as with our CLI, you don’t need to provide your private key. This version is also more streamlined than the CLI version as you don’t need to include the provider URL when checking the Devnet balances.\n#!/bin/bash\n\n# Define your variables\naddress=\"0xaC568a981B1370B2e1bAA8cE30BD5AC9E28C572D\" # Public wallet address\nnode_address=\"https://devnet.irys.xyz\"\ntoken=\"token\"\nbalance_output=\"\";\n\n# Create the API endpoint URL\nbalance_check_url=\"${node_address}/account/balance/${token}?address=${address}\"\n\n# Make the cURL request and capture the response\nbalance_output=$(curl -s \"$balance_check_url\")\n\n# Parse the balance from the response using awk\nparsed_balance=$(echo \"$balance_output\" | awk -F'\"' '{print $4}')\n\n# Define the decimal factor for conversion (this works for MATIC and others with 18 decimals)\ndecimal_factor=1000000000000000000\n\n# For Solana currencies with 9 decimals, use\n# decimal_factor=1000000000\n\n# Convert parsed_balance to standard units\nbalance_in_standard_units=$(awk -v parsed_balance=\"$parsed_balance\" -v decimal_factor=\"$decimal_factor\" 'BEGIN{printf \"%.18f\", parsed_balance/decimal_factor}')\n\n# Define your threshold in standard units\nthreshold=0.1\n\n# Check if balance_in_standard_units is within threshold of 0\nis_close_to_zero=$(awk -v balance=\"$balance_in_standard_units\" -v threshold=\"$threshold\" 'BEGIN{if(balance < threshold) print 1; else print 0}')\n\nif [ $is_close_to_zero -eq 1 ]; then\necho \"Balance ${balance_in_standard_units} is within $(echo \"$threshold*100\" | bc -l)% of 0, please fund.\"\nelse\necho \"Balance ${balance_in_standard_units} funding not yet needed\"\nfi\nTo run a bash script periodically, use cron. Assuming you saved the above script as a file checkBalance.sh, open up your crontab file using crontab -e and then add an entry to call the script periodically. To call it every 30 minutes, you’d add the following:*/30 * * * * /path/to/your/script/checkBalance.sh"}},"/hands-on/tutorials/udl-nft":{"title":"Define NFT licensing with the UDL","data":{"":"In this tutorial, you'll learn how to attach a Universal Data License (UDL) to an NFT.The UDL is a parameterized license you can use to explicitly define how you allow your content to be used.","overview#Overview":"Purchasing an NFT not only gives you ownership of the token itself but, depending on the collection, may also grant certain rights over the underlying intellectual property. These rights cover things like creating derivative works or merchandising the artwork on items such as t-shirts. Each NFT collection varies in the rights it provides to its token holders and historically, there hasn't been a standard license attached to NFTs.With the UDL creators now have a simple, customizable license they can easily attach to NFT metadata at upload that spells out the permissions they grant to the token holders.","adding-udl-to-nfts#Adding UDL to NFTs":"Creating an NFT is (generally) a four step process:\nUpload the visual asset (image or video)\nEmbed the URL to the visual asset in a metadata file\nUpload the metadata file\nUse the link to the metadata when minting the NFT\n\nFor more details on this, we have a separate tutorial.When uploading the metadata, you can attach a UDL in the form of tags with name / value pairs.If you’re using our NodeJS SDK to upload your metadata files, you can modify your upload script to include the UDL parameters. Not all UDL tags are required, and the ones you use will depend on how you want to allow your content to be used. The script below demonstrates how to add common tags to a metadata file upload, when using it for your own project, customize as needed.\nimport Irys from \"@irys/sdk\";\nimport * as fs from \"fs\";\nimport dotenv from \"dotenv\";\ndotenv.config();\n\n// Returns a reference to an Irys node\nconst getIrys = async () => {\nconst url = \"https://devnet.irys.xyz\";\n// Devnet RPC URLs change often, use a recent one from https://chainlist.org/chain/80001\nconst providerUrl = \"\";\nconst token = \"matic\";\nconst privateKey = process.env.PRIVATE_KEY;\n\nconst irys = new Irys({\nurl, // URL of the node you want to connect to\ntoken, // Token used for payment\nkey: privateKey, // ETH or SOL private key\nconfig: { providerUrl: providerUrl }, // Optional provider URL, only required when using Devnet\n});\nreturn irys;\n};\n\n// Path to metadata file\nconst fileToUpload = \"./metadata.json\";\n\n// Define the Tag type\ntype Tag = {\nname: string;\nvalue: string;\n};\n\n// Define your unique license\nconst tags: Tag[] = [\n{ name: \"Content-Type\", value: \"application/json\" },\n{ name: \"Contract\", value: \"0xd9145CCE52D386f254917e481eB44e9943F39138\" },\n{ name: \"Payment-Mode\", value: \"Global-Distribution\" },\n{ name: \"License\", value: \"yRj4a5KMctX_uOmKWCFJIjmY8DeJcusVk6-HzLiM_t8\" },\n{ name: \"License-Fee\", value: \"Monthly-1\" },\n{ name: \"Derivation\", value: \"Allowed-With-Credit\" },\n{ name: \"Commerical-Use\", value: \"Allowed\" },\n{ name: \"Currency\", value: \"ETH\" },\n];\n\n// Upload the metadata with UDL tags\nconst uploadMetadata = async () => {\ntry {\nconst irys = await getIrys();\nconst response = await irys.uploadFile(fileToUpload, { tags });\nconsole.log(`File uploaded ==> https://gateway.irys.xyz/${response.id}`);\n} catch (e) {\nconsole.log(\"Error uploading file \", e);\n}\n};\nuploadMetadata();","using-the-provenance-toolkit#Using the provenance toolkit":"You can also use the Irys Provenance Toolkit repository which provides a simple graphical interface.\nFork or clone the repository\nUse the Uploader component to upload your visual assets\nUse the UDL Uploader component to upload your metadata file"}},"/hands-on/tutorials/udl-erc20":{"title":"Create an ERC20 profit-sharing token for NFTs with UDL","data":{"":"In this tutorial, you will create a custom ERC20 token and use it to manage fractional ownership of NFTs that have a Universal Data License (UDL).","monetizing-udl#Monetizing UDL":"Using the UDL, creators can define a set of rules that clearly define how their content can be used and what fees are charged for different uses.To charge a fee of 42 tokens, you’d add this tag:\n{ \"name\": \"License-Fee\", \"value\": \"One-Time-42\" }\nTo specify the Matic token, you’d add this tag:\n{ \"name\": \"Currency\", \"value\": \"MATIC\" }\nTo specify that payments should be made to a given address, you’d add this tag:\n{ \"name\": \"Payment-Address\", \"value\": \"0xBundlooor\" }\nHowever this only allows for a single owner, in cases where you want to have fractional ownership, you would attach a profit-sharing token (PST) contract to the UDL using the Contract tag:\n{ \"name\": \"Contract\", \"value\": \"0xFoo\" }\nWhen the Contact tag is present, you have to further define how payments should be distributed:Either setting it so that fees are split between all holders proportionally to their holdings:\n{ \"name\": \"Payment-Mode\", \"value\": \"Global-Distribution\" }\nOr randomly distributed to one holder, with distribution weighted proportionally to holdings:\n{ \"name\": \"Payment-Mode\", \"value\": \"Random-Distribution\" }\nIn this tutorial, we’ll write an ERC20 profit-sharing token contract. The contract will be set to either global or random distribution at creation and will expose a function called distributeRevenue() which accepts payments and distributes it between holders. You can use the contract as is, or use its logic as a base for building your own contracts.","prerequisites#Prerequisites":"To complete this tutorial, you should have a basic understanding of the UDL and the opportunities it affords builders. You should understand the basics of Solidity but do not need to be an expert.","the-smart-contract#The smart contract":"Our contract, named MySong, represents ownership in a single music NFT. This contract is an ERC20 token, and we've set its total supply to a fixed 100 tokens.\nHaving 100 tokens makes it easy to mentally model ownership amounts, as having 1 coin means you own 1% of the total.\nIn practice, the number of coins could be anything.\nThe majority of the contract is boilerplate ERC20, it mints 100 tokens to the contract deployer at creation, and through inheritance, it includes functions for transferring tokens between addresses.In its constructor, the contract is set to either global or random mode, and then exposes a function called distributeRevenue(), which splits revenue payments among token-holders. The function accepts payment in the form of ETH, then either does global or random distribution. To simplify things, this contract uses pseudo-random number generation which comes with an element of risk. When building your own solutions, you might choose to use a verifiable random number generator.\nThis is just one way revenue distribution could be handled, another way would be for the contract to hold all\npayments and let recipients claim them when it makes sense. This method would help save gas costs, as recipients\ncould choose to only take distributions when their balance is higher the gas fees.\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract MySong is ERC20, Ownable {\nusing SafeMath for uint256;\n\nenum PaymentMode { GLOBAL, RANDOM }\nPaymentMode public paymentMode;\n\nconstructor(PaymentMode _paymentMode) ERC20(\"MySong\", \"MSG\") {\n_mint(msg.sender, 100);\npaymentMode = _paymentMode;\n}\n\nfunction distributeRevenue() external payable onlyOwner {\nuint256 totalSupply = totalSupply();\nrequire(totalSupply > 0, \"No tokens exist.\");\n\nif (paymentMode == PaymentMode.GLOBAL) {\n_distributeGlobal();\n} else if (paymentMode == PaymentMode.RANDOM) {\n_distributeRandom();\n}\n}\n\nfunction _distributeGlobal() private {\nfor (uint256 i = 0; i < _holders.length; i++) {\naddress holder = _holders[i];\nuint256 holderBalance = balanceOf(holder);\n\nif (holderBalance > 0) {\nuint256 amountToDistribute = msg.value.mul(holderBalance).div(totalSupply());\npayable(holder).transfer(amountToDistribute);\n}\n}\n}\n\nfunction _distributeRandom() private {\nuint256 randomValue = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender))) % totalSupply();\nuint256 cumulativeSum = 0;\n\nfor (uint256 i = 0; i < _holders.length; i++) {\naddress holder = _holders[i];\nuint256 holderBalance = balanceOf(holder);\n\ncumulativeSum = cumulativeSum.add(holderBalance);\n\nif (randomValue < cumulativeSum) {\npayable(holder).transfer(msg.value);\nbreak;\n}\n}\n}\n\naddress[] private _holders;\n\nfunction _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\nsuper._beforeTokenTransfer(from, to, amount);\n\nif (from == address(0)) {\n_addHolder(to);\n} else if (to == address(0)) {\n_removeHolder(from);\n} else {\n_addHolder(to);\n}\n}\n\nfunction _addHolder(address newHolder) private {\nif (balanceOf(newHolder) == 0) {\n_holders.push(newHolder);\n}\n}\n\nfunction _removeHolder(address oldHolder) private {\nif (balanceOf(oldHolder) == 0) {\nfor (uint256 i = 0; i < _holders.length; i++) {\nif (_holders[i] == oldHolder) {\n_holders[i] = _holders[_holders.length - 1];\n_holders.pop();\nbreak;\n}\n}\n}\n}\n} // MySong","testing-on-remix#Testing on Remix":"To understand how token works, let’s test it in the Remix IDE.","deploying-the-contract#Deploying the contract":"Launch Remix\nSelect Environment: In the left sidebar, under the \"Deploy & run transactions\" tab, ensure \"Remix VM (Shanghai)\" is selected as the environment.\nPaste the Contract: In the “File explorer” tab click the + icon to create a new file. Name it MySong.sol and paste in the MySong contract code.\nCompile the Contract: In the left sidebar, click on the \"Solidity compiler\" tab, then click the \"Compile MySong.sol\" button.\nDeploy: Go back to the \"Deploy & run transactions\" tab. MySong should be selected in the \"Contract\" dropdown. Click the orange \"Deploy\" button and either enter 0 for global distribution or 1 for random distribution.","transferring-tokens#Transferring tokens":"Once the contract is deployed, under \"Deployed Contracts\", find MySong. You'll see buttons representing contract functions. To transfer tokens:\nClick the transfer function.\nEnter the recipient address in the \"to\" field (choose from the \"Account\" dropdown at the top of the page)\nSpecify the number of tokens to send in the \"value\" field ( 100)\nClick the transact button.","sending-revenue#Sending revenue":"Once you’ve distributed tokens between holders, test revenue distribution.\nIn the \"Deploy & run transactions\" tab, above to the \"Deploy\" button, there's a field labeled \"Value\". Enter the amount of Ether you want to distribute as revenue.\nn the \"Deployed Contracts\" section, find MySong and click the distributeRevenue() function.\nClick the transact button.\nCheck Balances: After distributing revenue, you can switch between accounts in the \"Account\" dropdown at the top to see how the Ether balance of each account has changed.","contract-tag#Contract tag":"After creating and deploying the contract, fork the Irys Provenance Toolkit and use the Irys UDL Uploader to upload a new asset while setting the Contract tag to be the address of the smart contract you just deployed. This pairs the UDL-protected asset with the smart contract, establishing a payment management rule for platforms.","alternatives#Alternatives":"While creating a custom ERC20 and attaching it to the NFT’s UDL via the Contract tag works fine, it has one possible downside that the ERC20 needs to be created before the NFT. You create the ERC20 contract and then attach the contract address to the NFT’s UDL. In cases where you have an existing NFT with UDL, and want to layer on fractional ownership afterwards, you will need an alternative approach, like the one implemented in this repository.","extending#Extending":"Using an ERC20 token to model ownership of a UDL asset opens up new ideas for builders including:\nCreating a DEX that focuses on trading the tokens, where the market cap of the token represents the value placed on the UDL NFT.\nCreating a lending platform that uses the tokens as collateral. The platform could base the loan amount on the artist’s historical sales data.\nGifting long-term token holders with tokens from new creations.\n\nThe UDL's strength lies in its parametrized rules without preset enforcement. As builders, you have the freedom to craft tools that uphold these rules and also innovate beyond them.What will you build?"}},"/hands-on/tutorials/encrypting-onchain-data":{"title":"Encrypting onchain data","data":{"":"Data uploaded to Irys is stored permanently on Arweave. Once on Arweave, this data becomes publicly accessible, anyone can view it. For projects where privacy is a concern, you can use LitProtocol to encrypt your data before storing it on Irys.This guide is an overview of what Lit Protocol is and how to use it with Irys. We also have code examples teaching how to do server-side and browser-based encryption. Additionally, the open-source Irys Provenance Toolkit has an encrypted uploader component you can drop into any React-based project.","lit-protocol#Lit Protocol":"Lit Protocol enables developers to create and manage decentralized keys for condition-based encryption and programmatic signing for digital assets. In short, you can use it to:\nEncrypt data\nDefine fine-grained access rules for who can decrypt data\nDecrypt data\n\nEncrypted data can be stored on Irys, then retrieved and decrypted at any point in the future.","irys--lit-use-cases#Irys + Lit use cases":"Using Lit Protocol with Irys opens up new opportunities for builders, including:\nGating access to content\nEncrypting posts for Lens protocol\nDecentralized identity verification\nCreating private data marketplaces\nCreating NFTs only viewable by their owner\nStoring private personal data on-chain\n\n\nUsing Lit Protocol, the access control conditions provide near infinite flexibility. Imagine a system for government\nbid management: bids are required to be submitted by a specific deadline, tracked using Irys' millisecond-accurate\ntimestamps. The bids remain encrypted up to this deadline, aiding in preventing corruption by ensuring the bids are\ninaccessible to all parties until the designated time.","encrypting-data#Encrypting data":"There are three steps to encrypting data\nObtain a wallet signature (AuthSig), which proves you own a wallet\nDefine access control conditions for who can decrypt your data\nConnect to a Lit node and request that it encrypt your data","access-control-conditions#Access control conditions":"Lit Protocol enables users to set access control conditions specifying who can decrypt data.This provides builders with the flexibility to designate data decryption permissions, including:\nA single wallet address\nDAO membership\nOwners of an ERC20 or ERC721\nOutcomes from a smart contract call\nOutcomes from an API call","decrypting-data#Decrypting data":"There are three steps to decrypting data:\nObtain a wallet signature (AuthSig), which proves you own a wallet\nRetrieve data stored on Arweave\nConnect to a Lit node and request that it decrypt your data","code-examples#Code examples":"Server-side encryption\nBrowser-based encryption","demo#Demo":"Irys Provenance Toolkit"}},"/hands-on/tutorials/livepeer":{"title":"Using Livepeer to transcode video","data":{"":"Livepeer is a decentralized video protocol for transcoding video content. For projects involving both live and recorded video, Livepeer combined with Irys allows you to optimize video delivery for each unique client.","transcoding#Transcoding":"Transcoding is the process of converting between video file format types. When streaming video, it's important as it allows you to optimize video delivery based on factors such as a client's device size, preferences and the quality of their internet connection. This allows you to upload a high-resolution 4K video file, and then deliver formats optimized for TV streaming, tablets and mobile. You can even allow clients to specify lower-quality formats to help economize bandwidth charges.","setup#Setup":"To get started, you'll need to create an API key first.If you're working with React, you can install the Livepeer React SDK with:\nnpm @livepeer/react","transcoding-a-video-stored-on-arweave#Transcoding a video stored on Arweave":"Video files can be uploaded to Arweave via Irys using our CLI, or SDK.Using the <Player> tag from the Livepeer SDK you can embed an Arweave URL, the URL format can be either ar://aqvPK_xi-EDcmAHPAPpDcaYyGekp-06T16ElvNTnJNk or https://gateway.irys.xyz/aqvPK_xi-EDcmAHPAPpDcaYyGekp-06T16ElvNTnJNk. The first time Livepeer encounters the URL it will transcode the file, the transcoded versions are then stored in an account tied to your API key. Transcoded files are kept for as long as your account is active.\n<Player title=\"Irys SDK For NodeJS\" src=\"ar://aqvPK_xi-EDcmAHPAPpDcaYyGekp-06T16ElvNTnJNk\" autoPlay muted />\nIn order to properly transcode your video, the <Player> component must have access to a Livepeer client that contains a valid API key. Best practice is to use the provider pattern and the <LivepeerConfig> component.For example, to make the client available to all child components in your app, you would structure your index.js file as follows.\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport { LivepeerConfig, createReactClient, studioProvider } from \"@livepeer/react\";\n\nconst livepeerClient = createReactClient({\nprovider: studioProvider({\napiKey: process.env.LIVEPEER_API_KEY,\n}),\n});\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(\n<LivepeerConfig client={livepeerClient}>\n<App />\n</LivepeerConfig>,\n);"}},"/hands-on/tutorials/react":{"title":"Using Irys With npx create-react-app","data":{"":"If you're using React with Vite, polyfills are handled differently. You'll need to follow this guide\ninstead.\nIrys is fully compatible with React, however, if you’re using npx create-react-app to create your project, you will need to do some additional configuration and installation. This guide details how to create a new React project and add Irys support, if you already have a React project open, free to skip down a few steps.Create a new directory for your project, cd into it, and create your React project:\nmkdir irys-react\ncd irys-react\nnpx create-react-app .\nInstall the Irys SDK and ethers:\nnpm install @irys/sdk ethers@5\nIn your App.js file write an initialization function that sets up a WebIrys object. The following code shows how to use ethers5, if you're using a different provider make sure to specify it when creating the wallet.\nimport { providers } from \"ethers\";\nimport { WebIrys } from \"@irys/sdk\";\n\nfunction App() {\nconst initialiseIrys = async () => {\nawait window.ethereum.enable();\nconst provider = new providers.Web3Provider(window.ethereum);\nconst wallet = { name: \"ethersv5\", provider: provider };\nconst url = \"https://node1.irys.xyz\";\nconst token = \"matic\";\nconst webIrys = new WebIrys({ url, token, wallet });\nawait webIrys.ready();\nreturn webIrys;\n};\n\nreturn <div className=\"App\">Irys Test</div>;\n}\n\nexport default App;\nViewing that page, you'll get a bunch of errors saying BREAKING CHANGE: webpack < 5 used to include polyfills for node.js core modules by default.To fix this you'll need to include NodeJS polyfills which are no longer included by default.Install first react-app-rewired, a package that allows for editing of the webpack config file to fix polyfill issue. Then install the missing dependencies.\nnpm install react-app-rewired\nnpm install --save-dev crypto-browserify stream-browserify assert stream-http https-browserify os-browserify url buffer process\nnpm install browserify-zlib path-browserify path\nAt the root level of your project, create a new file called config-overrides.js and paste the following in:\nconst webpack = require(\"webpack\");\n\nmodule.exports = function override(config) {\nconst fallback = config.resolve.fallback || {};\nconfig.resolve.alias = { ...(config?.resolve?.alias ?? {}), stream: \"stream-browserify\" };\nObject.assign(fallback, {\ncrypto: require.resolve(\"crypto-browserify\"),\nstream: require.resolve(\"stream-browserify\"),\nassert: require.resolve(\"assert\"),\nhttp: require.resolve(\"stream-http\"),\nhttps: require.resolve(\"https-browserify\"),\nos: require.resolve(\"os-browserify\"),\nurl: require.resolve(\"url\"),\nzlib: require.resolve(\"browserify-zlib\"),\n});\nconfig.resolve.fallback = fallback;\nconfig.plugins = (config.plugins || []).concat([\nnew webpack.ProvidePlugin({\nprocess: \"process/browser\",\nBuffer: [\"buffer\", \"Buffer\"],\n}),\n]);\n\nreturn config;\n};\nOverride package.json to include the new webpack configuration. Look for this code block\n\"scripts\": {\n\"start\": \"react-scripts start\",\n\"build\": \"react-scripts build\",\n\"test\": \"react-scripts test\",\n\"eject\": \"react-scripts eject\"\n},\nand replace it with this block:\n\"scripts\": {\n\"start\": \"react-app-rewired start\",\n\"build\": \"react-app-rewired build\",\n\"test\": \"react-app-rewired test\",\n\"eject\": \"react-scripts eject\"\n},\n\nQuit React server and restart it with npm run start you should be good to go."}},"/hands-on/tutorials/uploading-nfts":{"title":"Uploading NFTs to Irys","data":{"":"When you use Irys to store NFT data on Arweave, you’re guaranteed your NFT will be both permanent and immutable. Here’s how you do it.","nft-assets#NFT assets":"There are generally three parts to an NFT:\nSmart contract\nNFT metadata\nNFT assets\n\nThe smart contract can be on any chain, the metadata and assets are stored on an external storage provider. The smart contract stores a pointer to the NFT metadata, and then the NFT metadata contains links to the NFT assets.In the example above for the Developer Quests NFT, there is a name and description that are shown on platforms like Opensea when the NFT is viewed. The image parameter points to a static image of the NFT. The animation_url parameter is optional and points to a video, song, or HTML animation file.","creating-an-nft#Creating an NFT":"Three steps to creating an NFT:\nUpload your assets to Irys\nEmbed the URLs to the assets in NFT metadata\nUpload metadata to Irys\nUse the metadata URL to mint your NFT\n\n\nThis guide does not cover the smart contract setup, if you’re unsure of how to do this,\nThirdweb has free, audited contracts available for use.","uploading-assets-sdk#Uploading assets (SDK)":"After installing the Irys SDK, use the following to upload your assets.\nimport Irys from \"@irys/sdk\";\nimport * as fs from \"fs\";\nimport dotenv from \"dotenv\";\ndotenv.config();\n\n// Returns a reference to an Irys node\nconst getIrys = async () => {\nconst url = \"https://devnet.irys.xyz\";\n// Devnet RPC URLs change often, use a recent one from https://chainlist.org/chain/80001\nconst providerUrl = \"\";\nconst token = \"matic\";\nconst privateKey = process.env.PRIVATE_KEY;\n\nconst irys = new Irys({\nurl, // URL of the node you want to connect to\ntoken, // Token used for payment\nkey: privateKey, // ETH or SOL private key\nconfig: { providerUrl: providerUrl }, // Optional provider URL, only required when using Devnet\n});\nreturn irys;\n};\n\nconst uploadImage = async () => {\nconst irys = await getIrys();\nconst fileToUpload = \"./myNFT.png\";\n\n// Get size of file\nconst { size } = await fs.promises.stat(fileToUpload);\n// Get cost to upload \"size\" bytes\nconst price = await irys.getPrice(size);\nconsole.log(`Uploading ${size} bytes costs ${irys.utils.fromAtomic(price)} ${token}`);\n// Fund the node\nawait irys.fund(price);\n\n// Upload metadata\ntry {\nconst response = await irys.uploadFile(fileToUpload);\nconsole.log(`File uploaded ==> https://gateway.irys.xyz/${response.id}`);\n} catch (e) {\nconsole.log(\"Error uploading file \", e);\n}\n};","uploading-assets-cli#Uploading assets (CLI)":"Alternatively, you can upload using our CLI.\nirys upload myNFT.png \\\n-h https://devnet.irys.xyz \\\n-t matic \\\n-w bf20......c9885307 \\\n--tags Content-Type image/png \\\n--provider-url https://rpc-mumbai.maticvigil.com","creating-metadata#Creating metadata":"Embed the URLs generated from the above script into your NFT metadata. The following example is from the Developer Quests NFT.\n{\n\"name\": \"Irys Developer Quests Quests\",\n\"description\": \"Irys Developer Quests #42\",\n\"image\": \"https://gateway.irys.xyz/737m0bA1kW4BlIJOg_kOGUpHAAI-3Ec9bdo8S_xTFKI\",\n\"animation_url\": \"https://gateway.irys.xyz/peRdpP3pjyFQ6m4Hca5fZY5zgz7RSlE86j-_5BEwnW0\",\n\"background_color\": \"FEF4EE\"\n}","uploading-metadata-sdk#Uploading metadata (SDK)":"Finally, upload your NFT metadata to Irys and use the URL generated to mint the NFT.\nimport Irys from \"@irys/sdk\";\nimport * as fs from \"fs\";\nimport dotenv from \"dotenv\";\ndotenv.config();\n\n// Returns a reference to an Irys node\nconst getIrys = async () => {\nconst url = \"https://devnet.irys.xyz\";\n// Devnet RPC URLs change often, use a recent one from https://chainlist.org/chain/80001\nconst providerUrl = \"\";\nconst token = \"matic\";\nconst privateKey = process.env.PRIVATE_KEY;\n\nconst irys = new Irys({\nurl, // URL of the node you want to connect to\ntoken, // Token used for payment\nkey: privateKey, // ETH or SOL private key\nconfig: { providerUrl }, // Optional provider URL, only required when using Devnet\n});\nreturn irys;\n};\n\nconst uploadMetadata = async () => {\nconst irys = await getIrys();\n\nconst fileToUpload = \"./metadata.json\";\nconst tags = [{ name: \"Content-Type\", value: \"application/json\" }];\n\n// Get size of file\nconst { size } = await fs.promises.stat(fileToUpload);\n// Get cost to upload \"size\" bytes\nconst price = await irys.getPrice(size);\nconsole.log(`Uploading ${size} bytes costs ${irys.utils.fromAtomic(price)} ${token}`);\n// Fund the node\nawait irys.fund(price);\n\n// Upload metadata\ntry {\nconst response = await irys.uploadFile(fileToUpload, { tags });\nconsole.log(`File uploaded ==> https://gateway.irys.xyz/${response.id}`);\n} catch (e) {\nconsole.log(\"Error uploading file \", e);\n}\n};","uploading-metadata-sdk-1#Uploading metadata (SDK)":"Alternatively, you can upload using our CLI.\nirys upload metadata.json \\\n-h https://devnet.irys.xyz \\\n-t matic \\\n-w bf20......c9885307 \\\n--tags Content-Type application/json \\\n--provider-url https://rpc-mumbai.maticvigil.com"}},"/hands-on/tutorials/server-side-encryption":{"title":"Encrypting onchain data (server-side)","data":{"":"This guide teaches you how to:\nEncrypt data using Lit Protocol\nEstablish a set of rules determining who can decrypt the data\nStore encrypted data on Arweave using Irys\nDecrypt data using Lit Protocol\n\nBefore diving into this guide, begin with \"Encrypting onchain data\".All of the code from this guide is also contained in GitHub repository.","dependencies#Dependencies":"Install using npm:\nnpm install @irys/sdk @lit-protocol/lit-node-client-nodejs@^3 dotenv ethers@^5 siwe@^2.1.4\nor yarn:\nyarn add @irys/sdk @lit-protocol/lit-node-client-nodejs@^3 dotenv ethers@^5 siwe@^2.1.4","imports#Imports":"import * as LitJsSdk from \"@lit-protocol/lit-node-client\";\nimport Irys from \"@irys/sdk\";\nimport { ethers } from \"ethers\";\nimport siwe from \"siwe\";\nimport dotenv from \"dotenv\";\ndotenv.config();","encrypting-data#Encrypting data":"","wallet-signature#Wallet signature":"A wallet signature (AuthSig) proves ownership of a wallet. By signing a basic transaction, regardless of its contents, you verify access to the wallet.First, create a file called .env with a single value, and include your private key.\nPRIVATE_KEY=\nThen, create a helper function that creates a message and signs it using your private key.\nLit Protocol supports both wallet signatures and session\nsignatures. This guide focuses solely\non wallet signatures, as session signatures are currently in development and only available for Ethereum.\n\nasync function getAuthSig() {\nconst litNodeClient = await getLitNodeClient();\n\nlet nonce = litNodeClient.getLatestBlockhash();\n\n// Initialize the signer\nconst wallet = new ethers.Wallet(process.env.PRIVATE_KEY);\nconst address = ethers.getAddress(await wallet.getAddress());\n\n// Craft the SIWE message\nconst domain = \"localhost\";\nconst origin = \"https://localhost/login\";\nconst statement = \"This is a test statement.  You can put anything you want here.\";\n\n// expiration time in ISO 8601 format.  This is 7 days in the future, calculated in milliseconds\nconst expirationTime = new Date(Date.now() + 1000 * 60 * 60 * 24 * 7).toISOString();\n\nconst siweMessage = new siwe.SiweMessage({\ndomain,\naddress: address,\nstatement,\nuri: origin,\nversion: \"1\",\nchainId: 1,\nnonce,\nexpirationTime,\n});\nconst messageToSign = siweMessage.prepareMessage();\n\n// Sign the message and format the authSig\nconst signature = await wallet.signMessage(messageToSign);\n\nconst authSig = {\nsig: signature,\nderivedVia: \"web3.eth.personal.sign\",\nsignedMessage: messageToSign,\naddress: address,\n};\n\nreturn authSig;\n}","access-control-conditions#Access control conditions":"Define rules for who to decrypt your data, limiting it to anyone with >= 0 ETH:\n// This defines who can decrypt the data\nfunction getAccessControlConditions() {\nconst accessControlConditions = [\n{\ncontractAddress: \"\",\nstandardContractType: \"\",\nchain: \"ethereum\",\nmethod: \"eth_getBalance\",\nparameters: [\":userAddress\", \"latest\"],\nreturnValueTest: {\ncomparator: \">=\",\nvalue: \"0000000000000\", // 0 ETH, so anyone can open\n},\n},\n];\n\nreturn accessControlConditions;\n}\nTo the wallet 0x50e2dac5e78B5905CB09495547452cEE64426db2\nconst accessControlConditions = [\n{\ncontractAddress: \"\",\nstandardContractType: \"\",\nchain,\nmethod: \"\",\nparameters: [\":userAddress\"],\nreturnValueTest: {\ncomparator: \"=\",\nvalue: \"0x50e2dac5e78B5905CB09495547452cEE64426db2\",\n},\n},\n];\nOr by people who hold a given ERC721:\nconst accessControlConditions = [\n{\ncontractAddress: \"0xA80617371A5f511Bf4c1dDf822E6040acaa63e71\",\nstandardContractType: \"ERC721\",\nchain,\nmethod: \"balanceOf\",\nparameters: [\":userAddress\"],\nreturnValueTest: {\ncomparator: \">\",\nvalue: \"0\",\n},\n},\n];","connecting-to-a-lit-node#Connecting to a Lit node":"Next, connect to a Lit node:\nasync function getLitNodeClient() {\n// Initialize LitNodeClient\nconst litNodeClient = new LitJsSdk.LitNodeClientNodeJs({\nalertWhenUnauthorized: false,\nlitNetwork: \"cayenne\",\n});\nawait litNodeClient.connect();\n\nreturn litNodeClient;\n}","encrypt-data#Encrypt data":"Finally, write a function that encrypts a string. In this guide we're using the Lit function encryptString() which encrypts a string and returns both the encrypted string and a hash of the original string. Lit also has encryptFile() for encrypting files directly.\nasync function encryptData(dataToEncrypt) {\nconst authSig = await getAuthSig();\nconst accessControlConditions = getAccessControlConditions();\nconst litNodeClient = await getLitNodeClient();\n\n// 1. Encryption\n// <Blob> encryptedString\n// <Uint8Array(32)> dataToEncryptHash\nconst { ciphertext, dataToEncryptHash } = await LitJsSdk.encryptString(\n{\nauthSig,\naccessControlConditions,\ndataToEncrypt: dataToEncrypt,\nchain: \"ethereum\",\n},\nlitNodeClient,\n);\nreturn [ciphertext, dataToEncryptHash];\n}","storing-on-arweave-via-irys#Storing on Arweave via Irys":"To use Irys to store data on Arweave, first connect to an Irys node. This function uses the same private key from our .env file and connects to the Irys Devnet where uploads are stored for 60 days. In a production environment, you would change this to use Irys' Node 1 or 2 where uploads are permanent.\nThis code is configured to MATIC to pay for uploads, and while working with the Irys Devnet, you need to fund your\nwallet with free MUMBAI MATIC Devnet tokens. Alternatively, you could use any other\nDevnet token supported by Irys.\n\nasync function getIrys() {\nconst url = \"https://devnet.irys.xyz\";\n// Devnet RPC URLs change often, use a recent one from https://chainlist.org/chain/80001\nconst providerUrl = \"\";\nconst token = \"matic\";\n\nconst irys = new Irys({\nurl, // URL of the node you want to connect to\ntoken, // Token used for payment\nkey: process.env.PRIVATE_KEY, // Private key\nconfig: { providerUrl }, // Optional provider URL, only required when using Devnet\n});\nreturn irys;\n}\nThen, write a function that takes the encrypted data, the original data hash, and the access control conditions, and stores it all on Arweave using Irys. Irys' upload function returns a signed receipt containing the exact time (in milliseconds) of the upload and also a transaction ID, which can then be used to download the data from a gateway.\nFor simplicity, we'll consolidate all three values into a JSON object and upload it to Irys in one transaction. This\nis a design choice; you have the flexibility to store these values as you see fit in your own implementation.\n\nasync function storeOnIrys(cipherText, dataToEncryptHash) {\nconst irys = await getIrys();\n\nconst dataToUpload = {\ncipherText: cipherText,\ndataToEncryptHash: dataToEncryptHash,\naccessControlConditions: getAccessControlConditions(),\n};\n\nlet receipt;\ntry {\nconst tags = [{ name: \"Content-Type\", value: \"application/json\" }];\nreceipt = await irys.upload(JSON.stringify(dataToUpload), { tags });\n} catch (e) {\nconsole.log(\"Error uploading data \", e);\n}\n\nreturn receipt?.id;\n}","decrypting-data#Decrypting data":"","retrieving-data-from-arweve-using-the-irys-gateway#Retrieving data from Arweve using the Irys gateway":"To download data stored on Arweave, connect to a gateway and request the data using your transaction ID.This function downloads the data JSON object, parses out the three values and returns them as an array of strings.\nasync function retrieveFromIrys(id) {\nconst gatewayAddress = \"https://gateway.irys.xyz/\";\nconst url = `${gatewayAddress}${id}`;\n\ntry {\nconst response = await fetch(url);\n\nif (!response.ok) {\nthrow new Error(`Failed to retrieve data for ID: ${id}`);\n}\n\nconst data = await response.json();\nreturn [data.cipherText, data.dataToEncryptHash, data.accessControlConditions];\n} catch (e) {\nconsole.log(\"Error retrieving data \", e);\n}\n}","decrypting-data-1#Decrypting data":"Finally, we decrypt the data using Lit's decryptString() function.\nasync function decryptData(ciphertext, dataToEncryptHash, accessControlConditions) {\nconst authSig = await getAuthSig();\nconst litNodeClient = await getLitNodeClient();\n\nlet decryptedString;\ntry {\ndecryptedString = await LitJsSdk.decryptToString(\n{\nauthSig,\naccessControlConditions,\nciphertext,\ndataToEncryptHash,\nchain: \"ethereum\",\n},\nlitNodeClient,\n);\n} catch (e) {\nconsole.log(e);\n}\n\nreturn decryptedString;\n}","main-function#Main function":"Now write a main() function that calls the calls our encrypt, store and decrypt code.\nasync function main() {\nconst messageToEncrypt = \"Irys + Lit is 🔥x2\";\n\n// 1. Encrypt data\nconst [cipherText, dataToEncryptHash] = await encryptData(messageToEncrypt);\n\n// 2. Store cipherText and dataToEncryptHash on Irys\nconst encryptedDataID = await storeOnIrys(cipherText, dataToEncryptHash);\n\nconsole.log(`Data stored at https://gateway.irys.xyz/${encryptedDataID}`);\n\n// 3. Retrieve data stored on Irys\n// In real world applications, you could wait any amount of time before retrieving and decrypting\nconst [cipherTextRetrieved, dataToEncryptHashRetrieved, accessControlConditions] = await retrieveFromIrys(\nencryptedDataID,\n);\n// 4. Decrypt data\nconst decryptedString = await decryptData(cipherTextRetrieved, dataToEncryptHashRetrieved, accessControlConditions);\nconsole.log(\"decryptedString:\", decryptedString);\n}\n\nmain();\nYou can also access the code as a single file in GitHub.","browser-based-example#Browser-based example":"Browser-based encryption","demo#Demo":"Irys Provenance Toolkit"}},"/":{"title":"Docs","data":{"":"Irys Docs\n\nUnlock the full potential of Irys' technology with our developer\nresources\n\n\n\n\n\n\nUse our SDK and start storing data permanently with 3 lines of code.\n\n\n\n\n\n\n\n\n\nWhat is Irys\n\n\n\n\nLearn more\n\n\n\n\n\n\n\n\n\n\nStart with tutorials and then join a global community of over 40,000\ndevelopers in our Quests program. Earn unique NFTs for every quest you\ncomplete."}},"/learn/bundling":{"title":"Bundling","data":{"":"Bundling\n\n\nIrys uses Bundling to help Arweave scale.\n\nUploading large numbers of files to Arweave can be technically challenging due to Arweave's limit of 1000 transactions per block. When demand spikes, that drives up fees, making permanent data unaffordable for many users. To address these challenges, bundlers are used to collate transactions into a single bundle and submit them to Arweave.These transactions are instantly retrievable and available to be queried. It is not necessary to wait for uploads to be confirmed and seeded on Arweave before they appear in query results.The implementation of bundlers and bundles has helped stabilize feeds on Arweave."}},"/learn/bundles":{"title":"Bundles","data":{"":"Bundles\n\n\n\nA bundle is a data structure representing a group of transactions. Any number of layer 2 data transactions can be compressed\nand included in a single bundle layer 1 transaction.","why-bundles#Why Bundles?":"Bundles allow for infinite transaction scaling - allowing up to 2^256 transactions to be stored in a single bundle. As bundle sizes increase, Arweave's transaction capacity can increase linearly - i.e. using 1 million item bundles allows for a 1,000,000x increase in layer 1 transaction capacity.The bundle spec, designed by Irys, is open-sourced and is currently implemented in JavaScript, Go, and Rust.To learn more, please refer to the spec documents."}},"/learn/funding-withdrawing":{"title":"Funding Withdrawing","data":{"":"Funding / withdrawing\n\n\n\nUsers fund nodes to pay for uploads. Funds can be withdrawn at any time.","tracking-deposits#Tracking Deposits":"Each Irys node has a collection of per-token wallets and an internal ledger system.The per-token wallets collect user deposits. All deposits for a given token are consolidated into a single designated wallet address.An internal ledger maintains a list of user wallet addresses, and records the amount deposited by each user into the node's corresponding wallet. This enables the system to accurately track each user's deposit history.In this system, every node has its own collection of wallets that records all deposits that take place on that node. Balances are not shared between nodes, each node is independent and self-contained.One of the benefits of not sharing balances between nodes is that it simplifies the process of scaling the system. By avoiding the need for shared state, each node can operate independently and be easily scaled up as needed.To see the list of wallets for a given node, append /info to the node address. The list for https://node2.irys.xyz/info is:\n{\n\"version\": \"0.2.0\",\n\"addresses\": {\n\"arweave\": \"ZE0N-8P9gXkhtK-07PQu9d8me5tGDxa_i4Mee5RzVYg\",\n\"ethereum\": \"0x474E7A206bd6186B0C51ad9b1D406c12c4fed9c1\",\n\"matic\": \"0x474E7A206bd6186B0C51ad9b1D406c12c4fed9c1\",\n\"bnb\": \"0x474E7A206bd6186B0C51ad9b1D406c12c4fed9c1\",\n\"avalanche\": \"0x474E7A206bd6186B0C51ad9b1D406c12c4fed9c1\",\n\"solana\": \"AFxXJjdXd4i4pvdFbYAd2TmJqQFu9aYCysAFRmPZ4jTo\",\n\"arbitrum\": \"0x474E7A206bd6186B0C51ad9b1D406c12c4fed9c1\",\n\"boba-eth\": \"0x474E7A206bd6186B0C51ad9b1D406c12c4fed9c1\",\n\"boba\": \"0x474E7A206bd6186B0C51ad9b1D406c12c4fed9c1\",\n\"chainlink\": \"0x474E7A206bd6186B0C51ad9b1D406c12c4fed9c1\",\n\"near\": \"bundlr2.near\",\n\"aptos\": \"0xed50b11ce7f4402bee43f357e593ca46515f530ecca991d1460dc0557617d033\"\n},\n\"gateway\": \"gateway.irys.xyz\"\n}","how-funding-works#How funding works":"The funding process is as follows:\nTokens are transferred from the user's wallet to the node's wallet address associated with the relevant token.\nThe transaction ID from the first step is forwarded to the selected Irys node.\nThe Irys node verifies that the transaction was directed to one of its designated wallets.\nOnce verified, the node proceeds to update an internal ledger that tracks the sender's wallet and the number of tokens transferred.","how-withdrawing-works#How withdrawing works":"The withdrawing process is as follows:\nThe node performs a validation of the request's field order and format, creates a deep hash of the supplied data, and subsequently verifies it using the provided signature.\nThe node checks if the request comes from a wallet listed on its internal ledger.\nThe node confirms if the requested withdrawal amount does not exceed the user's balance.\nThe requested funds are transferred back to the user from the node's wallet, with the user responsible for paying the associated gas fees for the transfer.\nThe internal ledger is updated with the user's new balance.\n\nThe request for withdrawal is sent as a JSON object with the following fields:\nconst data = {\nnonce,\npublicKey,\ntoken,\namount,\nsignature,\nsigType,\n};\n\nField\tDescription\tnonce\tA counter tracking the total number of withdrawals performed by this wallet (used to prevent man-in-the-middle attacks)\tpublicKey\tThe user's public key\ttoken\tThe token being withdrawn\tamount\tThe amount being withdrawn\tsignature\tSignature generated by hashing and then signing the token, amount, and nonce\tsigType\tUsed internally\n\nFor implementation and usage details, see the SDK documentation for fund()\nand withdrawBalance())."}},"/learn/irys-arweave":{"title":"Irys Arweave","data":{"":"Irys & Arweave\n\n\n\nIrys started out as a solution to both scale Arweave and reduce pain points experienced by developers. Our horizontal and linear scaling solutions radically increased transactions per second, from 9 TPS on Arweave directly to more than 50,000 TPS when using Irys.When uploading to Arweave, you pay for uploads in their native token AR, and sign the transaction using their native cryptography. The AR token isn’t widely available, and the cryptography needed to sign transactions isn’t as familiar to Web3 developers as the cryptography used by Ethereum and Solana. We eased this pain point by including support for 14 different tokens and their related cryptography. Developers can pay using the tokens they have and sign using any private key, including those from Solana and Ethereum.When uploading to Arweave, data is priced in increments of 256KB. This means if you upload 1KB or 255KB you pay the same. We eased this pain point by charging a straight fee per byte. You only pay for the data you need, no more.When uploading to Arweave, your transaction is considered confirmed once it’s included in a block. Your transaction is considered final once 50 confirmations have passed. With a block time of 2 minutes, it takes roughly 100 minutes before a transaction uploaded to Arweave can be considered final. Transaction finality is important, because in the event of a blockchain fork, only finalized transactions are guaranteed not to be dropped. We eased this pain point and streamlined the upload process by introducing optimistic finality.In addition to easing developer pain points encountered when working with Arweave, Irys also adds strong provenance to every upload."}},"/hands-on/tutorials/uploading-static-sites":{"title":"Uploading static websites","data":{"":"You can use Irys to upload entire static websites directly to the permaweb using only a few lines of code. You can use the uploadFolder() SDK function, or the upload-dir command with the CLI.","maintaining-link-structure#Maintaining link structure":"When you upload an entire folder of assets to Irys at the same time, two link structures are generated. You can download each asset directly using the transaction ID generated when uploading that unique asset. You can also download each asset using a link generated by combining the manifest ID generated for the entire folder upload with the relative path to the file.For example, if you upload a folder with the following structure:\nindex.html\nstyles.css\nimages/hero.jpg\nimages/logo.png\nyou can download the logo with the link https://gateway.irys.xyz/[manifest-id]/images/logo.png. Because relative paths are maintained, as long as your website uses relative links, you will not need to change any of your HTML when moving to the permaweb.","using-the-sdk#Using the SDK":"You can upload the entire website using the Irys SDK's uploadFolder() functions.\nimport Irys from \"@irys/sdk\";\nimport dotenv from \"dotenv\";\ndotenv.config();\n\nconst getIrys = async () => {\nconst url = \"https://devnet.irys.xyz\";\n// Devnet RPC URLs change often, use a recent one from https://chainlist.org/chain/80001\nconst providerUrl = \"\";\nconst token = \"matic\";\n\nconst irys = new Irys({\nurl, // URL of the node you want to connect to\ntoken, // Token used for payment and signing\nkey: process.env.PRIVATE_KEY, // ETH or SOL private key\nconfig: { providerUrl }, // Optional provider URL, only required when using Devnet\n});\nreturn irys;\n};\n\nconst uploadFolder = async () => {\nconst irys = await getIrys();\n\n// Upload an entire folder\nconst folderToUpload = \"./my-spa/\"; // Path to website folder\ntry {\nconst response = await irys.uploadFolder(\"./\" + folderToUpload, {\nindexFile: \"index.html\", // Your site's index file\nbatchSize: 50, // Number of items to upload at once\nkeepDeleted: false, // wWhether to keep now deleted items from previous uploads\n}); // Returns the manifest ID\n\nconsole.log(`Website uploaded. Manifest ID ${response.id}`);\n} catch (e) {\nconsole.log(\"Error uploading file \", e);\n}\n};","using-the-cli#Using the CLI":"You can also achieve the same using our CLI and the upload-dir command. Make sure to change the parameter options to provide your own private key and the name of your site's index file.\nirys upload-dir ./my-spa --index-file index.html -h https://node1.irys.xyz t -w bf20......c9885307"}},"/learn/strong-provenance":{"title":"Strong Provenance","data":{"":"Strong provenance\n\n\nAll data stored on Irys has strong provenance.Strong provenance, which includes permanence, precision, and unconstrained access, is the key to restoring clarity and confidence in the authorship and authenticity of data. It is best illustrated by the provenance trilemma showing the tradeoffs that proto-provenance layers made between data being permanent, precise, and unconstrained.","permanent#Permanent":"Data uploaded to Irys is stamped with a timestamp and attestation details before being passed to Arweave where it is stored permanently.","precise#Precise":"The timestamp assigned to transactions at upload is millisecond-accurate, this is unique in the blockchain space as most blockchains base their timestamps on block time. If the block time is 10 minutes - like with Bitcoin - then the timestamps generated by the chain are accurate to +/-10 minutes.The timestamp assigned by Irys is recorded in a signed receipt that can be verified by anyone at any time, even if Irys is no longer around. This timestamp can be used to chronologically order transactions.","unconstrained#Unconstrained":"Irys provides completely unconstrained provenance, there are no limits on file size uploads and there are no limits on who can verify the data.Irys is fully permissionless."}},"/learn/optimistic-cache":{"title":"Optimistic Cache","data":{"":"Optimistic cache\n\n\n\nThe optimistic cache ensures all data uploaded to Irys is immediately available via gateways, which\nare responsible for making data available to users.When a user requests data from a gateway, it searches for it in its local cache. If the data is not found, the gateway requests it from Arweave. If the data is still not found, the gateway requests it from Irys' optimistic cache. The optimistic cache is essential for providing users with real-time access to uploaded data, as it provides access to transactions that have not yet been seeded on Arweave, but are expected to be seeded soon.\n\nThe optimistic cache queries each Irys node sequentially until the data is found. Node 1 and 2 are queried first, followed by Devnet. If the data is found, it is returned instantly. Otherwise, a 404 code is returned.On Irys' Devnet, uploads are kept for approximately 60 days, during this time, the data is available from gateways in the same way that normal uploads are."}},"/hands-on/tutorials/vite":{"title":"Using Irys With React + Vite","data":{"":"This guide covers how to setup an Irys project using React + Vite.Setup a new project:\nmkdir irys-vite\ncd irys-vite\nnpm create vite@latest .\nnpm install\nChoose React and either TypeScript or JavaScript, then:\nnpm install\nInstall the Irys SDK and ethers:\nnpm install @irys/sdk ethers@5\nChange your App.tsx file as follows. This example uses ethere5, if you're using a different provider make sure to specify it when creating the wallet.\nimport \"./App.css\";\nimport { useState } from \"react\";\nimport { providers } from \"ethers\";\nimport { WebIrys } from \"@irys/sdk\";\n\nfunction App() {\nconst [connectedAddress, setConnectedAddress] = useState<string>(\"\");\n\nconst getWebIrys = async () => {\nawait window.ethereum.enable();\nconst provider = new providers.Web3Provider(window.ethereum);\nconsole.log(\"provider=\", provider);\nconst url = \"https://node1.irys.xyz\";\nconst token = \"matic\";\n\nconst wallet = { name: \"ethersv5\", provider: provider };\nconsole.log(\"wallet=\", wallet);\nconst webIrys = new WebIrys({ url, token, wallet });\nconsole.log(\"webIrys=\", webIrys);\nawait webIrys.ready();\nsetConnectedAddress(webIrys.address);\n};\n\nreturn (\n<>\n<h1>Vite + React + Irys</h1>\n{connectedAddress && connectedAddress.length > 0 && <h3>Connected from: {connectedAddress}</h3>}\n<div className=\"card\">\n<button onClick={getWebIrys}>Connect To Irys Node</button>\n</div>\n</>\n);\n}\n\nexport default App;\nWhen you load your app, you will see a blank white screen and find the following in your developer console.\nVite error\nClass extends value undefined is not a constructor or null\nTo fix this, first install:\nnpm install -D crypto-browserify stream-browserify os-browserify path-browserify vite-plugin-node-polyfills vite-plugin-notifier\nAnd then modify vite.config.ts to use the following:\nimport { defineConfig } from \"vite\";\nimport react from \"@vitejs/plugin-react\";\nimport { nodePolyfills } from \"vite-plugin-node-polyfills\";\n\n// https://vitejs.dev/config/\nexport default defineConfig({\nresolve: {\nalias: {\nprocess: \"process/browser\",\npath: \"path-browserify\",\nos: \"os-browserify\",\n},\n},\nplugins: [\nreact(),\nnodePolyfills({\n// To exclude specific polyfills, add them to this list.\nexclude: [\n\"fs\", // Excludes the polyfill for `fs` and `node:fs`.\n\"stream\",\n],\n// Whether to polyfill specific globals.\nglobals: {\nBuffer: true,\nglobal: true,\nprocess: true,\n},\n// Whether to polyfill `node:` protocol imports.\nprotocolImports: true,\n}),\n],\n});\nRestart React+Vite and you should be good to go."}},"/learn/udl":{"title":"Udl","data":{"":"UDL & builders\n\n\n\nThe Universal Data License (UDL) provides content creators with a straightforward way to define how their content can be used, along with the prices they set for its use. It is a standardized and parameterized approach that opens up new financial opportunities for creators and builders.","content-marketplaces#Content marketplaces":"Traditionally, online content sales tied creators to the licensing terms of individual platforms. This meant conforming to multiple different agreements for streaming on platforms, like with Spotify and Apple Music. These platforms are designed to extract the maximum value from creators, leaving them with only a small percentage of revenue, and while major artists might have the power to negotiate better terms, most creators find themselves constrained.With the UDL, creators can detail exactly how they allow their content to be used. Using the UDL, marketplaces can then identify and autonomously promote content, bypassing manual permissions as the licensee has already granted approval.","udl-and-nfts#UDL and NFTs":"NFT ownership is managed by a smart contract, and while the contract clearly calls out who owns which NFT, it does nothing to define what usage rights are granted to each owner. This means each NFT comes with unique rights, and that owners end up having to wade through detailed contracts to understand. For example, purchasing a Bored Apes NFT offers the buyer expansive rights, even allowing them to feature the NFT in media productions. Conversely, with Coke's NFT release, owning the NFT doesn't authorize you to repurpose the Coke logo for competing ventures.The Universal Data License (UDL) provides a structured way to clarify these permissions for NFT holders. To add a UDL to an NFT, creators simply need to incorporate UDL-specific tags when uploading NFT metadata.We also have a tutorial on adding a UDL to NFTs.","udl-and-ai#UDL and AI":"The UDL introduces the Derivation tag, specifically designed to grant the right to create derivative works based on the original content. When considering the training of AI models, especially those that generate images, the source data's licensing terms are crucial. AI models ingest and learn from this data, with the quality and diversity of the input data directly influencing the type of images the AI produces.If an AI is trained on data protected by copyrights that prohibit the creation of derivative works, users run the risk of violating these copyrights when using the AI's outputs. Conversely, training an AI exclusively on data that explicitly permits the creation of derivative works ensures that all images or outputs generated by that AI remain free from potential copyright infringements.","udl-and-creative-commons#UDL and Creative Commons":"The UDL and Creative Commons (CC) both aim to empower creators by giving them tools to define the terms under which their content can be used. However, a key distinction between them is the parameterized nature of the UDL.While Creative Commons offers a set of predefined licenses, each with its own fixed terms, the UDL allows creators to define specific usage terms via standardized metadata. This means that with the UDL, creators can customize license terms when they upload content by setting metadata tags. In contrast, Creative Commons' static nature requires creators to pick from the available licenses without the ability to customize individual parameters.Additionally, CC is primarily focused on credit and attribution, it doesn’t define terms for fees or revenue share. UDL is both more customizable than CC and more expansive.","udl-is-not-drm#UDL is not DRM":"The UDL is a licensing framework, and Digital Rights Management (DRM) is a set of access control technologies that limit the use of digital media or devices after sale. They are two different, but complementary technologies. While UDL defines usage terms via metadata, it doesn't enforce any control of content access. Encryption-based DRM could be used alongside UDL to enforce the terms specified, ensuring both clarity of rights and security of content.","crosschain-opportunities#Crosschain opportunities":"One potential way to manage ownership of UDL assets is with the use of custom tokens. You’d do this by creating a smart contract that creates a new token with a fixed supply. The tokens would be fully tradeable and their ownership would represent ownership of the UDL asset. The smart contract would expose a function that accepts revenue payments and automatically distributes them proportionally based on token ownership.If you’re interested in learning more, we have a tutorial on building an ERC20 token to manage UDL ownership.","opportunities-for-builders#Opportunities for Builders":"UDL is a set of rules and notably does not include any definition for how those rules are to be enforced. This opens up significant opportunities for builders looking to make an impact in the space.Opportunities like:\nBuilding an NFT platform where users can easily define licensing rules for their creations.\nAn AI image generation model trained only on assets that allow derivative works.\nA TikTok-like app that allows users to remix songs that allow derivative works to be created.\nA platform for automatically deploying ERC20 tokens to manage ownership of UDL content.\nA DRM system that uses LitProtocol to encrypt data, and making it available under terms defined by the UDL.\n\nWhat will you build?"}},"/learn/volumetric-scaling":{"title":"Volumetric Scaling","data":{"":"Volumetric scaling\n\n\n\nIrys’ scaling is volumetric because it can independently scale across three vectors: writing, reading, and verification. This scaling architecture enables each axis to adapt to meet fluctuating demand.","bundlers-writers#Bundlers (writers)":"Arweave has a limit of 1,000 transactions per block. When demand surges, fees shoot up, and spikes in network traffic can cause fees to increase exponentially, rendering permanent data unaffordable for many users. To solve this problem, Irys uses bundlers to collate transactions together into a bundle before submitting them to Arweave as a single transaction. Irys handles over 90% of all traffic on Arweave, has been tested at 50K TPS, and could easily scale to over 1,000,000 TPS.","gateways-readers#Gateways (readers)":"Gateways are responsible for indexing, serving, and making data and transactions on Arweave available to users.While many users rely on well-known gateways such as arweave.net and gateway.irys.xyz, it's also possible to run your own gateway using the AR.io open-source offering. This means that anyone can spin up a new gateway at any point in time to meet their unique demand requirements.","verification#Verification":"When you upload a transaction to Irys, you’re given a receipt containing a millisecond-accurate timestamp, authorship details, and other metadata. This receipt can be permissionlessly verified either by manually creating a deep hash of all its fields and comparing it against the receipt's signature or by using the SDK function irys.utils.verifyReceipt(), an abstraction of the manual verification process.","transaction-verification#Transaction verification":"In addition to verifying receipts, you can verify transactions by creating a deep hash of all transaction fields and verifying that the transaction signature was generated using the deep hash.","volumetric-scaling-now-and-in-the-future#Volumetric scaling now and in the future":"Irys is a fully unconstrained point of entry to Arweave, making permanent data with strong provenance accessible with just a few lines of code. Irys can handle millions of transactions per second and limitless data volumes, all while being permissionlessly verifiable. Arweave scales horizontally by increasing the number of miners storing data; therefore, more miners on Arweave means more bandwidth on the network.Irys is designed to handle more than just current demand; we're built for growth. Our scalability tests go beyond today's needs, ensuring we're prepared for what comes next.We're future-proof."}},"/learn/receipts":{"title":"Receipts","data":{"":"Receipts\n\n\n\nReceipts give you cryptographic proof of the exact time, accurate to the millisecond, that a transaction occurred.","receipts--timestamps#Receipts & Timestamps":"When you upload data to Irys, it is stamped with a millisecond-accurate timestamp before being passed to Arweave where it is stored permanently.Blockchains rely on timestamps to sequence the order of transactions and blocks. Transaction sequencing plays a critical role in blockchain security as it ensures that all transactions are recorded in the correct order, and that order is never changed.Receipts provide cryptographic proof of a timestamp. This creates a secure and tamper-proof sequence of all transactions, enabling proof of authenticity, permanence, and provenance.","ordering--streaming#Ordering & streaming":"Ordering and streaming applications process and deliver data in real-time. They're commonly used for messaging, event processing, and data integration. They transfer high data volumes between independent applications while maintaining high performance and scalability. Popular examples include Apache Kafka and RabbitMQ.Users could use Irys' receipts to:\nBuild a category-based event streaming application by using Irys query package","why-use-signed-receipts#Why use signed receipts?":"Cryptographically signed receipts open up new development options for builders. For example:\nSequential ordering of posts, likes and comments for a decentralized social protocol.\nSequential ordering of data generated by a group messaging protocol.\nAutomatically adjudicating music copyright claims.\nPreserving history, ensuring it's not manipulated over time.\nPreserving scientific research using Irys' pay-once, store-forever model.","receipt-permanence#Receipt permanence":"Upon posting a transaction to Irys, a receipt is immediately returned to the user.Irys maintains an internal registry of all receipts, which can be queried whenever a receipt is needed. These receipts are stored in a centralized fashion, which may be sufficient for users comfortable with the trust assumptions of centralized services.Users also have the option to use Irys to store the receipt on Arweave. These receipts inherit Arweave’s permanence, meaning you can verify transaction sequencing at any time, even if Irys is no longer available.","receipt-format#Receipt format":"Receipts are a JSON object with the following format:\n{\nid: '1Txlbl5NgEqUbIkDnnunHC0gFx0n8_Y92zAsoX54kI8',\ntimestamp: 1676891681110,\nversion: '1.0.0',\npublic: '...',\nsignature: '...',\ndeadlineHeight: ...,\nblock: ...,\nvalidatorSignatures: [],\n}\n\nField\tDescription\tid\tTransaction id (used to download the data)\ttimestamp\tTimestamp (UNIX milliseconds) of when the transaction was created\tversion\tThe version of this JSON file, currently 1.0.0\tpublic\tPublic key of the bundler node used\tsignature\tA signed deep hash of the JSON receipt\tdeadlineHeight\tThe block number by which the transaction must be finalized on Arweave\tblock\tDeprecated\tvalidatorSignatures\tDeprecated","verifying-receipts#Verifying receipts":"You may need to verify a receipt at some point after it was issued. For example, if your application’s security depends on the order of transactions, you can then verify every receipt to ensure its order has not been tampered with.The receipt contains a signature field, which is generated by creating a deep hash of information from the receipt, including transaction ID and timestamp. It is then signed it by Irys.Using the Irys SDK you can verify the signature using the using the same values from the receipt along with the supplied public key.","timestamp-generation#Timestamp generation":"Irys records the precise time of each transaction with a UNIX timestamp in milliseconds. This timestamp is generated by the node that first receives and verifies the transaction."}},"/learn/transaction-lifecycle":{"title":"Transaction Lifecycle","data":{"":"Transaction lifecycle\n\n\n\nWhen you post a transaction to Irys, you are instantly given back a signed receipt from the node you upload to. While it takes over 100 minutes to achieve transaction finality on Arweave, we optimistically consider the transaction final at upload time as our nodes have internal safeguards that ensure transaction finality on Arweave.Internally, all data submitted to Irys is collected by a bundler. Roughly every 2 minutes, the bundler groups transactions, merges them into a single bundle, and submits them to Arweave.Since we’re submitting data to Arweave, it’s important to understand what happens over there too.Arweave currently uses its 2.x transaction format, which includes an id, a signature, a public key, meta tags, and the amount of money you’re sending. While the 1.0 format included your data, the 2.0 format notably does not include your data. The reason they moved away from including the data in the transaction was to accommodate larger uploads. With a block time of roughly 2 minutes, the maximum upload to Arweave was limited by network transmission speeds. The laws of physics and the current state of network hardware created an upper limit on data size which constrained Arweave’s ability to scale.\nThere are no limits restricting the amount of data that can be uploaded to Arweave via Irys.\nIn the current 2.6 Arweave version, miners submit the smaller header information first, and then they seed the actual data to their peers afterward. To incentivize miners to store as much data as possible, Arweave operates under a protocol called Succinct Proof of Random Access (SPoRA) where miners need to prove they have access to a random piece of historical data. The more data a miner stores, the greater the number of mining rewards they can earn. Miners have the option of how much data to store, and while there are storage costs associated with storing the full dataset, storing data is also the path to earning more mining rewards.\n\nAfter submitting your transaction header to Arweave, Irys continually monitors the submission, if finality is not achieved,\nthe transaction is automatically resubmitted.In addition to submitting the transaction header, Irys also submits your data to a network of miners. In general, your data is submitted to a minimum of 10 miners and is guaranteed to be seeded to a minimum of 3 miners.Irys decides which miners to seed your data to based on our internal reliability score. We constantly scan Arweave, starting first at a known miner, then recursively scanning all of its peers, all of those peer’s peers, and so on. Each miner is given a reliability score that while initially based on the scores of its peers, is continually updated based on that miner’s behavior. Miners are praised for good behavior and punished for bad behavior. As any one instance of bad behavior can be detrimental to the network, we use a logarithmic scoring system. The higher a miner’s score, the harder it becomes to increase that score. However, any instance of bad behavior causes an immediate and linear decrease in a miner’s score. Miners are extra careful to avoid bad behavior as a single instance will cause their score to drop significantly and due to the logarithmic scoring system, it will then take time to rebuild a previous reliability score.Our praise and punish reputation system has an additional added benefit of helping responsible miners earn greater rewards. Responsible behavior leads to a higher reputation score, a higher score means we seed data directly to them, which means they’re able to supply the recall block quicker, which in turn means they’re able to complete the block quicker and earn greater rewards."}},"/overview/about":{"title":"About","data":{"":"Irys is the only provenance layer. It enables users to scale permanent data and precisely attribute its origin.A provenance layer is a ledger of record for digital information, tracking the origins and modifications of data.Data uploaded to Irys is permanent, precise, and unconstrained.\nPermanent\nData stored on Irys is censorship-resistant and immutable, forever. There's no counterparty\nrisk of data being removed.\nPrecise\nEach piece of data is timestamped with a high-precision timestamp, providing a reliable sequence of\nevents.\nUnconstrained\nUsers can always read, write, and easily discover data at any scale, making the data fully composable. Irys is permissionless\nand offers limitless permanent data, enabling it to provide provenance for all information.\n\nAll uploads to Irys are verifiable. After uploading data, you’re given a receipt that can be used by anyone to verify the data’s provenance at any time.","building-with-irys#Building with Irys":"Irys' developer tools make it easy to add permanent data with strong provenance to your projects."}},"/overview/cost-to-upload":{"title":"Cost to Upload","data":{"":"Cost to upload\n\n\n\nThe cost to upload data to Arweave using Irys is based on the number of bytes uploaded.","price-calculator#Price calculator":"The calculator provides the real-time cost of permanently uploading your data.","fee-breakdown#Fee breakdown":"Fees are computed as follows:\nirys_fee(X = number of bytes) =\narweave_cost(max(X, 10000)) *\nconversion_rate(\"AR\", token) *\nglobal_multiplier *\noracle_fee\n\narweave_cost is cost of storing X number of bytes on Arweave using linear pricing (i.e. ignoring minimum chunk size). e.g. if arweave_cost(256KB) = $2.56 then arweave_cost(1KB) = $0.01\nconversion_rate is the conversion rate between AR and some other token (e.g. MATIC). This allows users to pay the same fees in different currencies.\nglobal_multiplier is a multiplier applied to all transactions which can be seen as a “profit margin”.\noracle_fee is a risk multiplier which accounts for cost of treasury management and asset volatility.","free-uploads#Free uploads":"Uploads below 100 KiB are free on Node 2. This is a public good for users to be encouraged to try Irys. Uploads are rate-limited to 600 transactions per minute, with upload counts resetting every minute.If you upload more than 600 transactions within a minute and have a funded balance on Node 2 that balance will be used to pay for the transaction. If you don't have a balance, then you'll get a 402 - Free transaction limit exceeded, funds required error."}},"/overview/gateways":{"title":"Gateways","data":{"":"Gateways\n\n\n\nGateways are responsible for indexing, serving, and making data available to users.","indexing#Indexing":"To ensure that all transactions on Arweave are easily searchable and accessible, gateways index all transaction metadata, including transactions posted via Irys, and transactions posted directly to Arweave. Gateways monitor Arweave for new blocks, and indexes them as they are propagated. Whenever a user posts a transaction to Irys, gateways detect it and add it to its own database.During the indexing process, gateways extract transactions from each block and index the metadata. When a bundle is encountered, gateways index all the transactions within. Similarly, if a manifest is found, gateways indexes it. By indexing manifests, gateways create a virtual directory structure that mimics the original folder system. This allows users to access data using the URL format https://gateway.irys.xyz/[manifest-id]/[file-name].","querying#Querying":"Transaction metadata can be queried directly using the Irys query package a REST API or GraphQL. This enables users to create tailored queries, such as searching for specific tags or addresses.Irys supports adding custom metadata tags to each upload, these tags allow users to build data models, all queryable via GraphQL.When a user posts a transaction to Irys, gateways pick it up and store it in their database. This allows gateways to support optimistic GraphQL, meaning query results include both transactions seeded on Arweave as well as those expected to be seeded soon. This ensures users have access to the most up-to-date data and can use it to build real-time applications.","serving-data#Serving Data":"When a transaction is seeded on Arweave, its header and data are stored separately (as explained\nin transaction lifecycle). To access this data, users request\nit from a gateway. Because it can be complex, computationally heavy, and difficult for average\nusers to access data directly from miners on Arweave, gateways are crucial in making downloading\ndata as simple as uploading.When a user requests data from a given gateway, the gateway first checks its internal cache, serving the data from there if it's available. If not, the gateway then checks Arweave to see if the data is stored there. If found, that gateway retrieves the data and serves it to the user, caching it for future use and providing faster response times for frequently requested data.If the data is not found on Arweave or the gateway’s local cache, the gateway checks Irys' optimistic cache to see if the data is available. By doing this, the gateway allows for instant access to data uploaded to Irys, even if it hasn't been finalized on Arweave. This also means data uploaded to Irys' Devnet, where uploads are kept for approximately 60 days, is available via gateways.","scaling#Scaling":"Gateways are a crucial component in Irys' scaling strategy. To effectively scale, it's important to separate read and write components so they can be optimized independently. In Irys' approach, bundlers handle writing while gateways handle reading.","gateway-schema--endpoints#Gateway schema / endpoints":"To download data from a gateway, use the transaction id obtained during upload. The most commonly used gateway is https://gateway.irys.xyz, and the format used to download data is https://gateway.irys.xyz/[transaction-id].For example https://gateway.irys.xyz/CO9EpX0lekJEfXUOeXncUmMuG8eEp5WJHXl9U9yZUYA.For GraphQL queries, you can connect to either of these official endpoints:\nhttps://gateway.irys.xyz/graphql\nhttps://arweave.dev/graphql\n\nOr this endpoint from Goldsky which offers fast response times:https://arweave-search.goldsky.com/graphql"}},"/overview/permanent-data":{"title":"Permanent Data","data":{"":"Permanent data\n\n\nPermanence guarantees your data can be retrieved at any point in the future.\n\nPermanent data is fault-tolerant, tamperproof, and paid-for:\nFault-tolerant\nData is stored so that it can survive unexpected events, including data corruption and loss.\nTamperproof\nStored data is immutable, it can’t be maliciously changed.\nPaid-for\nThe cost of storing the data permanently is covered up-front, and there is a mechanism for paying miners on an acceptable\ncadence.","fault-tolerant#Fault-tolerant":"Your data is replicated across multiple Arweave nodes. Current estimates show there are 781+ complete replicas of the data, ensuring that no number of failed drives or natural disasters can damage your data.","tamperproof#Tamperproof":"Your data is identifiable by a unique identifier formed by hashing the upload. Every piece of data produces a distinct hash, even a minute change in the original content results in a completely different identifier. This makes it easy to verify and ensure that the stored data remains unaltered over time.","paid-for#Paid-for":"When you upload data you pay a single up-front fee. The upload fee is divided, 5% is paid to the miner who includes your transaction in a winning block, and 95% is reserved for future funding of storage via the Arweave endowment.The Arweave endowment uses the current cost of storage combined with a conservative estimate of how much storage costs decline year on year to ensure there are always enough funds available to pay miners for continued storage. Arweave has published simulations showing how the current endowment will last at least 10,000 years.","how-will-this-evolve#How will this evolve?":"The Arweave endowment is based on current storage technology, their current cost and declining costs over time. The Arweave yellow-paper acknowledges that the most important thing is data permanence, not network permanence and at some point in the future when \"a permanent information storage system more suited to the challenges of the time emerges, the Arweave’s data will be ‘subsumed’ into this network.\"","why-does-permanent-data-matter#Why does permanent data matter?":"Permanence ensures the security of all data posted to Irys. No hostile party, not even a government, can alter this.It also enables composability. Chunks of permanent data can be used as primitives to power the next iteration of the internet, the permaweb.Irys enables a global dataset that will always be reliable and accessible.","getting-started#Getting started":"You can permanently upload data in 3 lines of code.\n// Connect to a node\nconst irys = new Irys({ url, token, key });\n\n// Fund the node\nconst fundTx = await irys.fund(irys.utils.toAtomic(0.05));\n\n// Upload data\nconst receipt = await irys.uploadFile(\"./myImage.png\");\nFor full code examples you can copy and paste into your projects, check out our SDK.If you are builing a browser-based app, check out Irys in the browser, and the Provenance Toolkit, a suite of UI open-source UI components for managing node balances and uploading files.Our query package contains everything you need to search Irys transaction metadata.Beginners should start with our SDK tutorial.","what-can-you-build-with-permanent-data#What can you build with permanent data?":"Learn more in our use-cases section."}},"/overview/fees":{"title":"Fees","data":{"":"Fees\n\n\nIyrs' fee is dynamic and depends on several parameters.\n\nFees are computed as follows:\nirys_fee(X = number of bytes) =\narweave_cost(max(X, 10000)) *\nconversion_rate(\"AR\", token) *\nglobal_multiplier *\noracle_fee\n\narweave_cost is cost of storing X number of bytes on Arweave using linear pricing (i.e. ignoring minimum chunk size). e.g. if arweave_cost(256KB) = $2.56 then arweave_cost(1KB) = $0.01\nconversion_rate is the conversion rate between AR and some other token (e.g. MATIC). This allows users to pay the same fees in different currencies.\nglobal_multiplier is a multiplier applied to all transactions which can be seen as a “profit margin”.\noracle_fee is a risk multiplier which accounts for cost of treasury management and asset volatility.","free-uploads#Free uploads":"Uploads below 100 KiB are free on Node 2. This is a public good for users to be encouraged to try Irys. Uploads are rate-limited to 600 transactions per minute, with upload counts resetting every minute.If you upload more than 600 transactions within a minute and have a funded balance on Node 2 that balance will be used to pay for the transaction. If you don't have a balance, then you'll get a 402 - Free transaction limit exceeded, funds required error."}},"/overview/nodes":{"title":"Nodes","data":{"":"Nodes\n\n\n\nIrys has three nodes:\nhttps://node1.irys.xyz\nhttps://node2.irys.xyz\nhttps://devnet.irys.xyz\n\n\nOur Node URLs have recently changed from bundlr.network to irys.xyz, if you have an existing project, see our\nmigration guide for details on how to upgrade.","mainnet#Mainnet":"Uploads to Irys' Mainnet (Nodes 1 and 2) are stored permanently on Arweave. Your upload will remain accessible at all times, even if Irys is no longer available.Uploads of less than 100 KiB are free on Node 2.Uploads can be paid for in any of the 16 tokens we support.","devnet#Devnet":"Uploads to Irys' Devnet are kept for roughly 60 days. The Devnet is for building and prototyping projects along with learning our SDK.Uploads can be paid for using free tokens available from faucets.","chain-integrations#Chain integrations":"Irys is multichain, supporting both paying for uploads with 16 tokens and signing that upload using the token’s cryptography. The signature type used to sign a transaction is tracked at the transaction-level.","connecting-to-a-node#Connecting To A Node":"See our docs for code samples showing how to connect to an Irys node when uploading, and when querying."}},"/overview/tools":{"title":"Tools","data":{"":"Tools\n\n\nGet started building with Irys today.\n\n\n\nIrys SDK\n\nPermanent data with strong provenance using only three lines of code using our SDK.\n\nCLI\n\nPermanent data with strong provenance from your CLI.\n\nProvenance Toolkit\n\nRapidly build your next project using our library of UI components.\n\nIrys query package\n\nQuery Irys and Arweave transactions using our JavaScript package.\n\nArweave package\n\nA fork of arweave-js that introduces better typing, increased NodeJS\ncompatibility, and better support for using streams.\n\nWhistleblower\n\nA light client for monitoring Irys nodes and ensuring transactions are finalized on Arweave and seeded to miners.\n\nExplorer\n\nA transaction explorer and analytics platform for Irys."}},"/overview/ordering":{"title":"Ordering","data":{"":"Ordering\n\n\nIrys enables users to instantly sequence data with extreme precision.\n\nThis supports applications that require a guarantee on order such as execution layers (rollups),\nmessaging and event processing, among others.","proof-of-time#Proof of time":"Each transaction comes with a signed receipt that includes a verifiable timestamp, which is accurate to the millisecond. With this, users can always rely on the chronology of their data.","search-seamlessly#Search seamlessly":"Tags categorize transactions. Timestamps order them. Together, tags and timestamps enable users to categorize and order their data to efficiently search for data with single queries.","getting-started#Getting started":"You can upload multiple transactions and sequence them using our SDK and query package in a few lines of code.","uploading#Uploading":"// Connect to a node\nconst irys = new Irys({ url, token, key });\n\n// Fund the node\nconst fundTx = await irys.fund(irys.utils.toAtomic(0.05));\n\n// Tag your uploads\nconst tags = [{ name: \"application-id\", value: \"my-tx-sequence\" }];\n\n// Upload 10 transactions\nfor (let i = 0; i < 10; i++) {\nconst receipt = await irys.upload(\"GM \" + i, { tags });\nconsole.log(`Transaction #${i} uploaded at ${receipt.timestamp}`);\n}","ordering#Ordering":"const myQuery = new Query();\nconst results = await myQuery\n.search(\"irys:transactions\")\n.tags([{ name: \"application-id\", values: [\"my-tx-sequence\"] }])\n.sort(\"ASC\")\n.stream();\n\n// Iterate over the results\nfor await (const result of stream) {\nconsole.log(result);\n}"}},"/overview/supported-tokens":{"title":"Supported Tokens","data":{"":"Tokens\n\n\nIyrs supports 16 tokens used when paying for and signing uploads.","mainnet-tokens#Mainnet tokens":"On Nodes 1 and 2 can pay for uploads in any of these tokens:\nToken / Blockchain\tToken\tParameter Value\tIrys Support\tWebIrys Support\tAptos\tAPT\taptos\tyes\tyes\tAlgorand\tALGO\talgorand\tyes\tno\tArbitrum\tETH\tarbitrum\tyes\tyes\tArweave\tAR\tarweave\tyes\tyes (via Arconnect)\tAvalanche C-Chain\tAVAX\tavalanche\tyes\tyes\tBinance Coin\tBNB\tbnb\tyes\tyes\tBoba\tBOBA\tboba\tyes\tyes\tBoba-eth\tETH\tboba-eth\tyes\tyes\tChainlink\tLINK\tchainlink\tyes\tyes\tEthereum\tETH\tethereum\tyes\tyes\tBase Ethereum\tETH\tbase-eth\tyes\tyes\tFantom\tFTM\tfantom\tyes\tyes\tNear\tNEAR\tnear\tyes\tyes\tPolygon\tMATIC\tmatic\tyes\tyes\tSolana\tSOL\tsolana\tyes\tyes\tUSDC (on Ethereum)\tUSDC\tusdc-eth\tyes\tyes\tUSDC (on Polygon)\tUSDC\tusdc-polygon\tyes\tyes","devnet-tokens#Devnet tokens":"On Devnet, you can pay for uploads in any of these tokens:\nToken / Blockchain\tToken\tParameter Value\tIrys Support\tWebIrys Support\tAptos\tAPT\taptos\tyes\tyes\tAlgorand\tALGO\talgorand\tyes\tno\tArbitrum\tETH\tarbitrum\tyes\tyes\tAvalanche C-Chain\tAVAX\tavalanche\tyes\tyes\tBerachain\tBERA\tbera\tyes\tyes\tBinance Coin\tBNB\tbnb\tyes\tyes\tChainlink\tLINK\tchainlink\tyes\tyes\tEthereum (Sepolia)\tETH\tethereum\tyes\tyes\tBase Ethereum (Sepolia)\tETH\tbase-eth\tyes\tyes\tNear\tNEAR\tnear\tyes\tyes\tPolygon (Mumbai)\tMATIC\tmatic\tyes\tyes\tSolana\tSOL\tsolana\tyes\tyes\tUSDC (on Ethereum)\tUSDC\tusdc-eth\tyes\tyes\tUSDC (on Polygon)\tUSDC\tusdc-polygon\tyes\tyes","specifying-token#Specifying token":"To use a different token, link your private key and supply the token name when creating a new Irys object. The accepted values for token are listed in the third column of the tables above.Example:\nconst getIrys = async () => {\nconst url = \"https://devnet.irys.xyz\";\n// Devnet RPC URLs change often, use a recent one from https://chainlist.org/chain/80001\nconst providerUrl = \"\";\nconst token = \"matic\";\n\nconst irys = new Irys({\nurl, // URL of the node you want to connect to\ntoken, // Token used for payment\nkey: process.env.PRIVATE_KEY, // ETH or SOL private key\nconfig: { providerUrl }, // Optional provider URL, only required when using Devnet\n});\nreturn irys;\n};"}},"/overview/querying-tagging":{"title":"Querying Tagging","data":{"":"Querying & tagging\n\n\nUsers can add custom metadata tags to each upload, these tags allow users to build semi-relational data models, all instantly queryable.","tagging#Tagging":"Irys supports attaching metadata tags to each transaction.Tags can be used to:\nCategorize transactions, making it easier to search for and retrieve relevant information using GraphQL\nBuild mutable references\nInform web browsers how to render image files","querying#Querying":"Contained within the transaction header is the metadata, this is available for querying via our query package and GraphQL."}},"/terminology":{"title":"Terminology","data":{"":"Terminology\n\n\nTechnical terms to help you understand Irys\n\nBundle | Bundler | Deep Hash | Provenance | Provenance Layer | Proto-provenance layer | Gateways | Optimistic finalization | Provenance | Transaction | Transaction Receipt","bundle#Bundle":"A set of transactions joined into a single Arweave transaction.","bundler#Bundler":"A node on Irys that receives transactions, handles payment channels and produces bundles.","deep-hash#Deep Hash":"A hash algorithm that takes a nested list of values as input and produces a 384 bit hash, where a change of any value or the structure will affect the hash.","provenance#Provenance":"The history of data. It can describe where data came from, how it was created, and who has handled it. Data provenance provides transparency into the lifecycle of data and is critical for building trust in the data.","gateways#Gateways":"Nodes that listen to both bundlers and the Arweave L1 with the purpose of aggregating and indexing transactions. This allows you to retrieve and lookup transactions from clusters of bundlers without maintaining your own index.","optimistic-finalization#Optimistic finalization":"An incentive mechanism used by Irys to provide instant upload times.On Arweave, a block is considered confirmed after 50 block confirmations. Data is considered seeded after it is stored by a minimum number of miners. This can take up to 100 minutes.When you post a transaction to Irys, you are given a signed receipt. At this point, we can optimistically consider the transaction final because there is a greater financial incentive for nodes to behave honestly than there is for malicious behavior.","provenance-1#Provenance":"The issuing of signed receipts, including a timestamp accurate to the millisecond, that provide irrefutable proof of data provenance.","provenance-layer#Provenance layer":"A ledger of record for digital information that tracks the origins and modifications of data. Data on a provenance layer must be permanent, precise, and unconstrained.","proto-provenance-layer#Proto-provenance layer":"Previous projects that have provided degrees of provenance, but have fundamentally failed to be provenance layers. They fail to fulfill the Provenance Trilemma, by either not being permanent, precise or unconstrained.","provenance-trilemma#Provenance Trilemma":"A representation of the tradeoffs proto-provenance layers have had to make in the past. It describes the tradeoffs between data being permanent, precise, and unconstrained.","transaction#Transaction":"A single item sent to a specific address, usually contains a data payload.","transaction-receipt#Transaction Receipt":"A proof that an Iyrs transaction gets on to Arweave by an expected block.\nThe transaction receipt format is."}}}